<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>An allocator-aware optional type</title>
        <meta content='text/html; charset=UTF-8'/>
	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	tab { padding-left: 2em; }
        
	tab0 { padding-left: 0em; }
	tab1 { padding-left: 2em; }
    tab2 { padding-left: 4em; }
    tab3 { padding-left: 6em; }
    tab4 { padding-left: 8em; }
	ins {background-color:#A0FFA0}
	del {background-color:#FFA0A0}
	</style>
</head>
<body>

<address align=right>
Document number: P2047R6
<br/>
Audience: LEWG
<br/>
<br/>
<a href="mailto:dinka.ranns@gmail.com">Nina Dinka Ranns</a><br/>
<a href="mailto:phalpern@halpernwightsoftware.com">Pablo Halpern</a><br/>
<a href="mailto:ville.voutilainen@gmail.com">Ville Voutilainen</a><br/>
2024-xx-xx<br/>
</address>
<hr/>
<h1 align=center>An allocator-aware variant type</h1>

<h2>Abstract</h2>
 
<p>
 
</p>

<p>  
  This is a complete proposal with formal wording.
</p>

<p>
<br/>change history :

 
<h2>Motivation and Proposal Summary</h2>
<p>
 
</p>


<h2>Design decisions:</h2>

<p><h3><tt>basic_variant</tt> supports non-scoped propagating allocators </h3></p>
<p>
  There are two ways of viewing <tt>basic_varian</tt>  from allocator propagation perspective :
<br/> #1 <tt>basic_varian</tt> is like an <tt>std::tuple</tt>, i.e. it only accepts
      the allocator at construction so it can forward it to the value_type object. One can 
      use a non-scoped propagation allocator, and when using a scoped propagation allocator
      <tt>basic_varian</tt> will not "consume" an allocator level. A variant 
      object is in a way like a tuple object as it does not use the allocator itself, 
      it only passes it into the value_type object.
<br/> #2 <tt>basic_variant</tt> is like an <tt>std::vector</tt>, i.e. it is a container
        of one or zero elements, and one should use a scoped propagating allocator if one wants
        the value_type object to use the allocator. In this approach <tt>basic_variant</tt> will "consume" an allocator level.
        Using non-scoped propagating allocators makes little sense in this scenario.
      </p>
<p>        
<p> The proposal implements #1 as <tt>basic_varian</tt> itself does not allocate any memory so it makes little sense for it to consume an alloctor level.
</p>

- blurb about allocator not being consumed by basic_variant
- when is basic-variant allocator aware
- basic-variant is not required to store an allocator if no types are allocator aware optimisation
- blurb about conversions between <tt>std::variant&lt;T&gt;</tt> and <tt>std::basic_variant&lt;T,Alloc&gt;</tt> 
- blurb about Allocator aware types are assumed to be move enabled 
    

    
    
<h3>default constructor      </h3>
<p>    No conditional triviality of the default constructor - the internal state needs to be initialised. 
    uses_allocator construction is always used in case the default allocator construction produces different allocators each time. Possible optimisation opportunity for allocators which have is_always_equal set to true, but no benefit in triviality or constexpr - uses_allocator construction will be constexpr if it can be constexpr either way. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant constexpr considerations would only depend on the constexpr construction of the 0th alternative.
    </p>
    <h3>copy constructor     </h3>
    <p>
        Copy construction does not do uses_allocator construction - the type is expected to behave acccording to the traits and get the right allocator. This allows for triviality if allocator is always equal and the constructed type can be trivially copy constructed. If allocator is not always equal, we need to check the traits to get the right allocator and that initialisation can not be trivial. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to store the allocator and triviality only depends on the triviality of the alternatives. This proposal does not consider such optimisation. 
        
    </p>
    <h3>move constructor     </h3>
    <p>
        Move construction does not do uses_allocator construction - the type is expected to behave acccording to the traits and get the right allocator. This allows for triviality if allocator can be trivially copy constructed and the constructed type can be trivially move constructed. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to store the allocator and triviality only depends on the triviality of the alternatives. This proposal does not consider such optimisation. 
        
    </p>
    <h3>value constructor     </h3>
    <p>
        Value construction must do uses_allocator construction if allocators aren't always equal- the plain copy/move construction may use the wrong allocator.
        Exception specification : 
      <br/>       - for non AA type, the exception specification is equivalent to is_nothrow_constructible_v&lt;Tj, T&gt;
      <br/>       - for AA type, any allocation is potentially throwing. To get a possibly no throw construction, we need to delegate to plain copy/move which can possibly reuse the allocation. The delegation can only
              happen if allocators are always equal. 
        
    </p>
    
    <h3>copy assignment constructor     </h3>
    <p>
        First the allocator is possibly modified based on the traits, then the assignment/construction is done as normal. 
        Triviality can only happen if allocator is always equal.
        The condition for the copy construction vs variant move construction is as follows :
    <br/>     - if a copy construction can't throw do copy construction 
    <br/>     - if move construction can throw do copy construction as the move construction doesn't bring any benefits
    <br/>     - otherwise, do move construction.
    </p><p>        
        With the introduction of allocators, we now have to consider when we can do plain copy construction and when allocator extended construction is needed.
        If type is non AA, we can do plain copy construction. 
        Tf the type is AA and allocator is always equal, we can also do plain copy construction.  Note that, for allocator is always equal case, plain copy construction and allocator copy construction will efectiveky result in the same allocator. We do not consider the possibility of doing non allocator extended copy construction for the case where the copy assignment allocator propagation matches the resulting allocator at copy construction as that case can't be checked at compile time.
        In all other cases, copy construction must use allocator extended copy construction to guarantee that the right allocator is used.
    </p><p>   
        Move construction must use non allocator extended construction to allow for allocator propagation.  For the AA types, we can only invoke the non alllocator extended move if we don't need to explicitly set the allocator. We don't need to explicitly set the allocator if allocators are always equal or if POCMA=true (because the allocator always propagates in move construction, so a well behaved POCMA=true type will have set the allocator in the assignment to what the reulsting allocator will be after move construction).
     </p><p>   
        The resulting behaviour is as follows
     <br/>   - if the type is not AA (i.e. no allocation is needed) or it is AA and allocator is always equal, and the copy is non throwing or move is throwing, do non alocator extended copy construction
     <br/>   - if the type is AA and allocator is not always equal and POCMA = false (i.e. allocator must be explicitly used), do the allocator extended copy construction.
     <br/>   - otherwise, do move construction
    </p>
    <h3>move assignment constructor </h3>    
    <p>
        First the allocator is possibly modified based on the traits, then the assignment/construction is done as normal. 
        In addition to usual triviality requirements, triviality can only happen if the allocator is propagated for move assignment(POCMA=true) or if the allocator is always equal. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to ever allocate and triviality only depends on the triviality of the alternative operations. This proposal does not consider such optimisation. 
     </p><p>   
        The exception specification needs to consider assignment and construction operations. Move assignment can be checked directly even for AA types. Move construction can be done directly for AA types if the allocator is always equal or if POCMA=true. OTherwise, the move construction needs to explicitly specify the allocator 
        
<h3>value assignment constructor</h3>
<p>
    Value construction must do uses_allocator construction if allocators aren't always equal- the plain copy/move construction may use the wrong allocator.
        Exception specification : 
      <br/>       - for non AA type, the exception specification is equivalent to is_nothrow_assignable_v&lt;Tj, T&gt; &amp; &amp; is_nothrow_constructible_v&lt;Tj, T&gt;
      <br/>       - for AA type, any allocation is potentially throwing. To get a possibly no throw construction, we need to delegate to plain move which can possibly reuse the allocation. The delegation can only
              happen if allocators are always equal. 
    <br/>
        Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to ever allocate and exception specification depends only on the alternatives
        This proposal does not consider such optimisation.
    </p>
    
    <h3>swap</h3>
<p>
    First the allocator is possibly modified based on the traits, then the swap/construction is done as normal. 
    
    Exception specification : To get a possibly no throw construction, we need to delegate to plain move which can possibly reuse the allocation. The delegation can only happen if allocators are always equal or if 
    propagate_on_container_swap == true (for such a type, the resulting allocator in move construction is the required allocator as move construction always propagates the allocator.) This means that swap can only be 
    noexcept if 
    <br/> -  is_nothrow_move_constructible_v&lt;Ti, T&gt; &amp; &amp; is_nothrow_constructible_v&lt;Ti, T&gt; for all i, and
    <br/> - allocator is always equal or propagate_on_container_swap == true
    </p>
    
<h2>Feedback items for LEWG: </h2>


<h2>Proposed wording</h2>
<p>
Add new paragraphs after ???
</p>
    <p><h3><ins> Header &lt;basic_variant&gt; synopsis [basic.variant.sys]</ins></h3> </p>

<blockquote><ins><code>
namespace std {
    
<br/>
<br/><tab/>  // [basic.variant], class template basic_variant  
<br/><tab/>  template&lt;class Allocator, class... Types&gt;
<br/><tab2/>    class basic_variant;  
<br/><tab/>  // [basic.variant.traits], allocator-related traits
<br/><tab/>    template&lt;class Allocator, class... Types&gt;
<br/><tab2/>   struct uses_allocator&lt;basic_variant&lt;Allocator, Types...&gt;&gt;;
<br/>
<br/>
<br/><tab/>  // [basic.variant.helper], variant helper classes
<br/><tab/>   template&lt;class T &gt; struct variant_size;                        // not defined
<br/><tab/>   template&lt;class T &gt; struct variant_size&lt;const T&gt;;
<br/><tab/>   template&lt;class T &gt;
<br/><tab/>    constexpr size_t variant_size_v = variant_size&lt;T&gt;::value;
<br/><tab/> 
<br/><tab/>   template&lt;class Allocator, class... Types&gt;
<br/><tab2/>     struct variant_size&lt;basic_variant&lt;class Allocator, Types...&gt;&gt;;
<br/><tab/> 
<br/><tab/>   template&lt;size_t I, class T&gt; struct variant_alternative;       // not defined
<br/><tab/>   template&lt;size_t I, class T&gt; struct variant_alternative&lt;I, const T&gt;;
<br/><tab/>   template&lt;size_t I, class T&gt;
<br/><tab2/>     using variant_alternative_t = typename variant_alternative&lt;I, T&gt;::type;
<br/><tab/> 
<br/><tab/>   template&lt;size_t I, class Allocator,  class... Types&gt;
<br/><tab2/>     struct variant_alternative&lt;I, basic_variantt&lt;class Allocator, Types...&gt;&gt;;
<br/><tab/> 
<br/><tab/>   inline constexpr size_t variant_npos = -1;   
<br/><tab/>    // [basic.variant.get], value access
<br/><tab/>  template&lt;size_t T, class Allocator,  class... Types&gt;
<br/><tab2/>    constexpr(?) bool holds_alternative(const basic_variant&lt;class Allocator, Types...&gt;&amp) noexcept;
<br/><tab/>
<br/><tab/>  template&lt;size_t I, class Allocator, class... Types&gt;
<br/><tab2/>    constexpr variant_alternative_t&lt;I, variant&lt;Allocator, Types...&gt;&gt;&amp
<br/><tab3/>      get(variant&lt;Allocator, Types...&gt;&amp);                                         // freestanding-deleted
<br/><tab/>  template&lt;size_t I, class Allocator, class... Types&gt;
<br/><tab2/>    constexpr variant_alternative_t&lt;I, variant&lt;Allocator, Types...&gt;&gt;&amp&amp
<br/><tab3/>      get(variant&lt;Allocator, Types...&gt;&amp&amp);                                        // freestanding-deleted
<br/><tab/>  template&lt;size_t I, class Allocator, class... Types&gt;
<br/><tab2/>    constexpr const variant_alternative_t&lt;I, variant&lt;Allocator, Types...&gt;&gt;&amp
<br/><tab3/>      get(const variant&lt;Allocator, Types...&gt;&amp);                                   // freestanding-deleted
<br/><tab/>  template&lt;size_t I, class Allocator, class... Types&gt;
<br/><tab2/>    constexpr const variant_alternative_t&lt;I, variant&lt;Allocator, Types...&gt;&gt;&amp&amp
<br/><tab3/>      get(const variant&lt;Allocator, Types...&gt;&amp&amp);                                  // freestanding-deleted
<br/><tab/>
<br/><tab2/>  template&lt;class T, class Allocator, class... Types&gt;
<br/><tab3/>    constexpr T&amp; get(variant&lt;Allocator, Types...&gt;&amp);                              // freestanding-deleted
<br/><tab/>  template&lt;class T, class Allocator, class... Types&gt;
<br/><tab2/>    constexpr T&amp;&amp; get(variant&lt;Allocator, Types...&gt;&amp&amp);                            // freestanding-deleted
<br/><tab3/>  template&lt;class T, class Allocator, class... Types&gt;
<br/><tab/>    constexpr const T&amp; get(const variant&lt;Allocator, Types...&gt;&amp);                  // freestanding-deleted
<br/><tab2/>  template&lt;class T, class Allocator, class... Types&gt;
<br/><tab3/>    constexpr const T&amp;&amp; get(const variant&lt;Allocator, Types...&gt;&amp&amp);                // freestanding-deleted
    
<br/><tab/> <br/><tab/> <br/><tab/> <br/><tab/> <br/><tab/> <br/><tab/> <br/><tab/> <br/><tab/> <br/><tab/> <br/><tab/> <br/><tab/>   
    </code></ins></blockquote>

<p><h3><ins> Class template &lt;basic_variant&gt;  [basic.variant.variant]</ins></h3></p>
<p><h4><ins> General                               [basic.variant.variant.general]</ins></h4></p>
<code><ins>
<br/><tab0/>namespace std {
<br/><tab1/>  template&lt;class Allocator, class... Types&gt;
<br/><tab1/>  class basic_variant {
<br/><tab1/>  public:
<br/><tab2/>    // [basic.variant.ctor], constructors
<br/><tab2/>    constexpr basic_variant() noexcept(see below);
    

<br/><tab2/>    constexpr basic_variant(std::allocator_arg_t, const Allocator&amp;) noexcept(see below);
    
    
<br/><tab2/>    constexpr basic_variant(const basic_variant&amp;);
<br/><tab2/>    constexpr basic_variant(basic_variant&amp;&amp;) noexcept(see below);
<br/><tab/>
<br/><tab2/>    template&lt;class T&gt;
<br/><tab3/>      constexpr basic_variant(T&amp;&amp;) noexcept(see below);
<br/><tab/>
<br/><tab2/>    template&lt;class T, class... Args&gt;
<br/><tab3/>      constexpr explicit basic_variant(in_place_type_t&lt;T&gt;, Args&amp;&amp;...);
<br/><tab2/>    template&lt;class T, class U, class... Args&gt;
<br/><tab3/>      constexpr explicit basic_variant(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt;, Args&amp;&amp;...);
<br/><tab/>
<br/><tab2/>    template&lt;size_t I, class... Args&gt;
<br/><tab3/>      constexpr explicit basic_variant(in_place_index_t&lt;I&gt;, Args&amp;&amp;...);
<br/><tab2/>    template&lt;size_t I, class U, class... Args&gt;
<br/><tab3/>      constexpr explicit basic_variant(in_place_index_t&lt;I&gt;, initializer_list&lt;U&gt;, Args&amp;&amp;...);
<br/><tab/>
<br/><tab2/>    // [basic.variant.dtor], destructor
<br/><tab2/>    constexpr ~basic_variant();
<br/><tab/>
<br/><tab2/>    // [basic.variant.assign], assignment
<br/><tab2/>    constexpr basic_variant&amp; operator=(const basic_variant&amp;);
<br/><tab2/>    constexpr basic_variant&amp; operator=(basic_variant&amp;&amp;) noexcept(see below);
<br/><tab/>
<br/><tab2/>    template&lt;class T&gt; constexpr basic_variant&amp; operator=(T&amp;&amp;) noexcept(see below);
<br/><tab/>
<br/><tab2/>    // [basic.variant.mod], modifiers
<br/><tab2/>    template&lt;class T, class... Args&gt;
<br/><tab3/>      constexpr T&amp; emplace(Args&amp;&amp;...);
<br/><tab2/>    template&lt;class T, class U, class... Args&gt;
<br/><tab3/>      constexpr T&amp; emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
<br/><tab2/>    template&lt;size_t I, class... Args&gt;
<br/><tab3/>      constexpr variant_alternative_t&lt;I, basic_variant&lt;Types...&gt;&gt;&amp; emplace(Args&amp;&amp;...);
<br/><tab2/>    template&lt;size_t I, class U, class... Args&gt;
<br/><tab3/>      constexpr variant_alternative_t&lt;I, basic_variant&lt;Types...&gt;&gt;&amp;
<br/><tab4/>        emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
<br/><tab/>
<br/><tab2/>    // [basic.variant.status], value status
<br/><tab2/>    constexpr bool valueless_by_exception() const noexcept;
<br/><tab/>
<br/><tab2/>    constexpr size_t index() const noexcept;
<br/><tab/>
<br/><tab2/>    // [basic.variant.swap], swap
<br/><tab2/>    constexpr void swap(basic_variant&amp;) noexcept(see below);
<br/><tab/>
<br/><tab2/>    // [basic.variant.visit], visitation
<br/><tab2/>    template&lt;class Self, class Visitor&gt;
<br/><tab3/>      constexpr decltype(auto) visit(this Self&amp;&amp;, Visitor&amp;&amp;);
<br/><tab2/>    template&lt;class R, class Self, class Visitor&gt;
<br/><tab3/>      constexpr R visit(this Self&amp;&amp;, Visitor&amp;&amp;);
<br/><tab1/>  };
<br/><tab0/>}    
</ins></code>
    

    <p><ins>1.   Any instance of <tt>basic_variant</tt> at any given time either holds a value of one of its alternative types or holds no value. When an instance of <tt>basic_variant</tt> holds a value of alternative type T, it means that a value of type T, referred to as the <tt>basic_variant</tt> object's contained value, is allocated within the storage of the <tt>basic_variant</tt> object. Implementations are not permitted to use additional storage, such as dynamic memory, to allocate the contained value.</ins></p>
    <p><ins>2. All types in <tt>Types</tt> shall meet the <tt>Cpp17Destructible</tt> requirements (Table 35).</ins></p>
    <p><ins>3. A program that instantiates the definition of <tt>basic_variant</tt> with no template arguments is ill-formed.</ins></p>
    <p><ins>4. If a program declares an explicit or partial specialization of <tt>basic_variant</tt>, the program is ill-formed, no diagnostic required.</ins></p>

    
<h4></h4>22.6.3.2 Constructors[variant.ctor]</h4>
<p><ins>1. In the descriptions that follow, let <tt>i</tt> be in the range <tt>[0, sizeof...(Types))</tt>, and Ti be the ith type in <tt>Types</tt>. </ins></p>
<!-- basic_variant() noexcept(see below) -->
<p><ins>
<br/><code>constexpr basic_variant() noexcept(see below);</code>
<br/><tab/><i>Constraints:</i> <tt>is_default_constructible_v&lt;T0&gt;</tt> is <tt>true</tt>.
<br/><tab/><i>Effects:</i>  <tt><i>alloc</i></tt> is default initialized and a value of alternative type T0 is constructed using
  uses-allocator construction with allocator <tt>alloc</tt> and no other constructor arguments.
<br/><tab/><i>Postconditions:</i> <tt>valueless_by_exception()</tt> is <tt>false</tt> and <tt>index()</tt> is 0.
<br/><tab/><i>Throws:</i> Any exception thrown by the initialization of <tt>T0</tt>.
<br/><tab/><i>Remarks:</i> This function is <tt>constexpr</tt> if and only if the initialization of the <tt>alloc</tt> and the alternative type 
is constexpr-suitable ([dcl.constexpr]).The exception specification is equivalent to <tt>is_nothrow_default_constructible_v&lt;T0&gt;</tt>
    </ins></p>
<!-- basic_variant(const basic_variant&) noexcept(see below) -->

<p><ins>
<br/><code>constexpr basic_variant(const basic_variant&amp; w) noexcept(see below);</code>
<br/><tab/><i>Effects:</i> If <tt><i>w</i></tt> holds a value, initializes the variant to hold the same alternative as <tt><i>w</i></tt> and direct-initializes the contained value with <tt><i>GET&lt;j&gt;(w)</i></tt>, where <tt><i>j</i></tt> is <tt><i>w.index()</i></tt>. Otherwise, initializes the variant to not hold a value. If <tt>allocator_traits&lt;Allocator&gt;::is_always_equal::value</tt> is <tt>true</tt>, default constructs <tt>alloc</tt>. Otherwise, <tt><i>alloc</i></tt> is initialised with <tt><i>allocator_traits&lt;Allocator&gt;::select_on_container_copy_construction(alloc2)</i></tt>, where <tt>Allocator</tt> is the type of <tt><i>alloc</i></tt>, and <tt><i>alloc2</i></tt> is the corresponding allocator in <tt><i>w</i></tt>.  

<br/><tab/><i>Throws:</i> Any exception thrown by direct-initialization of any <tt>Ti</tt>for all <tt>i</tt>.

<br/><tab/><i>Remarks:</i> This constructor is defined as deleted unless <tt>is_copy_constructible_v&lt;T0&gt;</tt> is <tt>true</tt> for all <tt>i</tt>. The exception specification is equivalent to the logical <tt>AND</tt> of <tt>is_nothrow_copy_constructible_v&lt;Ti&gt;</tt> for all <tt>i</tt>. This constructor is trivial if:
<br/><tab3/>   - <tt>is_trivially_copy_constructible_v&lt;Ti&gt;</tt> is <tt>true</tt> for all <tt>i</tt>,   
<br/><tab3/>   - <tt>allocator_traits&lt;Allocator&gt;::is_always_equal::value</tt> is <tt>true</tt>, and
<br/><tab3/>   - <tt>is_trivially_default_constructible_v&lt;Allocator&gt;</tt> is <tt>true</tt>
    </ins></p>
<!-- basic_variant(basic_variant&&) noexcept(see below) -->
<p><ins>
<br/><code>constexpr basic_variant(basic_variant&amp;&amp; w) noexcept(see below);</code>
<br/><tab/><i>Constraints:</i> <tt>is_move_constructible_v&lt;Ti&gt;</tt> is <tt>true</tt> for all <tt>i</tt>.
<br/><tab/><i>Effects:</i> If <tt>w</tt> holds a value, initializes the variant to hold the same alternative as <tt>w</tt> and direct-initializes the contained value with <tt>GET&lt;j&gt;(std::move(w))</tt>, where <tt>j</tt> is <tt>w.index()</tt>. Otherwise, initializes the variant to not hold a value.  If <tt>allocator_traits&lt;Allocator&gt;::is_always_equal::value</tt> is <tt>true</tt>, default constructs <tt>alloc</tt>. Otherwise, <tt>alloc</tt> is initialised with the allocator in <tt>w</tt>.  
<br/><tab/><i>Throws:</i> Any exception thrown by move-constructing any <tt>Ti</tt>for all <tt>i</tt>.
<br/><tab/><i>Remarks:</i> The exception specification is equivalent to the logical <tt>AND</tt> of <tt>is_nothrow_move_constructible_v&lt;Ti&gt;</tt> for all <tt>i</tt>. This constructor is defined as deleted unless <tt>is_copy_constructible_v&lt;T0&gt;</tt> is <tt>true</tt> for all <tt>i</tt>. This constructor is trivial if:
<br/><tab3/>   - <tt>is_trivially_move_constructible_v&lt;Ti&gt;</tt> is <tt>true</tt> for all <tt>i</tt>,   
<br/><tab3/>   - <tt>is_trivially_copy_constructible_v&lt;Allocator&gt;</tt> is <tt>true</tt>    
    
    </ins></p>
<!-- basic_variant(T&&) noexcept(see below) -->    
<p><ins>    
<br/><code>template&lt;class T&gt; constexpr variant(T&amp;&amp; t) noexcept(see below);</code>
<br/><tab/>Let Tj be a type that is determined as follows: build an imaginary function FUN(Ti) for each alternative type Ti for which Ti x[] = {std::forward&lt;T&gt;(t)}; 
    is well-formed for some invented variable x. The overload FUN(Tj) selected by overload resolution for the expression FUN(std::forward&lt;T&gt;(t)) 
    defines the alternative Tj which is the type of the contained value after construction.
<br/><tab/><i>Constraints:</i> sizeof...(Types) is nonzero, is_same_v&lt;remove_cvref_t&lt;T&gt;, variant&gt; is false,
remove_cvref_t&lt;T&gt; is neither a specialization of in_place_type_t nor a specialization of in_place_index_t, is_constructible_v&lt;Tj, T&gt; is true, and
the expression FUN(std::forward&lt;T&gt;(t)) (with FUN being the above-mentioned set of imaginary functions) is well-formed.
[Note 2: variant&lt;string, string&gt; v("abc"); is ill-formed, as both alternative types have an equally viable constructor for the argument. — end note]
<br/><tab/><i>Effects:</i> alloc is default initialized. Initializes *this to hold the alternative type Tj and initializes the contained value using uses-allocator construction with allocator <tt>alloc</tt> and std::forward&lt;T&gt;(t).
<br/><tab/><i>Postconditions:</i> Postconditions: holds_alternative&lt;Tj&gt;(*this) is true.
<br/><tab/><i>Throws:</i>: Any exception thrown by the initialization of the selected alternative Tj
<br/><tab/><i>Remarks:</i> The exception specification is equivalent to is_nothrow_constructible_v&lt;Tj, T&gt;. If the constructor of Alloc and  Tj's selected constructor are constexpr constructors, this constructor is a constexpr constructor.
    </ins></p>
    
<!-- constexpr basic_variant(std::allocator_arg_t, const Allocator&) noexcept(see below); -->
<p><ins>
<br/><code>constexpr basic_variant(std::allocator_arg_t, const Allocator&amp;) noexcept(see below)</code>
<br/><code>constexpr basic_variant(std::allocator_arg_t, const Allocator&amp;, const basic_variant&amp;) noexcept(see below)</code>
<br/><code>constexpr basic_variant(std::allocator_arg_t, const Allocator&amp;, basic_variant&amp;&amp;) noexcept(see below)</code>
<br/><code>template&lt;class T&gt; constexpr variant(std::allocator_arg_t, const Allocator&amp;,T&amp;&amp; t) noexcept(see below);</code>
<br/><tab/><i>Effects:</i> Behaves the same as non allocator extended version of the constructor except it initializes <tt>alloc</tt> with the specified allocator. 
    </ins>
    <br/> [Question to LWG : do we need to specify how triviality, constexpr, and exception specification conditions differ for these constructors?]
    
    
</p>
</body>
</html> 
