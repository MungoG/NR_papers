<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>An allocator-aware optional type</title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2113.3">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 12.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p4 {margin: 0.0px 0.0px 6.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p7 {margin: 0.0px 0.0px 12.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p8 {margin: 0.0px 0.0px 12.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 18.0px}
    p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000; min-height: 16.0px}
    p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000}
    p.p18 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 9.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p20 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 15.6px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p21 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0f7001; -webkit-text-stroke: #0f7001}
    p.p22 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #000000}
    p.p23 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p24 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #0a4d69; -webkit-text-stroke: #0a4d69}
    p.p25 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p26 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #9d0612; -webkit-text-stroke: #9d0612}
    p.p27 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #9d0612; -webkit-text-stroke: #9d0612; min-height: 14.0px}
    p.p29 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000e9; background-color: #21ff06}
    p.p30 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #0a4d69; background-color: #21ff06; min-height: 14.0px}
    p.p31 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #0a4d69; background-color: #21ff06}
    p.p32 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p33 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #440045; background-color: #21ff06; min-height: 14.0px}
    p.p34 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p35 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06; min-height: 14.0px}
    p.p36 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06; min-height: 14.0px}
    p.p37 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0f7001; background-color: #21ff06; min-height: 16.0px}
    p.p38 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0f7001; background-color: #21ff06}
    p.p39 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000e9; background-color: #21ff06}
    p.p40 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0a4d69; -webkit-text-stroke: #0a4d69; background-color: #21ff06}
    p.p41 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p42 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #9d0612}
    p.p46 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #0a4d69; background-color: #000000; background-color: rgba(0, 0, 0, 0)}
    p.p47 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000; background-color: #000000; background-color: rgba(0, 0, 0, 0)}
    p.p48 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #000000; background-color: #000000; background-color: rgba(0, 0, 0, 0); min-height: 14.0px}
    p.p49 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #000000; background-color: #000000; background-color: rgba(0, 0, 0, 0)}
    p.p50 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; background-color: #000000; background-color: rgba(0, 0, 0, 0)}
    p.p51 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 10.0px 'Apple Color Emoji'; color: #0000e9; -webkit-text-stroke: #0000e9; min-height: 17.0px}
    p.p52 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times}
    p.p54 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 10.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9; min-height: 13.0px}
    p.p55 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 10.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9; min-height: 13.0px}
    p.p56 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times}
    p.p57 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000; background-color: #000000; background-color: rgba(0, 0, 0, 0); min-height: 16.0px}
    p.p58 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; background-color: #000000; background-color: rgba(0, 0, 0, 0)}
    p.p59 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #0a4d69; -webkit-text-stroke: #0a4d69; background-color: #000000; background-color: rgba(0, 0, 0, 0)}
    p.p60 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #000000; background-color: rgba(0, 0, 0, 0); min-height: 14.0px}
    p.p61 {margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p63 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p64 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000}
    p.p65 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; min-height: 16.0px}
    p.p66 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px 'Lucida Grande'; -webkit-text-stroke: #000000}
    p.p68 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #440045; -webkit-text-stroke: #440045}
    p.p72 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 10.0px 'Apple Color Emoji'; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p73 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #0a4d69}
    p.p74 {margin: 0.0px 0.0px 12.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000; min-height: 16.0px}
    p.p75 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #440045}
    li.li22 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #000000}
    li.li52 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times}
    li.li53 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; min-height: 16.0px}
    span.s1 {font-kerning: none}
    span.s2 {text-decoration: underline ; font-kerning: none}
    span.s3 {font: 14.0px Courier; font-kerning: none}
    span.s4 {font: 12.0px Courier; font-kerning: none}
    span.s5 {font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s6 {font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s7 {font: 9.3px Times; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s8 {font: 13.3px Times; font-kerning: none; color: #000000}
    span.s9 {font: 15.6px Times; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s10 {font-kerning: none; color: #5b3d2a; -webkit-text-stroke: 0px #5b3d2a}
    span.s11 {font-kerning: none; color: #440045; -webkit-text-stroke: 0px #440045}
    span.s12 {font: 13.3px Times; font-kerning: none; color: #0f7001; -webkit-text-stroke: 0px #0f7001}
    span.s13 {font-kerning: none; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s14 {font-kerning: none; color: #9d0612; -webkit-text-stroke: 0px #9d0612}
    span.s15 {font: 12.0px Times; font-kerning: none; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s16 {font: 13.3px Times; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s17 {font: 12.0px Times; font-kerning: none}
    span.s18 {font-kerning: none; color: #0a4d69; -webkit-text-stroke: 0px #0a4d69}
    span.s19 {font-kerning: none; color: #000000}
    span.s20 {font-kerning: none; color: #8c550a; -webkit-text-stroke: 0px #8c550a}
    span.s21 {font-kerning: none; color: #0f7001; -webkit-text-stroke: 0px #0f7001}
    span.s22 {font: 14.0px Times; font-kerning: none}
    span.s23 {font: 13.3px Times; font-kerning: none}
    span.s24 {font-kerning: none; -webkit-text-stroke: 0px #9d0612}
    span.s25 {font-kerning: none; -webkit-text-stroke: 0px #440045}
    span.s26 {font-kerning: none; -webkit-text-stroke: 0px #0a4d69}
    span.s27 {font: 12.0px Times; font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s28 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #0f7001}
    span.s29 {font-kerning: none; -webkit-text-stroke: 0px #0000e9}
    span.s30 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #0000e9}
    span.s31 {font-kerning: none; background-color: #21ff06}
    span.s32 {font-kerning: none; color: #0000e9; background-color: transparent}
    span.s33 {font: 9.4px Times; vertical-align: -2.0px; font-kerning: none}
    span.s34 {font: 9.4px Times; vertical-align: 4.8px; font-kerning: none}
    span.s35 {font-kerning: none; color: #0a4d69}
    span.s36 {font: 13.3px Times; font-kerning: none; color: #440045; -webkit-text-stroke: 0px #440045}
    span.s37 {font: 9.4px Times; font-kerning: none}
    span.s38 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s39 {font: 13.3px Times; font-kerning: none; color: #440045; -webkit-text-stroke: 0px #000000}
    span.s40 {font: 12.0px Times; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s41 {font: 12.0px 'Lucida Grande'; font-kerning: none}
    span.s42 {font: 13.3px Times; font-kerning: none; color: #440045}
    span.s43 {font: 13.3px Times; font-kerning: none; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s44 {font-kerning: none; color: #000000; background-color: rgba(0, 0, 0, 0); -webkit-text-stroke: 0px #000000}
    span.s45 {font: 13.3px Times; font-kerning: none; color: #8c550a; -webkit-text-stroke: 0px #8c550a}
    span.s46 {font-kerning: none; color: #440045}
    span.s47 {font-kerning: none; color: #8c550a}
    span.s48 {font-kerning: none; background-color: rgba(0, 0, 0, 0)}
    span.s49 {font-kerning: none; color: #000000; background-color: transparent; -webkit-text-stroke: 0px #000000}
    span.s50 {font: 13.3px Times; font-kerning: none; background-color: rgba(0, 0, 0, 0); -webkit-text-stroke: 0px #000000}
    span.s51 {font: 13.3px Times; font-kerning: none; color: #440045; background-color: rgba(0, 0, 0, 0); -webkit-text-stroke: 0px #000000}
    span.s52 {font: 13.3px Times; font-kerning: none; background-color: rgba(0, 0, 0, 0)}
    span.s53 {font: 13.3px Times; font-kerning: none; color: #440045; background-color: rgba(0, 0, 0, 0)}
    span.s54 {font: 9.4px Times; vertical-align: -2.0px; font-kerning: none; background-color: rgba(0, 0, 0, 0)}
    span.s55 {font: 13.3px Times; font-kerning: none; color: #8c550a; background-color: rgba(0, 0, 0, 0)}
    span.s56 {font: 13.3px Times; font-kerning: none; color: #9d0612; -webkit-text-stroke: 0px #9d0612}
    span.s57 {font: 13.3px Times; font-kerning: none; color: #000000; background-color: transparent; -webkit-text-stroke: 0px #000000}
    span.s58 {font: 13.3px Times; font-kerning: none; color: #0a4d69; -webkit-text-stroke: 0px #0a4d69}
    span.s59 {-webkit-text-stroke: 0px #000000}
    span.s60 {font: 12.0px 'Lucida Grande'; -webkit-text-stroke: 0px #000000}
    span.s61 {font: 13.3px Times}
    span.s62 {font: 13.3px Times; font-kerning: none; color: #9d0612}
    span.s63 {font: 13.3px Times; font-kerning: none; color: #440045; background-color: rgba(0, 0, 0, 0); -webkit-text-stroke: 0px #440045}
    span.s64 {font: 13.3px Times; font-kerning: none; background-color: rgba(0, 0, 0, 0); -webkit-text-stroke: 0px #440045}
    span.s65 {font: 9.4px Times; vertical-align: -2.0px; font-kerning: none; background-color: rgba(0, 0, 0, 0); -webkit-text-stroke: 0px #440045}
    span.s66 {font-kerning: none; background-color: rgba(0, 0, 0, 0); -webkit-text-stroke: 0px #000000}
    span.s67 {font-kerning: none; color: #440045; background-color: rgba(0, 0, 0, 0)}
    span.s68 {font: 10.0px Menlo; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s69 {font: 9.4px Times; vertical-align: -2.0px; font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s70 {font-kerning: none; color: #9d0612}
    span.s71 {font: 10.0px Menlo; font-kerning: none; color: #0000e9}
    span.s72 {font-kerning: none; -webkit-text-stroke: 0px #8c550a}
    span.s73 {font: 12.0px Times; font-kerning: none; color: #000000}
    span.s74 {font: 13.3px Times; font-kerning: none; color: #8c550a}
    span.s75 {font: 13.3px Times; font-kerning: none; color: #8c550a; -webkit-text-stroke: 0px #000000}
    span.s76 {font: 12.0px Times; font-kerning: none; color: #440045; -webkit-text-stroke: 0px #440045}
    span.s77 {font: 8.5px Times; vertical-align: -1.8px; font-kerning: none}
    span.s78 {font: 14.0px Times; font-kerning: none; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s79 {font: 10.0px 'Apple Color Emoji'; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s80 {font-kerning: none; color: #0a4d69; -webkit-text-stroke: 0px #000000}
    span.s81 {font: 9.4px Times; vertical-align: -2.1px; font-kerning: none}
    span.s82 {font: 13.3px 'Lucida Grande'; font-kerning: none}
    span.Apple-tab-span {white-space:pre}
    ul.ul1 {list-style-type: none}
    ul.ul2 {list-style-type: hyphen}
  </style>
</head>
<body>
<p class="p1"><span class="s1"><i>Document number: P2047R6<span class="Apple-converted-space"> </span></i></span></p>
<p class="p1"><span class="s1"><i>Audience: LEWG<span class="Apple-converted-space"> </span></i></span></p>
<p class="p2"><span class="s1"><i></i></span><br></p>
<p class="p3"><span class="s2"><a href="mailto:dinka.ranns@gmail.com"><i>Nina Dinka Ranns</i></a></span></p>
<p class="p3"><span class="s2"><a href="mailto:phalpern@halpernwightsoftware.com"><i>Pablo Halpern</i></a></span></p>
<p class="p3"><span class="s2"><a href="mailto:ville.voutilainen@gmail.com"><i>Ville Voutilainen</i></a></span></p>
<p class="p1"><span class="s1"><i>2024-xx-xx</i></span></p>
<p class="p4"><span class="s1"></span><br></p>
<h1 style="margin: 0.0px 0.0px 16.1px 0.0px; text-align: center; font: 24.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>An allocator-aware variant type</b></span></h1>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Abstract</b></span></h2>
<p class="p7"><span class="s1"></span><br></p>
<p class="p8"><span class="s1">This is a complete proposal with formal wording.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1"><br>
change history :<span class="Apple-converted-space"> </span></span></p>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Motivation and Proposal Summary</b></span></h2>
<p class="p7"><span class="s1"></span><br></p>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Design decisions:</b></span></h2>
<p class="p7"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s3"><b>basic_variant</b></span><span class="s1"><b> supports non-scoped propagating allocators<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p7"><span class="s1"></span><br></p>
<p class="p8"><span class="s1">There are two ways of viewing </span><span class="s4">basic_varian</span><span class="s1"> from allocator propagation perspective : <br>
#1 </span><span class="s4">basic_varian</span><span class="s1"> is like an </span><span class="s4">std::tuple</span><span class="s1">, i.e. it only accepts the allocator at construction so it can forward it to the value_type object. One can use a non-scoped propagation allocator, and when using a scoped propagation allocator </span><span class="s4">basic_varian</span><span class="s1"> will not "consume" an allocator level. A variant object is in a way like a tuple object as it does not use the allocator itself, it only passes it into the value_type object. <br>
#2 </span><span class="s4">basic_variant</span><span class="s1"> is like an </span><span class="s4">std::vector</span><span class="s1">, i.e. it is a container of one or zero elements, and one should use a scoped propagating allocator if one wants the value_type object to use the allocator. In this approach </span><span class="s4">basic_variant</span><span class="s1"> will "consume" an allocator level. Using non-scoped propagating allocators makes little sense in this scenario.<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="s1"></span><br></p>
<p class="p8"><span class="s1">The proposal implements #1 as </span><span class="s4">basic_varian</span><span class="s1"> itself does not allocate any memory so it makes little sense for it to consume an alloctor level.<span class="Apple-converted-space"> </span></span></p>
<p class="p10"><span class="s1">- blurb about allocator not being consumed by basic_variant - when is basic-variant allocator aware - basic-variant is not required to store an allocator if no types are allocator aware optimisation - blurb about conversions between </span><span class="s4">std::variant&lt;T&gt;</span><span class="s1"> and </span><span class="s4">std::basic_variant&lt;T,Alloc&gt;</span><span class="s1"> - blurb about Allocator aware types are assumed to be move enabled</span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 18.0px"><span class="s1"><b></b></span><br></h3>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Allocator overhead</b></span></h3>
<p class="p12"><span class="s1">Allocator overhead can be removed in two cases</span></p>
<p class="p12"><span class="s1">- if all alternatives are not allocator aware</span></p>
<p class="p12"><span class="s1">- is allocator_traits&lt;Allocator&gt;::is_always_equal::value == true</span></p>
<p class="p13"><span class="s1"></span><br></p>
<p class="p12"><span class="s1">In the former case, allocator is simply not needed. In the latter case, there is no need to store or pass in the allocator as the default allocator will do. The paper doesn’t standardise such optimisation, it is left as a QOI.</span></p>
<p class="p13"><span class="s1"></span><br></p>
<p class="p14"><span class="s1"><b></b></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Default constructor<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p8"><span class="s1">No conditional triviality of the default constructor - the internal state needs to be initialised. Uses_allocator construction is always used in case the default allocator construction produces different allocators each time. Possible optimisation opportunity for allocators which have is_always_equal set to true, but no benefit in triviality or constexpr - uses_allocator construction will be constexpr if it can be constexpr either way. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant constexpr considerations would only depend on the constexpr construction of the 0th alternative.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1">Because default constructor has to explicitly specify the allocator, unless is_always_equal==true, the default constructor is noexcept if 0th alternative is not AA or is_always_equal==true, and default construction of 0th alternative is noexcept.</span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Copy constructor<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p8"><span class="s1">Copy construction does not do uses_allocator construction - the type is expected to behave according to the traits and get the right allocator. This allows for triviality if allocator is always equal and both the allocator and the constructed type can be trivially copy constructed. If allocator is not always equal, we need to check the traits to get the right allocator and that initialisation can not be trivial. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to store the allocator and triviality only depends on the triviality of the alternatives. This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Move constructor<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p8"><span class="s1">Move construction does not do uses_allocator construction - the type is expected to behave according to the traits and get the right allocator. This allows for triviality if allocator can be trivially copy constructed and the constructed type can be trivially move constructed. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to store the allocator and triviality only depends on the triviality of the alternatives. This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Value constructor<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p8"><span class="s1">Value construction must do uses_allocator construction if allocators aren't always equal- the plain copy/move construction may use the wrong allocator.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1">Exception specification could be specified as<span class="Apple-converted-space">  </span>: <br>
- for non AA type, the exception specification is equivalent to is_nothrow_constructible_v&lt;Tj, T&gt; <br>
- for AA type, any allocation is potentially throwing. To get a possibly no throw construction, we need to delegate to plain copy/move which can possibly reuse the allocation. The delegation can only happen if allocators are always equal, so for the AA type, the exception specification is equivalent to (is_nothrow_constructible_v&lt;Tj, T&gt; &amp;&amp; </span><span class="s5">allocator_traits&lt;Allocator&gt;::is_always_equal::value == true)</span><span class="s1"> <br>
</span></p>
<p class="p8"><span class="s1">The paper does not propose exception specification on this value constructor and considers it QOI</span></p>
<p class="p7"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Copy assignment operator<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p8"><span class="s1">First the allocator is possibly modified based on the traits, then the assignment/construction is done as normal. Triviality can only happen if allocator is always equal. The condition for the copy construction vs variant move construction is as follows : <br>
- if a copy construction can't throw do copy construction <br>
- if move construction can throw do copy construction as the move construction doesn't bring any benefits <br>
- otherwise, do move construction.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1">With the introduction of allocators, we now have to consider when we can do plain copy construction and when allocator extended construction is needed. If type is non AA, we can do plain copy construction. Tf the type is AA and allocator is always equal, we can also do plain copy construction. Note that, for allocator is always equal case, plain copy construction and allocator copy construction will effectively result in the same allocator. We do not consider the possibility of doing non allocator extended copy construction for the case where the copy assignment allocator propagation matches the resulting allocator at copy construction as that case can't be checked at compile time. In all other cases, copy construction must use allocator extended copy construction to guarantee that the right allocator is used.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1">Move construction must use non allocator extended construction to allow for allocator propagation. For the AA types, we can only invoke the non allocator extended move if we don't need to explicitly set the allocator. We don't need to explicitly set the allocator if allocators are always equal or if POCMA=true (because the allocator always propagates in move construction, so a well behaved POCMA=true type will have set the allocator in the assignment to what the resulting allocator will be after move construction).<span class="Apple-converted-space"> </span></span></p>
<p class="p12"><span class="s1">The resulting behaviour is as follows <br>
- if the type is not AA (i.e. no allocation is needed) or it is AA and allocator is always equal, and the copy is non throwing or move is throwing, do non allocator extended copy construction <br>
- if the type is AA and allocator is not always equal and POCMA = false (i.e. allocator must be explicitly used), do the allocator extended copy construction. <br>
- otherwise, do move construction<span class="Apple-converted-space"> </span></span></p>
<p class="p13"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Move assignment operator<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p8"><span class="s1">First the allocator is possibly modified based on the traits, then the assignment/construction is done as normal. In addition to usual triviality requirements, triviality can only happen if the allocator is propagated for move assignment(POCMA=true) or if the allocator is always equal. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to ever allocate and triviality only depends on the triviality of the alternative operations. This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1">The exception specification needs to consider assignment and construction operations. Move assignment can be checked directly even for AA types. Move construction can be done directly for AA types if the allocator is always equal or if POCMA=true. Otherwise, the move construction needs to explicitly specify the allocator<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 18.0px"><span class="s1"><b></b></span><br></h3>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Value assignment operator</b></span></h3>
<p class="p8"><span class="s1">Value construction must do uses_allocator construction if allocators aren't always equal- the plain copy/move construction may use the wrong allocator. Exception specification : <br>
- for non AA type, the exception specification is equivalent to is_nothrow_assignable_v&lt;Tj, T&gt; &amp; &amp; is_nothrow_constructible_v&lt;Tj, T&gt; <br>
- for AA type, any allocation is potentially throwing. To get a possibly no throw construction, we need to delegate to plain move which can possibly reuse the allocation. The delegation can only happen if allocators are always equal. <br>
Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to ever allocate and exception specification depends only on the alternatives This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 18.0px"><span class="s1"><b></b></span><br></h3>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Member swap</b></span></h3>
<p class="p8"><span class="s1">First the allocator is possibly modified based on the traits, then the swap/construction is done as normal. Exception specification : To get a possibly no throw construction, we need to delegate to plain move which can possibly reuse the allocation. The delegation can only happen if allocators are always equal or if propagate_on_container_swap == true (for such a type, the resulting allocator in move construction is the required allocator as move construction always propagates the allocator.) This means that swap can only be noexcept if <br>
- is_nothrow_move_constructible_v&lt;Ti, T&gt; &amp; &amp; is_nothrow_constructible_v&lt;Ti, T&gt; for all i, and <br>
- allocator is always equal or propagate_on_container_swap == true<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1">Note that swap has undefined behaviour if (allocator is always equal or propagate_on_container_swap == true) condition is not satisfied, so this condition is not reflected in the exception specification.</span></p>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Feedback items for LEWG:<span class="Apple-converted-space"> </span></b></span></h2>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Proposed wording</b></span></h2>
<p class="p8"><span class="s1">Add new paragraphs after ???<span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="s1"></span><br></p>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000"><span class="s6"><a href="https://eel.is/c++draft/variant#variant.general"><b>22.</b></a><b>x.x.1</b></span><span class="s1"><b> General</b></span></h4>
<p class="p17"><span class="s6">1 </span><span class="s1">A basic_variant behaves like variant, except alternatives are created with uses-allocator construction and allocator information is preserved between alternatives.</span></p>
<p class="p18"><span class="s1"><a href="https://eel.is/c++draft/variant#general-2">2<span class="s7"></span></a></span></p>
<p class="p17"><span class="s6">2. </span><span class="s1">In subclause [variant], <i>GET</i> denotes a set of exposition-only function templates<a href="https://eel.is/c++draft/variant#general-2.sentence-1"><span class="s8">.</span></a></span></p>
<p class="p15"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; -webkit-text-stroke: #000000"><span class="s6"><b>22.x.x</b></span><span class="s1"><b> Header &lt;variant&gt; synopsis</b></span></h3>
<p class="p20"><span class="s1"><a href="https://eel.is/c++draft/variant.syn"><b>[variant.syn]</b><span class="s9"><b></b></span></a></span></p>
<p class="p21"><span class="s1"><i>// mostly freestanding</i></span></p>
<p class="p22"><span class="s10">#include</span><span class="s1"> </span><span class="s11">&lt;</span><span class="s1">compare</span><span class="s11">&gt;</span><span class="s1"><span class="Apple-converted-space">              </span></span><span class="s12"><i>// see </i><a href="https://eel.is/c++draft/compare.syn"><span class="s6"><i>[compare.syn]</i></span></a></span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">namespace</span><span class="s13"> std </span><span class="s14">{</span></p>
<p class="p21"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/variant#variant"><span class="s16"><i>[variant.variant]</i></span></a><i>, class template </i></span><span class="s17">variant</span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">class</span><span class="s1"> variant;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p21"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/variant#helper"><span class="s16"><i>[variant.helper]</i></span></a><i>, variant helper classes</i></span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s1"> T</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s18">struct</span><span class="s1"> variant_size;<span class="Apple-converted-space">                        </span></span><span class="s12"><i>// not defined</i></span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T</span><span class="s11">&gt;</span><span class="s13"> </span><span class="s1">struct</span><span class="s13"> variant_size</span><span class="s11">&lt;</span><span class="s1">const</span><span class="s13"> T</span><span class="s11">&gt;</span><span class="s13">;</span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> size_t <a href="https://eel.is/c++draft/variant#lib:variant_size_v"><span class="s19">variant_size_v</span></a> </span><span class="s11">=</span><span class="s1"> variant_size</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;::</span><span class="s1">value;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">struct</span><span class="s1"> variant_size</span><span class="s11">&lt;</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;</span><span class="s1">;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s1"> T</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s18">struct</span><span class="s1"> variant_alternative; <span class="Apple-converted-space">      </span></span><span class="s12"><i>// not defined</i></span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s1"> T</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s18">struct</span><span class="s1"> variant_alternative</span><span class="s11">&lt;</span><span class="s1">I, </span><span class="s18">const</span><span class="s1"> T</span><span class="s11">&gt;</span><span class="s1">;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s1"> T</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">using</span><span class="s1"> <a href="https://eel.is/c++draft/variant#lib:variant_alternative_t"><span class="s19">variant_alternative_t</span></a> </span><span class="s11">=</span><span class="s1"> </span><span class="s18">typename</span><span class="s1"> variant_alternative</span><span class="s11">&lt;</span><span class="s1">I, T</span><span class="s11">&gt;::</span><span class="s1">type;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">struct</span><span class="s1"> variant_alternative</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;</span><span class="s1">;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">inline</span><span class="s1"> </span><span class="s18">constexpr</span><span class="s1"> size_t variant_npos </span><span class="s11">=</span><span class="s1"> </span><span class="s11">-</span><span class="s20">1</span><span class="s1">;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p21"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/variant#get"><span class="s16"><i>[variant.get]</i></span></a><i>, value access</i></span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s11">...</span><span class="s13"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> holds_alternative</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s14">)</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s1">;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&amp;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s14">)</span><span class="s1">;<span class="Apple-converted-space">                                          </span></span><span class="s12"><i>// freestanding-deleted</i></span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&amp;&amp;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;&amp;</span><span class="s14">)</span><span class="s1">; <span class="Apple-converted-space">                                        </span></span><span class="s12"><i>// freestanding-deleted</i></span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">const</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&amp;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s14">)</span><span class="s1">;<span class="Apple-converted-space">                                    </span></span><span class="s12"><i>// freestanding-deleted</i></span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">const</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&amp;&amp;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;&amp;</span><span class="s14">)</span><span class="s1">; <span class="Apple-converted-space">                                  </span></span><span class="s12"><i>// freestanding-deleted</i></span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s11">...</span><span class="s13"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> T</span><span class="s11">&amp;</span><span class="s1"> get</span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s14">)</span><span class="s1">; <span class="Apple-converted-space">                              </span></span><span class="s12"><i>// freestanding-deleted</i></span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s11">...</span><span class="s13"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> T</span><span class="s11">&amp;&amp;</span><span class="s1"> get</span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;&amp;</span><span class="s14">)</span><span class="s1">; <span class="Apple-converted-space">                            </span></span><span class="s12"><i>// freestanding-deleted</i></span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s11">...</span><span class="s13"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">const</span><span class="s1"> T</span><span class="s11">&amp;</span><span class="s1"> get</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s14">)</span><span class="s1">; <span class="Apple-converted-space">                  </span></span><span class="s12"><i>// freestanding-deleted</i></span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s11">...</span><span class="s13"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">const</span><span class="s1"> T</span><span class="s11">&amp;&amp;</span><span class="s1"> get</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;&amp;</span><span class="s14">)</span><span class="s1">; <span class="Apple-converted-space">                </span></span><span class="s12"><i>// freestanding-deleted</i></span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> add_pointer_t</span><span class="s11">&lt;</span><span class="s1">variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">*</span><span class="s14">)</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s1">;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> add_pointer_t</span><span class="s11">&lt;</span><span class="s18">const</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">*</span><span class="s14">)</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s1">;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s11">...</span><span class="s13"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> add_pointer_t</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">*</span><span class="s14">)</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s1">;</span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s11">...</span><span class="s13"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> add_pointer_t</span><span class="s11">&lt;</span><span class="s18">const</span><span class="s1"> T</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">*</span><span class="s14">)</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s1">;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p21"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/variant#relops"><span class="s16"><i>[variant.relops]</i></span></a><i>, relational operators</i></span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> </span><span class="s18">operator</span><span class="s11">==</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1">, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> </span><span class="s18">operator</span><span class="s11">!=</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1">, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> </span><span class="s18">operator</span><span class="s11">&lt;</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1">, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> </span><span class="s18">operator</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1">, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> </span><span class="s18">operator</span><span class="s11">&lt;=</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1">, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> </span><span class="s18">operator</span><span class="s11">&gt;=</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1">, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template&lt;class Allocator, class... Types&gt;</span><span class="s13"> </span><span class="s1">requires</span><span class="s13"> </span><span class="s14">(<a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable"><span class="s6">three_way_comparable</span></a></span><span class="s11">&lt;</span><span class="s13">Types</span><span class="s11">&gt;</span><span class="s13"> </span><span class="s11">&amp;&amp;</span><span class="s13"> </span><span class="s11">...</span><span class="s14">)</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> common_comparison_category_t</span><span class="s11">&lt;</span><span class="s1">compare_three_way_result_t</span><span class="s11">&lt;</span><span class="s1">Types</span><span class="s11">&gt;...&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s18">operator</span><span class="s11">&lt;=&gt;</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1">, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p25"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s21"><i>// </i><a href="https://eel.is/c++draft/variant#visit"><span class="s6"><i>[variant.visit]</i></span></a><i>, visitation</i></span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s1"> Visitor, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Variants</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> <i>see below</i> visit</span><span class="s14">(</span><span class="s1">Visitor</span><span class="s11">&amp;&amp;</span><span class="s1">, Variants</span><span class="s11">&amp;&amp;...</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s1"> R, </span><span class="s18">class</span><span class="s1"> Visitor, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Variants</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> R visit</span><span class="s14">(</span><span class="s1">Visitor</span><span class="s11">&amp;&amp;</span><span class="s1">, Variants</span><span class="s11">&amp;&amp;...</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p21"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/variant#monostate"><span class="s16"><i>[variant.monostate]</i></span></a><i>, class </i></span><span class="s17">monostate</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">struct</span><span class="s1"> monostate;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p21"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/variant#monostate.relops"><span class="s16"><i>[variant.monostate.relops]</i></span></a><i>, </i></span><span class="s17">monostate</span><span class="s1"><i> relational operators</i></span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s11">==</span><span class="s14">(</span><span class="s13">monostate, monostate</span><span class="s14">)</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> strong_ordering </span><span class="s18">operator</span><span class="s11">&lt;=&gt;</span><span class="s14">(</span><span class="s1">monostate, monostate</span><span class="s14">)</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s1">;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p21"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/variant#specalg"><span class="s16"><i>[variant.specalg]</i></span></a><i>, specialized algorithms</i></span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">void</span><span class="s1"> swap</span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1">, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s14">)</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s14">(</span><span class="s1"><i>see below</i></span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p21"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/variant#bad.access"><span class="s16"><i>[variant.bad.access]</i></span></a><i>, class </i></span><span class="s17">bad_variant_access</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">class</span><span class="s1"> bad_variant_access;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p21"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/variant#hash"><span class="s16"><i>[variant.hash]</i></span></a><i>, hash support</i></span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T</span><span class="s11">&gt;</span><span class="s13"> </span><span class="s1">struct</span><span class="s13"> hash;</span></p>
<p class="p24"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template&lt;class Allocator, class... Types&gt;</span><span class="s13"> </span><span class="s1">struct</span><span class="s13"> hash</span><span class="s11">&lt;</span><span class="s13">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;</span><span class="s13">;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">template</span><span class="s11">&lt;&gt;</span><span class="s1"> </span><span class="s18">struct</span><span class="s1"> hash</span><span class="s11">&lt;</span><span class="s1">monostate</span><span class="s11">&gt;</span><span class="s1">;</span></p>
<p class="p26"><span class="s1">}</span></p>
<p class="p27"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 14.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s1"><b>X.x.x</b></span><span class="s13"><b> Class template basic_variant</b></span><span class="s1"><b> [basic.variant.variant]</b></span></h3>
<p class="p29"><span class="s5">X.x.x. 1 <b>General</b></span><span class="s22"><b> </b><a href="https://eel.is/c++draft/variant.variant.general"><span class="s23"><b>[</b></span></a></span><span class="s1"><b>basic.variant.variant.general]</b></span></p>
<p class="p30"><span class="s1"></span><br></p>
<p class="p31"><span class="s1">namespace</span><span class="s5"> std </span><span class="s24">{</span></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s25">&lt;</span><span class="s1">class</span><span class="s25"> </span><span class="s5">Allocator, </span><span class="s1">class</span><span class="s25">...</span><span class="s5"> Types</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s26">class</span><span class="s1"> basic_variant </span><span class="s24">{</span></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">  </span></span><span class="s1">public</span><span class="s25">:</span></p>
<p class="p33"><span class="s1"></span><br></p>
<p class="p34"><span class="s26"><span class="Apple-converted-space">    </span>using</span><span class="s1"> allocator_type<span class="Apple-converted-space">  </span></span><span class="s25">=</span><span class="s1"> Allocator;</span></p>
<p class="p35"><span class="s1"></span><br></p>
<p class="p29"><span class="s27"><span class="Apple-converted-space">    </span></span><span class="s28"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s29"><i>[</i></span></a></span><span class="s23"><i>basic.variant.ctor]</i></span><span class="s28"><i>, constructors</i></span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">constexpr</span><span class="s1"> basic_variant</span><span class="s24">()</span><span class="s1"> </span><span class="s26">noexcept</span><span class="s24">(</span><span class="s1"><i>see below</i></span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">constexpr</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s26">const</span><span class="s1"> basic_variant</span><span class="s25">&amp;</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">constexpr</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s1">basic_variant</span><span class="s25">&amp;&amp;</span><span class="s24">)</span><span class="s1"> </span><span class="s26">noexcept</span><span class="s24">(</span><span class="s1"><i>see below</i></span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s25">&lt;</span><span class="s1">class</span><span class="s5"> T</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s1">T</span><span class="s25">&amp;&amp;</span><span class="s24">)</span><span class="s1"> </span><span class="s26">noexcept</span><span class="s24">(</span><span class="s1"><i>see below</i></span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s25">&lt;</span><span class="s1">class</span><span class="s5"> T, </span><span class="s1">class</span><span class="s25">...</span><span class="s5"> Args</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> </span><span class="s26">explicit</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s1">in_place_type_t</span><span class="s25">&lt;</span><span class="s1">T</span><span class="s25">&gt;</span><span class="s1">, Args</span><span class="s25">&amp;&amp;...</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s25">&lt;</span><span class="s1">class</span><span class="s5"> T, </span><span class="s1">class</span><span class="s5"> U, </span><span class="s1">class</span><span class="s25">...</span><span class="s5"> Args</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> </span><span class="s26">explicit</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s1">in_place_type_t</span><span class="s25">&lt;</span><span class="s1">T</span><span class="s25">&gt;</span><span class="s1">, initializer_list</span><span class="s25">&lt;</span><span class="s1">U</span><span class="s25">&gt;</span><span class="s1">, Args</span><span class="s25">&amp;&amp;...</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">template</span><span class="s25">&lt;</span><span class="s1">size_t I, </span><span class="s26">class</span><span class="s25">...</span><span class="s1"> Args</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> </span><span class="s26">explicit</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s1">in_place_index_t</span><span class="s25">&lt;</span><span class="s1">I</span><span class="s25">&gt;</span><span class="s1">, Args</span><span class="s25">&amp;&amp;...</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">template</span><span class="s25">&lt;</span><span class="s1">size_t I, </span><span class="s26">class</span><span class="s1"> U, </span><span class="s26">class</span><span class="s25">...</span><span class="s1"> Args</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> </span><span class="s26">explicit</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s1">in_place_index_t</span><span class="s25">&lt;</span><span class="s1">I</span><span class="s25">&gt;</span><span class="s1">, initializer_list</span><span class="s25">&lt;</span><span class="s1">U</span><span class="s25">&gt;</span><span class="s1">, Args</span><span class="s25">&amp;&amp;...</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p37"><span class="s1"><i></i></span><br></p>
<p class="p38"><span class="s1"><i>// allocator-extended constructors</i></span></p>
<p class="p34"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">constexpr</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s5">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s5"> a</span><span class="s24">)</span><span class="s1"> ;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">constexpr</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s5">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s5"> a, </span><span class="s26">const</span><span class="s1"> basic_variant</span><span class="s25">&amp;</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">constexpr</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s5">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s5"> a, </span><span class="s24">basic_variant</span><span class="s25">&amp;&amp;</span><span class="s24">)</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s25">&lt;</span><span class="s1">class</span><span class="s5"> T</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s5">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s5"> a, </span><span class="s1">T</span><span class="s25">&amp;&amp;</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s25">&lt;</span><span class="s1">class</span><span class="s5"> T, </span><span class="s1">class</span><span class="s25">...</span><span class="s5"> Args</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> </span><span class="s26">explicit</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s5">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s5"> a, </span><span class="s1">in_place_type_t</span><span class="s25">&lt;</span><span class="s1">T</span><span class="s25">&gt;</span><span class="s1">, Args</span><span class="s25">&amp;&amp;...</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s25">&lt;</span><span class="s1">class</span><span class="s5"> T, </span><span class="s1">class</span><span class="s5"> U, </span><span class="s1">class</span><span class="s25">...</span><span class="s5"> Args</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> </span><span class="s26">explicit</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s5">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s5"> a, </span><span class="s1">in_place_type_t</span><span class="s25">&lt;</span><span class="s1">T</span><span class="s25">&gt;</span><span class="s1">, initializer_list</span><span class="s25">&lt;</span><span class="s1">U</span><span class="s25">&gt;</span><span class="s1">, Args</span><span class="s25">&amp;&amp;...</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">template</span><span class="s25">&lt;</span><span class="s1">size_t I, </span><span class="s26">class</span><span class="s25">...</span><span class="s1"> Args</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> </span><span class="s26">explicit</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s5">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s5"> a, </span><span class="s1">in_place_index_t</span><span class="s25">&lt;</span><span class="s1">I</span><span class="s25">&gt;</span><span class="s1">, Args</span><span class="s25">&amp;&amp;...</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">template</span><span class="s25">&lt;</span><span class="s1">size_t I, </span><span class="s26">class</span><span class="s1"> U, </span><span class="s26">class</span><span class="s25">...</span><span class="s1"> Args</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> </span><span class="s26">explicit</span><span class="s1"> basic_variant</span><span class="s24">(</span><span class="s5">allocator_arg_t, const </span><span class="s1">allocator_type</span><span class="s5"> a, </span><span class="s1">in_place_index_t</span><span class="s25">&lt;</span><span class="s1">I</span><span class="s25">&gt;</span><span class="s1">, initializer_list</span><span class="s25">&lt;</span><span class="s1">U</span><span class="s25">&gt;</span><span class="s1">, Args</span><span class="s25">&amp;&amp;...</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p29"><span class="s27"><span class="Apple-converted-space">    </span></span><span class="s28"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s30"><i>[</i></span></a></span><span class="s23"><i>basic.variant.dtor]</i></span><span class="s28"><i>, destructor</i></span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">constexpr</span><span class="s1"> </span><span class="s25">~</span><span class="s1">variant</span><span class="s24">()</span><span class="s1">;</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p29"><span class="s27"><span class="Apple-converted-space">    </span></span><span class="s28"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s30"><i>[</i></span></a></span><span class="s23"><i>basic.variant.assign]</i></span><span class="s28"><i> assignment</i></span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">constexpr</span><span class="s1"> variant</span><span class="s25">&amp;</span><span class="s1"> </span><span class="s26">operator</span><span class="s25">=</span><span class="s24">(</span><span class="s26">const</span><span class="s1"> variant</span><span class="s25">&amp;</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s5"> variant</span><span class="s25">&amp;</span><span class="s5"> </span><span class="s1">operator</span><span class="s25">=</span><span class="s24">(</span><span class="s5">variant</span><span class="s25">&amp;&amp;</span><span class="s24">)</span><span class="s5"> </span><span class="s1">noexcept</span><span class="s24">(</span><span class="s5"><i>see below</i></span><span class="s24">)</span><span class="s5">;</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s25">&lt;</span><span class="s1">class</span><span class="s5"> T</span><span class="s25">&gt;</span><span class="s5"> </span><span class="s1">constexpr</span><span class="s5"> variant</span><span class="s25">&amp;</span><span class="s5"> </span><span class="s1">operator</span><span class="s25">=</span><span class="s24">(</span><span class="s5">T</span><span class="s25">&amp;&amp;</span><span class="s24">)</span><span class="s5"> </span><span class="s1">noexcept</span><span class="s24">(</span><span class="s5"><i>see below</i></span><span class="s24">)</span><span class="s5">;</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p29"><span class="s27"><span class="Apple-converted-space">    </span></span><span class="s28"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s30"><i>[</i></span></a></span><span class="s23"><i>basic.variant.mod]</i></span><span class="s28"><i>, modifiers</i></span></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s25">&lt;</span><span class="s1">class</span><span class="s5"> T, </span><span class="s1">class</span><span class="s25">...</span><span class="s5"> Args</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> T</span><span class="s25">&amp;</span><span class="s1"> emplace</span><span class="s24">(</span><span class="s1">Args</span><span class="s25">&amp;&amp;...</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s25">&lt;</span><span class="s1">class</span><span class="s5"> T, </span><span class="s1">class</span><span class="s5"> U, </span><span class="s1">class</span><span class="s25">...</span><span class="s5"> Args</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> T</span><span class="s25">&amp;</span><span class="s1"> emplace</span><span class="s24">(</span><span class="s1">initializer_list</span><span class="s25">&lt;</span><span class="s1">U</span><span class="s25">&gt;</span><span class="s1">, Args</span><span class="s25">&amp;&amp;...</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">template</span><span class="s25">&lt;</span><span class="s1">size_t I, </span><span class="s26">class</span><span class="s25">...</span><span class="s1"> Args</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s25">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s25">&gt;&amp;</span><span class="s1"> emplace</span><span class="s24">(</span><span class="s1">Args</span><span class="s25">&amp;&amp;...</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">template</span><span class="s25">&lt;</span><span class="s1">size_t I, </span><span class="s26">class</span><span class="s1"> U, </span><span class="s26">class</span><span class="s25">...</span><span class="s1"> Args</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s25">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s25">&gt;&amp;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">        </span>emplace</span><span class="s24">(</span><span class="s1">initializer_list</span><span class="s25">&lt;</span><span class="s1">U</span><span class="s25">&gt;</span><span class="s1">, Args</span><span class="s25">&amp;&amp;...</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p29"><span class="s27"><span class="Apple-converted-space">    </span></span><span class="s28"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s30"><i>[</i></span></a></span><span class="s23"><i>basic.variant.status]</i></span><span class="s28"><i>, value status</i></span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">constexpr</span><span class="s1"> </span><span class="s26">bool</span><span class="s1"> valueless_by_exception</span><span class="s24">()</span><span class="s1"> </span><span class="s26">const</span><span class="s1"> </span><span class="s26">noexcept</span><span class="s1">;</span></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s5"> size_t index</span><span class="s24">()</span><span class="s5"> </span><span class="s1">const</span><span class="s5"> </span><span class="s1">noexcept</span><span class="s5">;</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p39"><span class="s28"><i><span class="Apple-converted-space">   </span>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s30"><i>[</i></span></a></span><span class="s1"><i>basic.variant.al]</i></span><span class="s28"><i>, allocator</i></span></p>
<p class="p34"><span class="s1"><span class="Apple-converted-space">    </span>allocator_type get_allocator</span><span class="s24">()</span><span class="s1"> </span><span class="s26">const</span><span class="s1">;</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p29"><span class="s27"><span class="Apple-converted-space">    </span></span><span class="s28"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s30"><i>[</i></span></a></span><span class="s23"><i>basic.variant.swap]</i></span><span class="s28"><i>, swap</i></span></p>
<p class="p31"><span class="s5"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s5"> </span><span class="s1">void</span><span class="s5"> swap</span><span class="s24">(</span><span class="s5">variant</span><span class="s25">&amp;</span><span class="s24">)</span><span class="s5"> </span><span class="s1">noexcept</span><span class="s24">(</span><span class="s5"><i>see below</i></span><span class="s24">)</span><span class="s5">;</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p29"><span class="s27"><span class="Apple-converted-space">    </span></span><span class="s28"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s30"><i>[</i></span></a></span><span class="s23"><i>basic.variant.visit]</i></span><span class="s28"><i> visitation</i></span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">template</span><span class="s25">&lt;</span><span class="s26">class</span><span class="s1"> Self, </span><span class="s26">class</span><span class="s1"> Visitor</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> </span><span class="s26">decltype</span><span class="s24">(</span><span class="s26">auto</span><span class="s24">)</span><span class="s1"> visit</span><span class="s24">(</span><span class="s26">this</span><span class="s1"> Self</span><span class="s25">&amp;&amp;</span><span class="s1">, Visitor</span><span class="s25">&amp;&amp;</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s26">template</span><span class="s25">&lt;</span><span class="s26">class</span><span class="s1"> R, </span><span class="s26">class</span><span class="s1"> Self, </span><span class="s26">class</span><span class="s1"> Visitor</span><span class="s25">&gt;</span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s26">constexpr</span><span class="s1"> R visit</span><span class="s24">(</span><span class="s26">this</span><span class="s1"> Self</span><span class="s25">&amp;&amp;</span><span class="s1">, Visitor</span><span class="s25">&amp;&amp;</span><span class="s24">)</span><span class="s1">;</span></p>
<p class="p40"><span class="s1">private</span><span class="s11">:</span></p>
<p class="p41"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s19">allocator_type</span><span class="s1"> <i>alloc</i>; <span class="Apple-converted-space">        </span></span><span class="s12"><i>// exposition only</i></span></p>
<p class="p32"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s24">}</span><span class="s1">;</span></p>
<p class="p42"><span class="s31">}</span></p>
<p class="p18"><span class="s1"><a href="https://eel.is/c++draft/variant#variant.general-1">1<span class="s7"></span></a></span></p>
<p class="p25"><span class="s23"><a href="http://github.com/Eelis/draft/tree/7faaaf22a11d54ad00e40cc8d7fbee90db8b0837/source/utilities.tex#L5052">#<span class="s32"></span></a></span></p>
<p class="p17"><span class="s1">Any instance of variant at any given time either holds a value of one of its alternative types or holds no value<a href="https://eel.is/c++draft/variant#variant.general-1.sentence-1"><span class="s8">.</span></a> When an instance of variant holds a value of alternative type T, it means that a value of type T, referred to as the variant object's <a href="https://eel.is/c++draft/variant#def:contained_value,variant"><span class="s8"><i>contained value</i></span></a>, is allocated within the storage of the variant object<a href="https://eel.is/c++draft/variant#variant.general-1.sentence-2"><span class="s8">.</span></a> Implementations are not permitted to use additional storage, such as dynamic memory, to allocate the contained value<a href="https://eel.is/c++draft/variant#variant.general-1.sentence-3"><span class="s8">.</span></a></span></p>
<p class="p18"><span class="s1"><a href="https://eel.is/c++draft/variant#variant.general-2">2<span class="s7"></span></a></span></p>
<p class="p25"><span class="s23"><a href="http://github.com/Eelis/draft/tree/7faaaf22a11d54ad00e40cc8d7fbee90db8b0837/source/utilities.tex#L5062">#<span class="s32"></span></a></span></p>
<p class="p17"><span class="s1">All types in Types shall meet the <i>Cpp17Destructible</i> requirements (Table <a href="https://eel.is/c++draft/utility.arg.requirements#tab:cpp17.destructible"><span class="s16">35</span></a>)<a href="https://eel.is/c++draft/variant#variant.general-2.sentence-1"><span class="s8">.</span></a></span></p>
<p class="p18"><span class="s1"><a href="https://eel.is/c++draft/variant#variant.general-3">3<span class="s7"></span></a></span></p>
<p class="p25"><span class="s23"><a href="http://github.com/Eelis/draft/tree/7faaaf22a11d54ad00e40cc8d7fbee90db8b0837/source/utilities.tex#L5066">#<span class="s32"></span></a></span></p>
<p class="p17"><span class="s1">A program that instantiates the definition of variant with no template arguments is ill-formed<a href="https://eel.is/c++draft/variant#variant.general-3.sentence-1"><span class="s8">.</span></a></span></p>
<p class="p18"><span class="s1"><a href="https://eel.is/c++draft/variant#variant.general-4">4<span class="s7"></span></a></span></p>
<p class="p25"><span class="s23"><a href="http://github.com/Eelis/draft/tree/7faaaf22a11d54ad00e40cc8d7fbee90db8b0837/source/utilities.tex#L5070">#<span class="s32"></span></a></span></p>
<p class="p17"><span class="s1">If a program declares an explicit or partial specialization of variant, the program is ill-formed, no diagnostic required<a href="https://eel.is/c++draft/variant#variant.general-4.sentence-1"><span class="s8">.</span></a></span></p>
<h4 style="margin: 0.0px 0.0px 16.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px"><span class="s1"><b></b></span><br></h4>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #000000; background-color: rgba(0, 0, 0, 0)"><span class="s1"><b>X.x.x.2 </b></span><span class="s13"><b>Constructors </b></span><span class="s23"><b>[basic.variant.ctor]</b></span></h4>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000; background-color: #000000; background-color: rgba(0, 0, 0, 0)"><span class="s1">In the descriptions that follow, let </span><span class="s23"><i>i</i></span><span class="s1"> be in the range [</span><span class="s20">0</span><span class="s1">, </span><span class="s18">sizeof</span><span class="s11">...</span><span class="s14">(</span><span class="s1">Types</span><span class="s14">)</span><span class="s1">), and </span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s1"> be the <i>i</i></span><span class="s34">th</span><span class="s1"> type in Types.</span></h4>
<p class="p46"><span class="s35">constexpr</span><span class="s5"> basic_variant</span><span class="s14">()</span><span class="s5"> </span><span class="s35">noexcept</span><span class="s14">(</span><span class="s5"><i>see below</i></span><span class="s14">)</span><span class="s5">;</span></p>
<p class="p47"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>: is_default_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33">0</span><span class="s11">&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">.</span></p>
<p class="p47"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: alloc is default-initialized. If </span><span class="s23">allocator_traits</span><span class="s36">&lt;</span><span class="s23">Allocator</span><span class="s36">&gt;::is_always_equal::</span><span class="s1">value is false,<span class="Apple-converted-space">  </span>an alternative of type </span><span class="s23">T</span><span class="s33">0</span><span class="s1"> is constructed by uses-allocator construction with allocator </span><span class="s11">alloc</span><span class="s1"> and no constructor arguments. Otherwise, </span><span class="s23">T</span><span class="s33">0</span><span class="s1"> is value-initialized.<span class="Apple-tab-span">	</span></span></p>
<p class="p47"><span class="s1"><span class="Apple-tab-span">	</span><i>Postconditions</i>: valueless_by_exception</span><span class="s14">()</span><span class="s1"> is </span><span class="s20">false</span><span class="s1"> and index</span><span class="s14">()</span><span class="s1"> is </span><span class="s20">0</span><span class="s1">.</span></p>
<p class="p47"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by the value-initialization of </span><span class="s23">T</span><span class="s33">0</span><span class="s7">.</span></p>
<p class="p47"><span class="s7"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Remarks</i>: This function is </span><span class="s18">constexpr</span><span class="s1"> if and only if the selected constructor of the alternative type </span><span class="s23">T</span><span class="s33">0</span><span class="s37"> </span><span class="s1">and the allocator alloc is constexpr-suitable (<a href="https://eel.is/c++draft/dcl.constexpr"><span class="s16">[dcl.constexpr]</span></a>)<a href="https://eel.is/c++draft/variant#ctor-6.sentence-1"><span class="s8">.</span></a> The exception specification is equivalent to is_nothrow_default_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33">0</span><span class="s11">&gt; &amp;&amp; <span class="Apple-converted-space">  </span>(</span><span class="s38">allocator_traits</span><span class="s39">&lt;</span><span class="s38">Allocator</span><span class="s39">&gt;::is_always_equal::</span><span class="s23">value || !</span><span class="s38">uses_allocator_v</span><span class="s39">&lt;</span><span class="s23">T</span><span class="s33">0</span><span class="s39">&gt;).</span><span class="s17"><span class="Apple-tab-span">	</span>[<i>Note </i></span><span class="s40"><i>:</i></span><span class="s41"> </span><span class="s17">See also class monostate<a href="https://eel.is/c++draft/variant#ctor-6.sentence-3"><span class="s13">.</span></a> — <i>end note</i>]</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p49"><span class="s18">constexpr</span><span class="s1"> basic_variant</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant</span><span class="s11">&amp;</span><span class="s1"> w</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p47"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Effects</i>: </span><span class="s23">If allocator_traits</span><span class="s42">&lt;</span><span class="s23">Allocator</span><span class="s42">&gt;::is_always_equal::</span><span class="s23">value is true, alloc is default-initialized. Otherwise, alloc is direct-initialized with an </span><span class="s38">allocator_traits</span><span class="s39">&lt;</span><span class="s38">Allocator</span><span class="s39">&gt;::select_on_container_copy_construction(w.get_allocator()).</span><span class="s23"> </span><span class="s1">If w holds a value, initializes the variant to hold the same alternative as w and direct-initializes the contained value with <i>GET</i></span><span class="s11">&lt;</span><span class="s1">j</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1">, where j is w</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()<a href="https://eel.is/c++draft/variant#ctor-7.sentence-1"><span class="s43">.</span></a></span><span class="s1"> Otherwise, initializes the variant to not hold a value.</span></p>
<p class="p47"><span class="s6"><a href="http://github.com/Eelis/draft/tree/7faaaf22a11d54ad00e40cc8d7fbee90db8b0837/source/utilities.tex#L5127"><span class="Apple-tab-span">	</span></a></span><span class="s1"><i>Throws</i>: Any exception thrown by direct-initializing any </span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s1"> for all </span><span class="s23"><i>i</i></span><span class="s1">.</span></p>
<p class="p47"><span class="s6"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Remarks</i>: This constructor is defined as deleted unless is_copy_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1"> for all </span><span class="s23"><i>i</i><a href="https://eel.is/c++draft/variant#ctor-9.sentence-1"><span class="s44">.</span></a></span><span class="s1"> This constructor is trivial if</span></p>
<p class="p47"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- </span><span class="s23">is_trivially_copy_constructible_v</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s36">&gt;</span><span class="s23"> is </span><span class="s45">true</span><span class="s23"> for all <i>i</i>,</span></p>
<p class="p50"><span class="s5"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- </span><span class="s1">allocator_traits</span><span class="s46">&lt;</span><span class="s1">Allocator</span><span class="s46">&gt;::is_always_equal::</span><span class="s1">value is true, and</span></p>
<p class="p50"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_constructible_v</span><span class="s46">&lt;</span><span class="s1">Allocator</span><span class="s46">&gt;</span><span class="s1"> is </span><span class="s47">true</span></p>
<p class="p51"><span class="s1"></span><br></p>
<p class="p52"><span class="s18">constexpr</span><span class="s5"> </span><span class="s48">basic_variant</span><span class="s14">(</span><span class="s5">vari </span><span class="s48">basic_variant </span><span class="s5">ant</span><span class="s11">&amp;&amp;</span><span class="s5"> w</span><span class="s14">)</span><span class="s5"> </span><span class="s18">noexcept</span><span class="s14">(</span><span class="s5"><i>see below</i></span><span class="s14">)</span><span class="s5">;</span></p>
<p class="p17"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>: is_move_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1"> for all </span><span class="s23"><i>i</i><a href="https://eel.is/c++draft/variant#ctor-10.sentence-1"><span class="s49">.</span></a></span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: </span><span class="s50">alloc is direct-initialized with </span><span class="s51">w.get_allocator(). </span><span class="s1">If w holds a value, initializes the variant to hold the same alternative as w and direct-initializes the contained value with <i>GET</i></span><span class="s11">&lt;</span><span class="s1">j</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">std</span><span class="s11"> :: </span><span class="s1">move</span><span class="s14">(</span><span class="s1">w</span><span class="s14">))</span><span class="s1">, where j is w</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()<a href="https://eel.is/c++draft/variant#ctor-11.sentence-1"><span class="s43">.</span></a></span><span class="s1"> Otherwise, initializes the variant to not hold a value<a href="https://eel.is/c++draft/variant#ctor-11.sentence-2"><span class="s8">.</span></a></span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by move-constructing any </span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s1"> for all </span><span class="s23"><i>i</i><a href="https://eel.is/c++draft/variant#ctor-12.sentence-1"><span class="s49">.</span></a></span></p>
<p class="p17"><span class="s1"><a href="https://eel.is/c++draft/variant#ctor-12.sentence-1"><span class="Apple-tab-span">	</span></a><i>Remarks</i>: The exception specification is equivalent to the logical and of is_nothrow_move_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> for all </span><span class="s23"><i>i</i></span><span class="s1">. This constructor is trivial if :</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>-</span><span class="s52"> is_trivially_move_constructible_v</span><span class="s53">&lt;</span><span class="s52">T</span><span class="s54"><i>i</i></span><span class="s53">&gt;</span><span class="s52"> is </span><span class="s55">true</span><span class="s52"> for all <i>i</i>, and</span></p>
<p class="p17"><span class="s52"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_copy_constructible_v</span><span class="s53">&lt;</span><span class="s52">Allocator</span><span class="s53">&gt;</span><span class="s52"> is </span><span class="s55">true</span></p>
<ul class="ul1">
  <li class="li53"></li>
</ul>
<p class="p22"><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s1"> T</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s18">constexpr</span><span class="s1"> </span><span class="s48">basic_variant</span><span class="s14">(</span><span class="s1">T</span><span class="s11">&amp;&amp;</span><span class="s1"> t</span><span class="s14">)</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s14">(</span><span class="s1"><i>see below</i></span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s23">Let T</span><span class="s33"><i>j</i></span><span class="s23"> be a type that is determined as follows: build an imaginary function <i>FUN</i></span><span class="s56">(</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s56">)</span><span class="s23"> for each alternative type T</span><span class="s33"><i>i</i></span><span class="s23"> for which T</span><span class="s33"><i>i</i></span><span class="s23"> x</span><span class="s56">[]</span><span class="s23"> </span><span class="s36">=</span><span class="s23"> </span><span class="s56">{</span><span class="s23">std</span><span class="s36"> :: </span><span class="s23">forward</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s36">&gt;</span><span class="s56">(</span><span class="s23">t</span><span class="s56">)}</span><span class="s23">; is well-formed for some invented variable x<a href="https://eel.is/c++draft/variant#ctor-14.sentence-1"><span class="s57">.</span></a> The overload <i>FUN</i></span><span class="s56">(</span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s56">)</span><span class="s23"> selected by overload resolution for the expression <i>FUN</i></span><span class="s56">(</span><span class="s23">std</span><span class="s36"> :: </span><span class="s23">forward</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s36">&gt;</span><span class="s56">(</span><span class="s23"> t</span><span class="s56">))</span><span class="s23"> defines the alternative T</span><span class="s33"><i>j</i></span><span class="s23"> which is the type of the contained value after construction.</span></p>
<p class="p17"><span class="s23"><i><span class="Apple-tab-span">	</span>Constraints</i>:<span class="Apple-converted-space"> </span></span></p>
<p class="p17"><span class="s23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- </span><span class="s58">sizeof</span><span class="s36">...</span><span class="s56">(</span><span class="s23">Types</span><span class="s56">)</span><span class="s23"> is nonzero,</span></p>
<p class="p17"><span class="s23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_same_v</span><span class="s36">&lt;</span><span class="s23">remove_cvref_t</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s36">&gt;</span><span class="s23">, variant</span><span class="s36">&gt;</span><span class="s23"> is </span><span class="s45">false</span><span class="s23">,</span></p>
<p class="p17"><span class="s23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- remove_cvref_t</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s36">&gt;</span><span class="s23"> is neither a specialization of in_place_type_t nor a specialization of in_place_index_t,</span></p>
<p class="p17"><span class="s23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s23">, T</span><span class="s36">&gt;</span><span class="s23"> is </span><span class="s45">true</span><span class="s23">, and<span class="Apple-tab-span">	</span>the expression <i>FUN</i></span><span class="s56">(</span><span class="s23"> std</span><span class="s36"> :: </span><span class="s23">forward</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s36">&gt;</span><span class="s56">(</span><span class="s23">t</span><span class="s56">))</span><span class="s23"> (with <i>FUN</i> being the above-mentioned set of imaginary functions) is well-formed.<span class="Apple-converted-space"> </span></span></p>
<p class="p22"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[<i>Note </i>:</span><span class="s41"> </span></p>
<p class="p22"><span class="s41"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">basic_variant</span><span class="s11">&lt;</span><span class="s1">string, string</span><span class="s11">&gt;</span><span class="s1"> v</span><span class="s14">(</span><span class="s20">"abc"</span><span class="s14">)</span><span class="s1">;</span></p>
<ul class="ul1">
  <ul class="ul2">
    <li class="li22"><span class="s59"><span class="Apple-tab-span">	</span></span><span class="s60"> <span class="Apple-converted-space">    </span></span><span class="Apple-converted-space">  </span><span class="s1">is ill-formed, as both alternative types have an equally viable constructor for the argument<a href="https://eel.is/c++draft/variant#ctor-15.5.sentence-2"><span class="s19">.</span></a> — <i>end note</i>]</span></li>
  </ul>
</ul>
<p class="p17"><span class="s61"><i><span class="Apple-tab-span">	</span>E</i></span><span class="s23"><i>ffects</i>: alloc is default-initialized.<span class="Apple-converted-space">  </span></span><span class="s52">If allocator_traits</span><span class="s53">&lt;</span><span class="s52">Allocator</span><span class="s53">&gt;::is_always_equal::</span><span class="s52">value is false, an alternative of type T</span><span class="s54">j</span><span class="s52"> is constructed by uses-allocator construction with allocator </span><span class="s53">alloc</span><span class="s52"> and </span><span class="s23">std</span><span class="s42">::</span><span class="s23">forward</span><span class="s42">&lt;</span><span class="s23">T</span><span class="s42">&gt;</span><span class="s62">(</span><span class="s23">t</span><span class="s62">)</span><span class="s52">. Otherwise, an alternative of type T</span><span class="s54">j </span><span class="s23">is direct-non-list-initialized with std</span><span class="s36"> :: </span><span class="s23">forward</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s36">&gt;</span><span class="s56">(</span><span class="s23">t</span><span class="s56">)</span><span class="s23">.</span></p>
<p class="p17"><span class="s23"><i><span class="Apple-tab-span">	</span>Postconditions</i>: holds_alternative</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s36">&gt;</span><span class="s56">(</span><span class="s36">*</span><span class="s58">this</span><span class="s56">)</span><span class="s23"> is </span><span class="s45">true</span><span class="s23">.</span></p>
<p class="p17"><span class="s23"><i><span class="Apple-tab-span">	</span>Throws</i>: Any exception thrown by the initialization of the selected alternative T</span><span class="s33"><i>j</i></span><span class="s37"><i>.</i></span></p>
<p class="p17"><span class="s23"><i><span class="Apple-tab-span">	</span>Remarks</i>: The exception specification is equivalent to is_nothrow_constructible_v</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s23">, T</span><span class="s36">&gt; &amp;&amp; </span><span class="s63">(</span><span class="s64">allocator_traits</span><span class="s63">&lt;</span><span class="s64">Allocator</span><span class="s63">&gt;::is_always_equal::</span><span class="s64">value || !uses_allocator_v</span><span class="s63">&lt;</span><span class="s64">T</span><span class="s65">j</span><span class="s63">&gt;)</span><span class="s23">. If Allocator’s default constructor and T</span><span class="s33"><i>j</i></span><span class="s23">'s selected constructor are constexpr constructors, this constructor is a constexpr constructor</span></p>
<p class="p54"><span class="s1"></span><br></p>
<p class="p22"><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s1"> T, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Args</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">explicit</span><span class="s1"> </span><span class="s66">basic_variant</span><span class="s14">(</span><span class="s1">in_place_type_t</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span><span class="s1">, Args</span><span class="s11">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>:<span class="Apple-converted-space"> </span></span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- There is exactly one occurrence of T in Types</span><span class="s11">...</span><span class="s1"> and</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s11">&lt;</span><span class="s1">T, Args</span><span class="s11">...&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>: </span><span class="s38">alloc is default-initialized.<span class="Apple-converted-space">  </span></span><span class="s52">An alternative of type T is constructed by uses-allocator construction with allocator </span><span class="s63">alloc</span><span class="s52"> and</span><span class="s1"> std</span><span class="s11"> :: </span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">Args</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">args</span><span class="s14">)</span><span class="s11">...</span><span class="s1"> .</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Postconditions</i>: holds_alternative</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s11">*</span><span class="s18">this</span><span class="s14">)</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by calling the selected constructor of T.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: If Allocator’s default constructor and T’s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p55"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U, </span><span class="s1">class</span><span class="s11">...</span><span class="s13"> Args</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">explicit</span><span class="s1"> </span><span class="s66">basic_variant</span><span class="s14">(</span><span class="s1">in_place_type_t</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span><span class="s1">, initializer_list</span><span class="s11">&lt;</span><span class="s1">U</span><span class="s11">&gt;</span><span class="s1"> il, Args</span><span class="s11">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>:</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- There is exactly one occurrence of T in Types</span><span class="s11">...</span><span class="s1"> and</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s11">&lt;</span><span class="s1">T, initializer_list</span><span class="s11">&lt;</span><span class="s1">U</span><span class="s11">&gt;&amp;</span><span class="s1">, Args</span><span class="s11">...&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">.</span></p>
<p class="p56"><span class="s38"><span class="Apple-tab-span">	</span><i>Effects</i>: </span><span class="s1">alloc is default-initialized.<span class="Apple-converted-space">  </span></span><span class="s48">An alternative of type T is constructed by uses-allocator construction with allocator </span><span class="s67">alloc</span><span class="s48"> and</span><span class="s38"> il, std</span><span class="s36"> :: </span><span class="s38">forward</span><span class="s36">&lt;</span><span class="s38">Args</span><span class="s36">&gt;</span><span class="s56">(</span><span class="s38"> args</span><span class="s56">)</span><span class="s36">...</span><span class="s38"> .</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Postconditions</i>: holds_alternative</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s11">*</span><span class="s18">this</span><span class="s14">)</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by calling the selected constructor of T.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span></span><span class="s23"><i>Remarks</i>: If Allocator’s default constructor and T’s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p15"><span class="s23"></span><br></p>
<p class="p22"><span class="s68">t</span><span class="s18">emplate</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Args</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">explicit</span><span class="s1"> </span><span class="s66">basic_variant</span><span class="s14">(</span><span class="s1">in_place_index_t</span><span class="s11">&lt;</span><span class="s1">I</span><span class="s11">&gt;</span><span class="s1">, Args</span><span class="s11">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>:</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- I is less than </span><span class="s18">sizeof</span><span class="s11">...</span><span class="s14">(</span><span class="s1">Types</span><span class="s14">)</span><span class="s1"> and</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>I</i></span><span class="s1">, Args</span><span class="s11">...&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">.</span></p>
<p class="p56"><span class="s38"><span class="Apple-tab-span">	</span><i>Effects</i>: </span><span class="s1">alloc is default-initialized.<span class="Apple-converted-space">  </span></span><span class="s48">An alternative of type</span><span class="s38"> T</span><span class="s69"><i>I</i></span><span class="s38"> </span><span class="s48">is constructed by uses-allocator construction with allocator </span><span class="s67">alloc</span><span class="s48"> and</span><span class="s5"> std</span><span class="s11"> :: </span><span class="s5">forward</span><span class="s11">&lt;</span><span class="s5">Args</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s5">args</span><span class="s14">)</span><span class="s11">...</span><span class="s5"> .</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Postconditions</i>: index</span><span class="s14">()</span><span class="s1"> is I.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by calling the selected constructor of </span><span class="s23">T</span><span class="s33"><i>I</i></span><span class="s37"><i>.</i></span></p>
<p class="p17"><span class="s37"><i><span class="Apple-tab-span">	</span></i></span><span class="s1"><i>Remarks</i>: </span><span class="s38">If Allocator’s default constructor and </span><span class="s23">T</span><span class="s33"><i>I</i></span><span class="s37"><i> </i></span><span class="s1">'s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p22"><span class="s68">t</span><span class="s18">emplate</span><span class="s11">&lt;</span><span class="s1">size_t I, , </span><span class="s18">class</span><span class="s1"> U,<span class="Apple-converted-space">  </span></span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Args</span><span class="s11">&gt;</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">explicit</span><span class="s1"> </span><span class="s66">basic_variant</span><span class="s14">(</span><span class="s1">in_place_index_t</span><span class="s11">&lt;</span><span class="s1">I</span><span class="s11">&gt;</span><span class="s1">,<span class="Apple-converted-space">  </span>initializer_list</span><span class="s11">&lt;</span><span class="s1">U</span><span class="s11">&gt;</span><span class="s1"> il,<span class="Apple-converted-space">  </span>Args</span><span class="s11">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s23"><i>Constraints</i>:</span></p>
<p class="p17"><span class="s23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- I is less than </span><span class="s58">sizeof</span><span class="s36">...</span><span class="s56">(</span><span class="s23">Types</span><span class="s56">)</span><span class="s23"> and</span></p>
<p class="p17"><span class="s23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s33"><i>I</i></span><span class="s23">, initializer_list</span><span class="s36">&lt;</span><span class="s23">U</span><span class="s36">&gt;&amp;</span><span class="s23">, Args</span><span class="s36">...&gt;</span><span class="s23"> is </span><span class="s45">true</span><span class="s23">.</span></p>
<p class="p17"><span class="s23"><span class="Apple-tab-span">	</span><i>Effects</i>: alloc is default-initialized.<span class="Apple-converted-space">  </span></span><span class="s52">An alternative of type</span><span class="s23"> T</span><span class="s33"><i>I</i></span><span class="s23"> </span><span class="s52">is constructed by uses-allocator construction with allocator </span><span class="s53">alloc</span><span class="s52"> and</span><span class="s23"> il, std</span><span class="s42"> :: </span><span class="s23">forward</span><span class="s42">&lt;</span><span class="s23">Args</span><span class="s42">&gt;</span><span class="s62">(</span><span class="s23">args</span><span class="s62">)</span><span class="s42">...</span><span class="s23"> .</span></p>
<p class="p17"><span class="s23"><span class="Apple-tab-span">	</span><i>Postconditions</i>: index</span><span class="s56">()</span><span class="s23"> is I.</span></p>
<p class="p17"><span class="s23"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by calling the selected constructor of T</span><span class="s33"><i>I</i></span><span class="s37"><i>.</i></span></p>
<p class="p17"><span class="s37"><i><span class="Apple-tab-span">	</span></i></span><span class="s23"><i>Remarks</i>: If Allocator’s default constructor and T</span><span class="s33"><i>I</i></span><span class="s37"><i> </i></span><span class="s23">'s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p57"><span class="s1"></span><br></p>
<p class="p58"><span class="s18">constexpr</span><span class="s5"> basic_variant</span><span class="s14">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a</span><span class="s14">)</span><span class="s5">;</span></p>
<p class="p58"><span class="s18">constexpr</span><span class="s5"> basic_variant</span><span class="s14">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a, </span><span class="s18">const</span><span class="s5"> basic_variant</span><span class="s11">&amp;</span><span class="s5"> w</span><span class="s14">)</span><span class="s5">;</span></p>
<p class="p58"><span class="s18">constexpr</span><span class="s5"> </span><span class="s1">basic_variant</span><span class="s14">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a, basic_variant</span><span class="s11">&amp;&amp;</span><span class="s5"> w</span><span class="s14">)</span><span class="s5">;</span></p>
<p class="p58"><span class="s35">template</span><span class="s46">&lt;</span><span class="s35">class</span><span class="s1"> T</span><span class="s46">&gt;</span><span class="s1"> </span><span class="s35">constexpr</span><span class="s1"> basic_variant</span><span class="s70">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a, T</span><span class="s46">&amp;&amp;</span><span class="s1"> t</span><span class="s70">)</span><span class="s1">;</span></p>
<p class="p49"><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s1"> T, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Args</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">explicit</span><span class="s1"> basic_variant</span><span class="s14">(</span><span class="s5">allocator_arg_t, const Allocator&amp; a, </span><span class="s1">in_place_type_t</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span><span class="s1">, Args</span><span class="s11">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p59"><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U, </span><span class="s1">class</span><span class="s11">...</span><span class="s13"> Args</span><span class="s11">&gt;</span></p>
<p class="p49"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">explicit</span><span class="s1"> basic_variant</span><span class="s14">(</span><span class="s5">allocator_arg_t, const Allocator&amp; a, </span><span class="s1">in_place_type_t</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span><span class="s1">, initializer_list</span><span class="s11">&lt;</span><span class="s1">U</span><span class="s11">&gt;</span><span class="s1"> il, Args</span><span class="s11">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p49"><span class="s68">t</span><span class="s18">emplate</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Args</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">explicit</span><span class="s1"> basic_variant</span><span class="s14">(</span><span class="s5">allocator_arg_t, const Allocator&amp; a, </span><span class="s1">in_place_index_t</span><span class="s11">&lt;</span><span class="s1">I</span><span class="s11">&gt;</span><span class="s1">, Args</span><span class="s11">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p58"><span class="s71">t</span><span class="s35">emplate</span><span class="s46">&lt;</span><span class="s1">size_t I, , </span><span class="s35">class</span><span class="s1"> U,<span class="Apple-converted-space">  </span></span><span class="s35">class</span><span class="s46">...</span><span class="s1"> Args</span><span class="s46">&gt;</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p58"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s35">constexpr</span><span class="s1"> </span><span class="s35">explicit</span><span class="s1"> basic_variant</span><span class="s70">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a, in_place_index_t</span><span class="s46">&lt;</span><span class="s1">I</span><span class="s46">&gt;</span><span class="s1">,<span class="Apple-converted-space">  </span>initializer_list</span><span class="s46">&lt;</span><span class="s1">U</span><span class="s46">&gt;</span><span class="s1"> il,<span class="Apple-converted-space">  </span>Args</span><span class="s46">&amp;&amp;...</span><span class="s1"> args</span><span class="s70">)</span><span class="s1">;</span></p>
<p class="p60"><span class="s1"></span><br></p>
<p class="p56"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Behaves the same as non allocator extended version of the constructor except it initializes alloc with the specified allocator before initializing the alternative, if any, </span><span class="s48">by uses-allocator construction</span><span class="s1">.</span></p>
<p class="p12"><span class="s1"><br>
[Question to LWG : do we need to specify how triviality differs for these constructors?]<span class="Apple-converted-space"> </span></span></p>
<p class="p13"><span class="s1"></span><br></p>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s16"><b>x.x.x.x</b></span><span class="s8"><b> Destructor </b></span><span class="s1">[basic.variant.dtor]</span></h4>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 12.0px Times"><span class="s18">constexpr</span><span class="s5"> </span><span class="s11">~ </span><span class="s48">basic_variant</span><span class="s14">()</span><span class="s5">;</span></h4>
<p class="p17"><span class="s1"><i>Effects</i>: If valueless_by_exception</span><span class="s14">()</span><span class="s1"> is </span><span class="s20">false</span><span class="s1">, destroys the currently contained value.</span></p>
<p class="p17"><span class="s1"><i>Remarks</i>: If is_trivially_destructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1"> for all </span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s1">, then this destructor is trivial.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p61"><span class="s16"><b>x.x.x.x</b></span><span class="s8"><b> Assignment </b></span><span class="s1">[basic.variant.assign]</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p52"><span class="s18">constexpr</span><span class="s5"> </span><span class="s48">basic_variant</span><span class="s11">&amp;</span><span class="s5"> </span><span class="s18">operator</span><span class="s11">=</span><span class="s14">(</span><span class="s18">const</span><span class="s5"> </span><span class="s48">basic_variant</span><span class="s11">&amp;</span><span class="s5"> rhs</span><span class="s14">)</span><span class="s5">;</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span>Let </span><span class="s23"><i>j</i></span><span class="s1"> be rhs</span><span class="s11">.</span><span class="s1">index</span><span class="s14">().</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>:<span class="Apple-converted-space"> </span></span></p>
<p class="p63"><span class="s8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If allocator_traits&lt;Allocator&gt;::</span><span class="s1">propagate_on_container_copy_assignment::value is </span><span class="s20">true</span><span class="s72">, sets alloc to rhs.alloc</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If neither </span><span class="s11">*</span><span class="s18">this</span><span class="s1"> nor rhs holds a value, there is no additional effect.</span><span class="s7"><br>
</span><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if </span><span class="s11">*</span><span class="s18">this</span><span class="s1"> holds a value but rhs does not, destroys the value contained in </span><span class="s11">*</span><span class="s18">this</span><span class="s1"> and sets </span><span class="s11">*</span><span class="s18">this</span><span class="s1"> to not hold a value</span><span class="s7"><br>
</span><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">==</span><span class="s1"> </span><span class="s23"><i>j</i></span><span class="s1">, assigns the value contained in rhs to the value contained in </span><span class="s11">*</span><span class="s18">this</span><span class="s1">,</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if<span class="Apple-converted-space"> </span></span></p>
<p class="p64"><span class="s43"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- </span><span class="s5">uses_allocator_v&lt;remove_cv_t&lt;Tj&gt;, Alloc&gt; is false, or </span><span class="s1">uses_allocator_v&lt;remove_cv_t&lt;Tj&gt;, Alloc&gt; is true and </span><span class="s19">allocator_traits&lt;Allocator&gt;::</span><span class="s1">is_always_equal::value is </span><span class="s47">true</span><span class="s5">, and<span class="Apple-converted-space"> </span></span></p>
<p class="p17"><span class="s8"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- </span><span class="s23">either is_nothrow_copy_constructible_v</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s36">&gt;</span><span class="s23"> is </span><span class="s45">true</span><span class="s23"> or is_nothrow_move_constructible_v</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s36">&gt;</span><span class="s23"> is </span><span class="s45">false</span><span class="s73"> ,</span></p>
<p class="p17"><span class="s73"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s23">destroys the value content in *this and creates an alternative of type T</span><span class="s33"><i>j<span class="Apple-converted-space"> </span></i></span><span class="s23"> direct-initialised with <i>GET</i></span><span class="s42">&lt;</span><span class="s23"><i>j</i></span><span class="s42">&gt;(rhs)</span></p>
<p class="p56"><span class="s38"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise,<span class="Apple-converted-space"> </span></span><span class="s19"> if uses_allocator_v&lt;remove_cv_t&lt;Tj&gt;, Alloc&gt; is true and </span><span class="s1">allocator_traits&lt;Allocator&gt;::</span><span class="s19">is_always_equal::value is </span><span class="s47">false</span><span class="s19">,</span><span class="s38"> destroys the value content in *this and</span></p>
<p class="p17"><span class="s1"><span class="Apple-converted-space"> </span>creates an alternative of type </span><span class="s23">T</span><span class="s33"><i>j<span class="Apple-converted-space"> </span></i></span><span class="s1"> direct-initialised with uses_allocator_construction_args&lt;Tj&gt;(alloc, </span><span class="s23"><i>GET</i></span><span class="s36">&lt;</span><span class="s23"><i>j</i></span><span class="s36">&gt;(rhs))</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, equivalent to </span><span class="s18">operator</span><span class="s11">=</span><span class="s14">(</span><span class="s1">variant</span><span class="s14">(</span><span class="s1">rhs</span><span class="s14">))</span><span class="s1">.</span></p>
<p class="p65"><span class="s1"></span><br></p>
<p class="p17"><span class="s1"><i>Postconditions</i>: index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">==</span><span class="s1"> rhs</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span></p>
<p class="p17"><span class="s1"><i>Returns</i>: </span><span class="s11">*</span><span class="s18">this</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i>Remarks</i>: This operator is defined as deleted unless is_copy_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> </span><span class="s11">&amp;&amp;</span><span class="s1"> is_copy_assignable_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1"> for all </span><span class="s23"><i>i</i><a href="https://eel.is/c++draft/variant#assign-5.sentence-1"><span class="s49">.</span></a></span><span class="s1"> If is_trivially_copy_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> </span><span class="s11">&amp;&amp;</span><span class="s1"> is_trivially_copy_assignable_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> </span><span class="s11">&amp;&amp;</span><span class="s1"> is_trivially_destructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1"> for all </span><span class="s23"><i>i</i></span><span class="s1">, this assignment operator is trivial</span></p>
<p class="p54"><span class="s1"></span><br></p>
<p class="p52"><span class="s18">constexpr</span><span class="s5"> </span><span class="s48">basic_variant</span><span class="s11">&amp;</span><span class="s5"> </span><span class="s18">operator</span><span class="s11">=</span><span class="s14">(</span><span class="s48">basic_variant</span><span class="s11">&amp;&amp;</span><span class="s5"> rhs</span><span class="s14">)</span><span class="s5"> </span><span class="s18">noexcept</span><span class="s14">(</span><span class="s5"><i>see below</i></span><span class="s14">)</span><span class="s5">;</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span>Let </span><span class="s23"><i>j</i></span><span class="s1"> be rhs</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: is_move_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> </span><span class="s11">&amp;&amp;</span><span class="s1"> is_move_assignable_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1"> for all </span><span class="s23"><i>i</i><a href="https://eel.is/c++draft/variant#assign-7.sentence-1"><span class="s49">.</span></a></span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>:</span></p>
<p class="p17"><span class="s23"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- If allocator_traits&lt;Allocator&gt;::</span><span class="s8">propagate_on_container_move_assignment::value is </span><span class="s74">true</span><span class="s8">, sets alloc to rhs.alloc</span><span class="s1"><br>
<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- If neither </span><span class="s11">*</span><span class="s18">this</span><span class="s1"> nor rhs holds a value, there is no effect.</span></p>
<p class="p17"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise, if </span><span class="s11">*</span><span class="s18">this</span><span class="s1"> holds a value but rhs does not, destroys the value contained in </span><span class="s11">*</span><span class="s18">this</span><span class="s1"> and sets </span><span class="s11">*</span><span class="s18">this</span><span class="s1"> to not hold a value.</span><span class="s7"><br>
</span><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise, if index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">==</span><span class="s1"> </span><span class="s23"><i>j</i></span><span class="s1">, assigns <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>j</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">std</span><span class="s11"> :: </span><span class="s1">move</span><span class="s14">(</span><span class="s1">rhs</span><span class="s14">))</span><span class="s1"> to the value contained in </span><span class="s11">*</span><span class="s18">this</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise,<span class="Apple-converted-space"> </span></span><span class="s23"> if<span class="Apple-converted-space"> </span></span></p>
<p class="p63"><span class="s19"><span class="Apple-converted-space">      <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- </span><span class="s1">uses_allocator_v&lt;remove_cv_t&lt;Tj&gt;, Alloc&gt; is false, or<span class="Apple-converted-space"> </span></span></p>
<p class="p64"><span class="s1"><span class="Apple-converted-space">      <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- uses_allocator_v&lt;remove_cv_t&lt;Tj&gt;, Alloc&gt; is true and </span><span class="s19">allocator_traits&lt;Allocator&gt;::</span><span class="s1">is_always_equal::value is </span><span class="s47">true</span><span class="s1">,</span></p>
<p class="p17"><span class="s73"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s23">destroys the value content in *this and creates an alternative of type T</span><span class="s33"><i>j<span class="Apple-converted-space"> </span></i></span><span class="s23"> direct-initialised with <i>GET</i></span><span class="s42">&lt;</span><span class="s23"><i>j</i></span><span class="s42">&gt;(std::move(rhs))</span></p>
<p class="p17"><span class="s23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>-<span class="Apple-converted-space">  </span>Otherwise,<span class="Apple-converted-space"> </span></span><span class="s8"> </span><span class="s23">destroys the value content in *this and creates an alternative of type T</span><span class="s33"><i>j </i></span><span class="s50">is constructed by uses-allocator construction with allocator </span><span class="s51">alloc</span><span class="s50"> and </span><span class="s23"><i>GET</i></span><span class="s42">&lt;</span><span class="s23"><i>j</i></span><span class="s42">&gt;(std::move(rhs)))</span></p>
<p class="p17"><span class="s42"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Returns</i>: </span><span class="s11">*</span><span class="s18">this</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Remarks</i>: If </span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_move_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> </span><span class="s11">&amp;&amp;</span><span class="s1"> is_trivially_move_assignable_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> </span><span class="s11">&amp;&amp;</span><span class="s1"> is_trivially_destructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1"> for all </span><span class="s23"><i>i</i></span><span class="s1">, and<span class="Apple-converted-space"> </span></span></p>
<p class="p64"><span class="s43"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- </span><span class="s19">allocator_traits&lt;Allocator&gt;::</span><span class="s1">is_always_equal::value is </span><span class="s47">true </span><span class="s19">or allocator_traits&lt;Allocator&gt;::</span><span class="s1">propagate_on_container_move_assignment::value is </span><span class="s47">true<span class="Apple-converted-space"> </span></span></p>
<p class="p17"><span class="s75"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">this assignment operator is trivial<a href="https://eel.is/c++draft/variant#assign-10.sentence-1"><span class="s8">.</span></a> </span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>The exception specification is equivalent to logical and operation of (</span><span class="s38">allocator_traits&lt;Allocator&gt;::</span><span class="s43">is_always_equal::value &amp;&amp; </span><span class="s38">allocator_traits&lt;Allocator&gt;::</span><span class="s43">propagate_on_container_move_assignment::valu) and<span class="Apple-converted-space">  </span></span><span class="s1">is_nothrow_move_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> </span><span class="s11">&amp;&amp;</span><span class="s1"> is_nothrow_move_assignable_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> for all </span><span class="s23"><i>i</i></span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an exception is thrown during the call to </span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s1">'s move construction (with </span><span class="s23"><i>j</i></span><span class="s1"> being rhs</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">), the variant will hold no value.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an exception is thrown during the call to </span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s1">'s move assignment, the state of the contained value is as defined by the exception safety guarantee of </span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s1">'s move assignment; index</span><span class="s14">()</span><span class="s1"> will be </span><span class="s23"><i>j</i></span><span class="s1">.</span></p>
<p class="p55"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T</span><span class="s11">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s44">basic_variant</span><span class="s11">&amp;</span><span class="s13"> </span><span class="s1">operator</span><span class="s11">=</span><span class="s14">(</span><span class="s13">T</span><span class="s11">&amp;&amp;</span><span class="s13"> t</span><span class="s14">)</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s14">(</span><span class="s13"><i>see below</i></span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span>Let </span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s37"><i> </i></span><span class="s1">be a type that is determined as follows: build an imaginary function <i>FUN</i></span><span class="s14">(</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s14">)</span><span class="s1"> for each alternative type </span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s1"> for which </span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s1"> x</span><span class="s14">[]</span><span class="s1"> </span><span class="s11">=</span><span class="s1"> </span><span class="s14">{</span><span class="s1">std</span><span class="s11"> :: </span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">t</span><span class="s14">)}</span><span class="s1">; is well-formed for some invented variable x<a href="https://eel.is/c++draft/variant#assign-11.sentence-1"><span class="s8">.</span></a> The overload <i>FUN</i></span><span class="s14">(</span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s14">)</span><span class="s1"> selected by overload resolution for the expression <i>FUN</i></span><span class="s14">(</span><span class="s1">std</span><span class="s11"> :: </span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1"> t</span><span class="s14">))</span><span class="s1"> defines the alternative </span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s1"> which is the type of the contained value after assignment.</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>:</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_same_v</span><span class="s11">&lt;</span><span class="s1">remove_cvref_t</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span><span class="s1">, variant</span><span class="s11">&gt;</span><span class="s1"> is </span><span class="s20">false</span><span class="s1">,</span></p>
<p class="p17"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- is_assignable_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s11">&amp;</span><span class="s1">, T</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s11">&amp;&amp;</span><span class="s1"> is_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s1">, T</span><span class="s11">&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">, and</span></p>
<p class="p17"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- the expression <i>FUN</i></span><span class="s14">(</span><span class="s1">std</span><span class="s11"> :: </span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">t</span><span class="s14">))</span><span class="s1"> (with <i>FUN</i> being the above-mentioned set of imaginary functions) is well-formed<a href="https://eel.is/c++draft/variant#assign-12.sentence-1"><span class="s8">.</span></a></span></p>
<p class="p22"><span class="s23"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s1">[<i>Note </i>:</span><span class="s41"> </span></p>
<p class="p66"><span class="s1"><span class="Apple-converted-space">                             </span></span><span class="s17">variant</span><span class="s76">&lt;</span><span class="s17">string, string</span><span class="s76">&gt;</span><span class="s17"> v;</span></p>
<ul class="ul1">
  <ul class="ul2">
    <ul class="ul2">
      <li class="li52"><span class="Apple-converted-space">                                    </span><span class="s5">v </span><span class="s11">=</span><span class="s5"> </span><span class="s20">"abc"</span><span class="s5">;</span></li>
    </ul>
  </ul>
  <li class="li22"><span class="s59"> <span class="Apple-converted-space">                    </span></span><span class="s1">is ill-formed, as both alternative types have an equally viable constructor for the argument<a href="https://eel.is/c++draft/variant#assign-12.3.sentence-2"><span class="s19">.</span></a> — <i>end note</i>]</span></li>
</ul>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>:</span><span class="s7"><br>
</span><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- If </span><span class="s11">*</span><span class="s18">this</span><span class="s1"> holds a </span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s1">, assigns std</span><span class="s11"> :: </span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">t</span><span class="s14">)</span><span class="s1"> to the value contained in </span><span class="s11">*</span><span class="s18">this</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise, </span><span class="s23">if<span class="Apple-converted-space"> </span></span></p>
<p class="p63"><span class="s19"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- </span><span class="s1">uses_allocator_v&lt;remove_cv_t&lt;Tj&gt;, Alloc&gt; is false, or uses_allocator_v&lt;</span><span class="s19">remove_cvref_t </span><span class="s1">&lt;Tj&gt;, Alloc&gt; is true and </span><span class="s19">allocator_traits&lt;Allocator&gt;::</span><span class="s1">is_always_equal::value is </span><span class="s47">true</span><span class="s1">, and<span class="Apple-converted-space"> </span></span></p>
<p class="p17"><span class="s8"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- </span><span class="s23">either is_nothrow_copy_constructible_v</span><span class="s42">&lt;</span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s42">&gt;</span><span class="s23"> is </span><span class="s74">true</span><span class="s23"> or is_nothrow_move_constructible_v</span><span class="s42">&lt;</span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s42">&gt;</span><span class="s23"> is </span><span class="s74">false</span><span class="s73">,</span></p>
<p class="p17"><span class="s73"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s23">destroys the value content in *this, if any, and creates an alternative of type T</span><span class="s33"><i>j<span class="Apple-converted-space"> </span></i></span><span class="s23"> direct-initialised with std</span><span class="s36"> :: </span><span class="s23">forward</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s36">&gt;</span><span class="s56">(</span><span class="s23">t</span><span class="s56">)</span></p>
<p class="p17"><span class="s23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise,<span class="Apple-converted-space"> </span></span><span class="s8"> if uses_allocator_v&lt;remove_cv_t&lt;Tj&gt;, Alloc&gt; is true and </span><span class="s23">allocator_traits&lt;Allocator&gt;::</span><span class="s8">is_always_equal::value is </span><span class="s74">false</span><span class="s8">,</span><span class="s23"> destroys the value content in *this, if any, and</span></p>
<p class="p56"><span class="s5"><span class="Apple-converted-space"> </span>creates an alternative of type T</span><span class="s69"><i>j<span class="Apple-converted-space"> </span></i></span><span class="s5"> </span><span class="s48">by uses-allocator construction with allocator </span><span class="s67">alloc</span><span class="s48"> and </span><span class="s5">std</span><span class="s11"> :: </span><span class="s5">forward</span><span class="s11">&lt;</span><span class="s5">T</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s5">t</span><span class="s14">),</span></p>
<p class="p17"><span class="s23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, equivalent to emplace</span><span class="s36">&lt;</span><span class="s23"><i>j</i></span><span class="s36">&gt;</span><span class="s56">(</span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s56">(</span><span class="s23">std</span><span class="s36"> :: </span><span class="s23">forward</span><span class="s36">&lt;</span><span class="s23">T</span><span class="s36">&gt;</span><span class="s56">(</span><span class="s23">t</span><span class="s56">)))</span><span class="s23">.</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Postconditions</i>: holds_alternative</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s11">*</span><span class="s18">this</span><span class="s14">)</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">, with </span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s1"> selected by the imaginary function overload resolution described above<a href="https://eel.is/c++draft/variant#assign-14.sentence-1"><span class="s8">.</span></a></span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Returns</i>: </span><span class="s11">*</span><span class="s18">this<a href="https://eel.is/c++draft/variant#assign-15.sentence-1"><span class="s43">.</span></a></span></p>
<p class="p22"><span class="s23"><i><span class="Apple-tab-span">	</span>Remarks</i>: The exception specification is equivalent to:</span><span class="s1"> is_nothrow_assignable_v</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s77"><i>j</i></span><span class="s11">&amp;</span><span class="s1">, T</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s11">&amp;&amp;</span><span class="s1"> is_nothrow_constructible_v</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s77"><i>j</i></span><span class="s1">, T</span><span class="s11">&gt; &amp;&amp; (!uses_allocator_v&lt;remove_cv_t&lt;Tj&gt;, Alloc&gt; || allocator_traits&lt;Allocator&gt;::is_always_equal::value</span><span class="s43">)</span></p>
<p class="p17"><span class="s7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">If an exception is thrown during the assignment of std</span><span class="s11"> :: </span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">t</span><span class="s14">)</span><span class="s1"> to the value contained in </span><span class="s11">*</span><span class="s18">this</span><span class="s1">, the state of the contained value and t are as defined by the exception safety guarantee of the assignment expression; valueless_by_exception</span><span class="s14">()</span><span class="s1"> will be </span><span class="s20">false<a href="https://eel.is/c++draft/variant#assign-16.1.sentence-1"><span class="s43">.</span></a></span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an exception is thrown during the initialization of the contained value, the variant object is permitted to not hold a value<a href="https://eel.is/c++draft/variant#assign-16.2.sentence-1"><span class="s8">.</span></a></span></p>
<p class="p7"><span class="s1"></span><br></p>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s13"><b> Modifiers</b></span><span class="s1"><b> [basic.variant.mod]</b></span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #000000"><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s1"> T, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Args</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s18">constexpr</span><span class="s1"> T</span><span class="s11">&amp;</span><span class="s1"> emplace</span><span class="s14">(</span><span class="s1">Args</span><span class="s11">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>: is_constructible_v</span><span class="s11">&lt;</span><span class="s1">T, Args</span><span class="s11">...&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">, and T occurs exactly once in Types.</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Equivalent to:</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #000000"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s18">return</span><span class="s1"> emplace</span><span class="s11">&lt;</span><span class="s23"><i>I</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">std</span><span class="s11">::</span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">Args</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">args</span><span class="s14">)</span><span class="s11">...</span><span class="s14">)</span><span class="s1">;</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000"><span class="s17"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">where </span><span class="s23"><i>I</i></span><span class="s1"> is the zero-based index of T in Types.</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 10.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9; min-height: 13.0px"><span class="s1"></span><br></h4>
<p class="p24"><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U, </span><span class="s1">class</span><span class="s11">...</span><span class="s13"> Args</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> T</span><span class="s11">&amp;</span><span class="s1"> emplace</span><span class="s14">(</span><span class="s1">initializer_list</span><span class="s11">&lt;</span><span class="s1">U</span><span class="s11">&gt;</span><span class="s1"> il, Args</span><span class="s11">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>: is_constructible_v</span><span class="s11">&lt;</span><span class="s1">T, initializer_list</span><span class="s11">&lt;</span><span class="s1">U</span><span class="s11">&gt;&amp;</span><span class="s1">, Args</span><span class="s11">...&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">, and T occurs exactly once in Types.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Equivalent to:</span></p>
<p class="p22"><span class="s18"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>return</span><span class="s1"> emplace</span><span class="s11">&lt;</span><span class="s23"><i>I</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">il, std</span><span class="s11">::</span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">Args</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">args</span><span class="s14">)</span><span class="s11">...</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>where </span><span class="s23"><i>I</i></span><span class="s1"> is the zero-based index of T in Types.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p22"><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Args</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, </span><span class="s66">basic_variant</span><span class="s11">&lt;Allocator, </span><span class="s1">Types</span><span class="s11">...&gt;&gt;&amp;</span><span class="s1"> emplace</span><span class="s14">(</span><span class="s1">Args</span><span class="s11">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Mandates</i>: </span><span class="s23">I &lt; </span><span class="s58">sizeof</span><span class="s36">...</span><span class="s56">(</span><span class="s23">Types</span><span class="s56">)</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: is_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>I</i></span><span class="s1">, Args</span><span class="s11">...&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Destroys the currently contained value if valueless_by_exception</span><span class="s14">()</span><span class="s1"> is </span><span class="s20">false<a href="https://eel.is/c++draft/variant#mod-7.sentence-1"><span class="s43">.</span></a></span><span class="s1"> Then constructs an alternative of type </span><span class="s23">T</span><span class="s33"><i>I</i></span><span class="s1"> </span><span class="s50">by uses-allocator construction with allocator </span><span class="s51">alloc</span><span class="s50"> and </span><span class="s1">std</span><span class="s11">::</span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">Args</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">args</span><span class="s14">)</span><span class="s11">…</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Postconditions</i>: index</span><span class="s14">()</span><span class="s1"> is I<a href="https://eel.is/c++draft/variant#mod-8.sentence-1"><span class="s8">.</span></a></span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Returns</i>: A reference to the new contained value.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown during the initialization of the contained value.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: If an exception is thrown during the initialization of the contained value, the variant is permitted to not hold a value<a href="https://eel.is/c++draft/variant#mod-11.sentence-1"><span class="s8">.</span></a></span></p>
<p class="p55"><span class="s1"></span><br></p>
<p class="p22"><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s18">class</span><span class="s1"> U, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Args</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, </span><span class="s66">basic_variant </span><span class="s11">&lt;Allocator, </span><span class="s1">Types</span><span class="s11">...&gt;&gt;&amp;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span>emplace</span><span class="s14">(</span><span class="s1">initializer_list</span><span class="s11">&lt;</span><span class="s1">U</span><span class="s11">&gt;</span><span class="s1"> il, Args</span><span class="s11">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Mandates</i>: </span><span class="s23">I &lt; </span><span class="s58">sizeof</span><span class="s36">...</span><span class="s56">(</span><span class="s23">Types</span><span class="s56">)</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Constraints</i>: is_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>I</i></span><span class="s1">, initializer_list</span><span class="s11">&lt;</span><span class="s1">U</span><span class="s11">&gt;&amp;</span><span class="s1">, Args</span><span class="s11">...&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Destroys the currently contained value if valueless_by_exception</span><span class="s14">()</span><span class="s1"> is </span><span class="s20">false<a href="https://eel.is/c++draft/variant#mod-14.sentence-1"><span class="s43">.</span></a></span><span class="s1"> </span><span class="s23"> constructs an alternative of type T</span><span class="s33"><i>I</i></span><span class="s23"> </span><span class="s52">by uses-allocator construction with allocator </span><span class="s53">alloc</span><span class="s52"> and</span><span class="s1"> il, std</span><span class="s11"> :: </span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">Args</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">args</span><span class="s14">)</span><span class="s11">... .</span></p>
<p class="p17"><span class="s11"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Postconditions</i>: index</span><span class="s14">()</span><span class="s1"> is I.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Returns</i>: A reference to the new contained value.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown during the initialization of the contained value.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: If an exception is thrown during the initialization of the contained value, the variant is permitted to not hold a value.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p15"><span class="s1"></span><br></p>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s13"><b>Value status</b></span><span class="s1"><b> [basic.variant.status]</b></span></h4>
<p class="p55"><span class="s1"></span><br></p>
<p class="p22"><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> valueless_by_exception</span><span class="s14">()</span><span class="s1"> </span><span class="s18">const</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s1">;</span></p>
<p class="p17"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Effects</i>: Returns </span><span class="s20">false</span><span class="s1"> if and only if the variant holds a value.</span></p>
<p class="p22"><span class="s23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">[<i>Note </i></span><span class="s6"><i>1</i></span><span class="s1">:</span><span class="s41"> </span><span class="s1">It is possible for a basic_variant to hold no value if an exception is thrown during a type-changing assignment or emplacement<a href="https://eel.is/c++draft/variant#status-2.sentence-1"><span class="s19">.</span></a> The latter means that even a basic_variant</span><span class="s11">&lt;</span><span class="s18">float</span><span class="s1">, </span><span class="s18">int</span><span class="s11">&gt;</span><span class="s1"> can become valueless_by_exception</span><span class="s14">()</span><span class="s1">, for instance by</span></p>
<p class="p24"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>struct</span><span class="s13"> S </span><span class="s14">{</span><span class="s13"> </span><span class="s1">operator</span><span class="s13"> </span><span class="s1">int</span><span class="s14">()</span><span class="s13"> </span><span class="s14">{</span><span class="s13"> </span><span class="s1">throw</span><span class="s13"> </span><span class="s20">42</span><span class="s13">; </span><span class="s14">}}</span><span class="s13">;</span></p>
<p class="p68"><span class="s13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s44">basic_variant </span><span class="s1">&lt;std::allocator&lt;char&gt;, </span><span class="s18">float</span><span class="s13">, </span><span class="s18">int</span><span class="s1">&gt;</span><span class="s13"> v</span><span class="s14">{</span><span class="s20">12.f</span><span class="s14">}</span><span class="s13">;</span></p>
<p class="p22"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>v</span><span class="s11">.</span><span class="s1">emplace</span><span class="s11">&lt;</span><span class="s20">1</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">S</span><span class="s14">())</span><span class="s1">;</span></p>
<p class="p22"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>— <i>end note</i>]</span></p>
<p class="p55"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">constexpr</span><span class="s13"> size_t index</span><span class="s14">()</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p17"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Effects</i>: If valueless_by_exception</span><span class="s14">()</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">, returns variant_npos<a href="https://eel.is/c++draft/variant#status-3.sentence-1"><span class="s8">.</span></a> Otherwise, returns the zero-based index of the alternative of the contained value.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s78"><b>Allocator </b></span><span class="s1"><b>[basic.variant.all]</b></span></h3>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; font: 12.0px Times; -webkit-text-stroke: #000000"><span class="s1">allocator_type get_allocator</span><span class="s14">()</span><span class="s1"> </span><span class="s18">const</span><span class="s1">;</span></h3>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; font: 13.3px Times; -webkit-text-stroke: #000000"><span class="s1"><i>Returns</i>: A copy of the Allocator that was passed to the object's constructor or, if that allocator has been replaced, a copy of the most recent replacement.</span></h3>
<p class="p15"><span class="s1"></span><br></p>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s13"><b>Swap</b></span><span class="s1"><b> [basic.variant.swap]</b></span></h4>
<p class="p72"><span class="s1"><a href="https://eel.is/c++draft/variant#lib:swap,variant">🔗<span class="s79"></span></a></span></p>
<p class="p73"><span class="s35">constexpr</span><span class="s5"> </span><span class="s35">void</span><span class="s5"> swap</span><span class="s14">(</span><span class="s66">basic_variant</span><span class="s11">&amp;</span><span class="s5"> rhs</span><span class="s14">)</span><span class="s5"> </span><span class="s35">noexcept</span><span class="s14">(</span><span class="s5"><i>see below</i></span><span class="s14">)</span><span class="s5">;</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Mandates</i>: is_move_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1"> for all </span><span class="s23"><i>i</i></span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Preconditions</i>: Each </span><span class="s23">T</span><span class="s33"><i>i </i></span><span class="s1">meets the <i>Cpp17Swappable</i> requirements (<a href="https://eel.is/c++draft/swappable.requirements"><span class="s16">[swappable.requirements]</span></a>)</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>:  </span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If allocator_traits</span><span class="s11">&lt;</span><span class="s1">Allocator</span><span class="s11">&gt;::</span><span class="s1">propagate_on_container_swap</span><span class="s11">::</span><span class="s1">value is </span><span class="s20">true</span><span class="s1">, then </span><span class="s23">Allocator</span><span class="s1"> shall meet the <i>Cpp17Swappable</i> requirements and the allocators of *this and res shall also be exchanged by calling swap as described in <a href="https://eel.is/c++draft/swappable.requirements"><span class="s16">[swappable.requirements]</span></a><a href="https://eel.is/c++draft/container.reqmts#65.sentence-3"><span class="s8">.</span></a> Otherwise, the allocators shall not be swapped, and the behavior is undefined unless *this</span><span class="s11">.</span><span class="s1">get_allocator</span><span class="s14">()</span><span class="s1"> </span><span class="s11">==</span><span class="s1"> rhs</span><span class="s11">.</span><span class="s1">get_allocator</span><span class="s14">()</span><span class="s1">.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If valueless_by_exception</span><span class="s14">()</span><span class="s1"> </span><span class="s11">&amp;&amp;</span><span class="s1"> rhs</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">()</span><span class="s1"> no additional effect.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">==</span><span class="s1"> rhs</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">, calls swap</span><span class="s14">(</span><span class="s1"><i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s11">*</span><span class="s18">this</span><span class="s14">)</span><span class="s1">, <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">rhs</span><span class="s14">))</span><span class="s1"> where </span><span class="s23"><i>i</i></span><span class="s1"> is index</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, exchanges values of rhs and </span><span class="s11">*</span><span class="s18">this</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: If index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">==</span><span class="s1"> rhs</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">, any exception thrown by swap</span><span class="s14">(</span><span class="s1"><i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s11">*</span><span class="s18">this</span><span class="s14">)</span><span class="s1">, <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">rhs</span><span class="s14">))</span><span class="s1"> with </span><span class="s23"><i>i</i></span><span class="s1"> being index</span><span class="s14">()<a href="https://eel.is/c++draft/variant#swap-4.sentence-1"><span class="s43">.</span></a></span><span class="s1"> Otherwise, any exception thrown by the move constructor of </span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s1"> or </span><span class="s23">T</span><span class="s33"><i>j</i></span><span class="s1"> with </span><span class="s23"><i>i</i></span><span class="s1"> being index</span><span class="s14">()</span><span class="s1"> and </span><span class="s23"><i>j</i></span><span class="s1"> being rhs</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: If an exception is thrown during the call to function swap</span><span class="s14">(</span><span class="s1"><i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s11">*</span><span class="s18">this</span><span class="s14">)</span><span class="s1">, <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">rhs</span><span class="s14">))</span><span class="s1">, the states of the contained values of </span><span class="s11">*</span><span class="s18">this</span><span class="s1"> and of rhs are determined by the exception safety guarantee of swap for lvalues of </span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s1"> with </span><span class="s23"><i>i</i></span><span class="s1"> being index</span><span class="s14">()<a href="https://eel.is/c++draft/variant#swap-5.sentence-1"><span class="s43">.</span></a></span><span class="s1"> If an exception is thrown during the exchange of the values of </span><span class="s11">*</span><span class="s18">this</span><span class="s1"> and rhs, the states of the values of </span><span class="s11">*</span><span class="s18">this</span><span class="s1"> and of rhs are determined by the exception safety guarantee of variant's move constructor<a href="https://eel.is/c++draft/variant#swap-5.sentence-2"><span class="s8">.</span></a> The exception specification is equivalent to the logical and of is_nothrow_move_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> </span><span class="s11">&amp;&amp;</span><span class="s1"> is_nothrow_swappable_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> for all </span><span class="s23"><i>i</i></span><span class="s1">.</span></p>
<p class="p74"><span class="s1"></span><br></p>
<p class="p15"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; -webkit-text-stroke: #000000"><span class="s1"><b>basic_variant helper classes</b></span><span class="s6"><b> [basic.variant.helper]</b></span></h3>
<p class="p75"><span class="s18">template</span><span class="s46">&lt;</span><span class="s35">class</span><span class="s1"> Allocator,<span class="Apple-converted-space">  </span></span><span class="s18">class</span><span class="s46">...</span><span class="s5"> Types</span><span class="s46">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">struct</span><span class="s1"> variant_size</span><span class="s11">&lt;basic_</span><span class="s1">variant</span><span class="s11">&lt;Allocator, </span><span class="s1">Types</span><span class="s11">...&gt;&gt;</span><span class="s1"> </span><span class="s11">:</span><span class="s1"> integral_constant</span><span class="s11">&lt;</span><span class="s1">size_t, </span><span class="s18">sizeof</span><span class="s11">...</span><span class="s14">(</span><span class="s1">Types</span><span class="s14">)</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s14">{</span><span class="s1"> </span><span class="s14">}</span><span class="s1">;</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p22"><span class="s1">variant_alternative</span><span class="s11">&lt;</span><span class="s1">I, basic_variant</span><span class="s11">&lt;Allocator, </span><span class="s1">Types</span><span class="s11">...&gt;&gt;::</span><span class="s1">type</span></p>
<p class="p17"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Mandates</i>: </span><span class="s23">I &lt; </span><span class="s58">sizeof</span><span class="s36">...</span><span class="s56">(</span><span class="s23">Types</span><span class="s56">)</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Type</i>: The type </span><span class="s23">T</span><span class="s33"><i>I</i></span><span class="s37"><i>.</i></span></p>
<p class="p15"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s13"><b>Value access</b></span><span class="s1"><b> [basic.variant.get]</b></span></h3>
<p class="p72"><span class="s1"><a href="https://eel.is/c++draft/variant#lib:holds_alternative">🔗<span class="s79"></span></a></span></p>
<p class="p52"><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s5"> T, </span><span class="s35">class</span><span class="s1"> Allocator,<span class="Apple-converted-space">  </span></span><span class="s18">class</span><span class="s11">...</span><span class="s5"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> holds_alternative</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant</span><span class="s11">&lt;Allocator, </span><span class="s1">Types</span><span class="s11">...&gt;&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s1">;</span></p>
<p class="p17"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Mandates</i>: The type T occurs exactly once in Types.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Returns</i>: </span><span class="s20">true</span><span class="s1"> if index</span><span class="s14">()</span><span class="s1"> is equal to the zero-based index of T in Types<a href="https://eel.is/c++draft/variant#get-2.sentence-1"><span class="s8">.</span></a></span></p>
<p class="p72"><span class="s1"><a href="https://eel.is/c++draft/variant#get-itemdecl:2">🔗<span class="s79"></span></a></span></p>
<p class="p52"><span class="s18">template</span><span class="s11">&lt;</span><span class="s5">size_t I, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s18">class</span><span class="s11">...</span><span class="s5"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&amp;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1">;<span class="Apple-converted-space">                                  </span></span><span class="s12"><i>// exposition only</i></span></p>
<p class="p22"><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&amp;&amp;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1">; <span class="Apple-converted-space">                                </span></span><span class="s12"><i>// exposition only</i></span></p>
<p class="p22"><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">const</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&amp;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1">;<span class="Apple-converted-space">                            </span></span><span class="s12"><i>// exposition only</i></span></p>
<p class="p22"><span class="s18">template</span><span class="s11">&lt;</span><span class="s1">size_t I, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">const</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&amp;&amp;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1">; <span class="Apple-converted-space">                          </span></span><span class="s12"><i>// exposition only</i></span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Mandates</i>: </span><span class="s23">I &lt; </span><span class="s58">sizeof</span><span class="s36">...</span><span class="s56">(</span><span class="s23">Types</span><span class="s56">)</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Preconditions</i>: v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> is I.</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Returns</i>: A reference to the object stored in the basic_variant.</span></p>
<p class="p72"><span class="s1"><a href="https://eel.is/c++draft/variant#lib:get,variant">🔗<span class="s79"></span></a></span></p>
<p class="p52"><span class="s35">template</span><span class="s46">&lt;</span><span class="s1">size_t I, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s35">class</span><span class="s46">...</span><span class="s1"> Types</span><span class="s46">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&amp;</span><span class="s1"> get</span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p52"><span class="s35">template</span><span class="s46">&lt;</span><span class="s1">size_t I, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s35">class</span><span class="s46">...</span><span class="s1"> Types</span><span class="s46">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&amp;&amp;</span><span class="s1"> get</span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p52"><span class="s35">template</span><span class="s46">&lt;</span><span class="s1">size_t I, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s35">class</span><span class="s46">...</span><span class="s1"> Types</span><span class="s46">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">const</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&amp;</span><span class="s1"> get</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p52"><span class="s35">template</span><span class="s46">&lt;</span><span class="s1">size_t I, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s35">class</span><span class="s46">...</span><span class="s1"> Types</span><span class="s46">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">const</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&amp;&amp;</span><span class="s1"> get</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><i></i></span><br></p>
<p class="p17"><span class="s1"><i>Mandates</i>: </span><span class="s23">I &lt; </span><span class="s58">sizeof</span><span class="s36">...</span><span class="s56">(</span><span class="s23">Types</span><span class="s56">)</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i>Effects</i>: If v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> is I, returns a reference to the object stored in the variant<a href="https://eel.is/c++draft/variant#get-7.sentence-1"><span class="s8">.</span></a> Otherwise, throws an exception of type bad_variant_access.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p22"><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s1"> T, </span><span class="s80">class</span><span class="s5"> Allocator, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s18">constexpr</span><span class="s1"> T</span><span class="s11">&amp;</span><span class="s1"> get</span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p22"><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s1"> T, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span><span class="s18">constexpr</span><span class="s1"> T</span><span class="s11">&amp;&amp;</span><span class="s1"> get</span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p22"><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s1"> T, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">const</span><span class="s1"> T</span><span class="s11">&amp;</span><span class="s1"> get</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p22"><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s1"> T, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span><span class="s1"> </span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">const</span><span class="s1"> T</span><span class="s11">&amp;&amp;</span><span class="s1"> get</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s1"><i>Mandates</i>: The type T occurs exactly once in Types.</span></p>
<p class="p17"><span class="s1"><i>Effects</i>: If v holds a value of type T, returns a reference to that value<a href="https://eel.is/c++draft/variant#get-9.sentence-1"><span class="s8">.</span></a> Otherwise, throws an exception of type bad_variant_access<a href="https://eel.is/c++draft/variant#get-9.sentence-2"><span class="s8">.</span></a></span></p>
<p class="p72"><span class="s1"><a href="https://eel.is/c++draft/variant#lib:get_if">🔗<span class="s79"></span></a></span></p>
<p class="p52"><span class="s35">template</span><span class="s46">&lt;</span><span class="s1">size_t I, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s35">class</span><span class="s46">...</span><span class="s1"> Types</span><span class="s46">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> add_pointer_t</span><span class="s11">&lt;</span><span class="s1">variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">*</span><span class="s1"> v</span><span class="s14">)</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s1">;</span></p>
<p class="p52"><span class="s35">template</span><span class="s46">&lt;</span><span class="s1">size_t I, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s35">class</span><span class="s46">...</span><span class="s1"> Types</span><span class="s46">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> add_pointer_t</span><span class="s11">&lt;</span><span class="s18">const</span><span class="s1"> variant_alternative_t</span><span class="s11">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&gt;&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">*</span><span class="s1"> v</span><span class="s14">)</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s1">;</span></p>
<p class="p17"><span class="s1"><i>Mandates</i>: </span><span class="s23">I &lt; </span><span class="s58">sizeof</span><span class="s36">...</span><span class="s56">(</span><span class="s23">Types</span><span class="s56">)</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i>Returns</i>: A pointer to the value stored in the variant, if v </span><span class="s11">!=</span><span class="s1"> </span><span class="s20">nullptr</span><span class="s1"> and v</span><span class="s11">-&gt;</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">==</span><span class="s1"> I<a href="https://eel.is/c++draft/variant#get-11.sentence-1"><span class="s8">.</span></a> Otherwise, returns </span><span class="s20">nullptr<a href="https://eel.is/c++draft/variant#get-11.sentence-2"><span class="s43">.</span></a></span></p>
<p class="p72"><span class="s1"><a href="https://eel.is/c++draft/variant#lib:get_if_">🔗<span class="s79"></span></a></span></p>
<p class="p22"><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s1"> T, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> add_pointer_t</span><span class="s11">&lt;</span><span class="s1">T</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">*</span><span class="s1"> v</span><span class="s14">)</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s1">;</span></p>
<p class="p22"><span class="s18">template</span><span class="s11">&lt;</span><span class="s18">class</span><span class="s1"> T, </span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s18">class</span><span class="s11">...</span><span class="s1"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> add_pointer_t</span><span class="s11">&lt;</span><span class="s18">const</span><span class="s1"> T</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">*</span><span class="s1"> v</span><span class="s14">)</span><span class="s1"> </span><span class="s18">noexcept</span><span class="s1">;</span></p>
<p class="p17"><span class="s1"><i>Mandates</i>: The type T occurs exactly once in Types.</span></p>
<p class="p17"><span class="s1"><i>Effects</i>: Equivalent to: </span><span class="s18">return</span><span class="s1"> get_if</span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1">; with </span><span class="s23"><i>i</i></span><span class="s1"> being the zero-based index of T in Types.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p20"><span class="s13"><b> Relational operators</b></span><span class="s1"><b> [basic.variant.relops]</b></span></p>
<p class="p72"><span class="s1"><a href="https://eel.is/c++draft/variant#lib:operator==,variant">🔗<span class="s79"></span></a></span></p>
<p class="p52"><span class="s18">template</span><span class="s11">&lt;</span><span class="s35">class</span><span class="s1"> Allocator, </span><span class="s18">class</span><span class="s11">...</span><span class="s5"> Types</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> </span><span class="s18">operator</span><span class="s11">==</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> v, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> w</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1"> </span><span class="s11">==</span><span class="s1"> <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s18">bool</span><span class="s1">, for all </span><span class="s23"><i>i</i></span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i>Returns</i>: If v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">!=</span><span class="s1"> w</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">, </span><span class="s20">false</span><span class="s1">; otherwise if v</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">()</span><span class="s1">, </span><span class="s20">true</span><span class="s1">; otherwise <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1"> </span><span class="s11">==</span><span class="s1"> <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1"> with </span><span class="s23"><i>i</i></span><span class="s1"> being v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> </span><span class="s18">operator</span><span class="s11">!=</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> v, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> w</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1"> </span><span class="s11">!=</span><span class="s1"> <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s18">bool</span><span class="s1">, for all </span><span class="s23"><i>i</i></span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i>Returns</i>: If v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">!=</span><span class="s1"> w</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">, </span><span class="s20">true</span><span class="s1">; otherwise if v</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">()</span><span class="s1">, </span><span class="s20">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1"> </span><span class="s11">!=</span><span class="s1"> <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1"> with </span><span class="s23"><i>i</i></span><span class="s1"> being v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> </span><span class="s18">operator</span><span class="s11">&lt;</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> v, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> w</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1"> </span><span class="s11">&lt;</span><span class="s1"> <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s18">bool</span><span class="s1">, for all </span><span class="s23"><i>i</i></span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i>Returns</i>: If w</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">()</span><span class="s1">, </span><span class="s20">false</span><span class="s1">; otherwise if v</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">()</span><span class="s1">, </span><span class="s20">true</span><span class="s1">; otherwise, if v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">&lt;</span><span class="s1"> w</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">, </span><span class="s20">true</span><span class="s1">; otherwise if v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">&gt;</span><span class="s1"> w</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">, </span><span class="s20">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1"> </span><span class="s11">&lt;</span><span class="s1"> <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1"> with </span><span class="s23"><i>i</i></span><span class="s1"> being v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> </span><span class="s18">operator</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> v, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> w</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1"> </span><span class="s11">&gt;</span><span class="s1"> <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s18">bool</span><span class="s1">, for all </span><span class="s23"><i>i</i></span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i>Returns</i>: If v</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">()</span><span class="s1">, </span><span class="s20">false</span><span class="s1">; otherwise if w</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">()</span><span class="s1">, </span><span class="s20">true</span><span class="s1">; otherwise, if v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">&gt;</span><span class="s1"> w</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">, </span><span class="s20">true</span><span class="s1">; otherwise if v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">&lt;</span><span class="s1"> w</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">, </span><span class="s20">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1"> </span><span class="s11">&gt;</span><span class="s1"> <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1"> with </span><span class="s23"><i>i</i></span><span class="s1"> being v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()<a href="https://eel.is/c++draft/variant#relops-8.sentence-1"><span class="s43">.</span></a></span></p>
<p class="p15"><span class="s1"><a href="https://eel.is/c++draft/variant#relops-8.sentence-1"></a></span><br></p>
<p class="p24"><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> </span><span class="s18">operator</span><span class="s11">&lt;=</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> v, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> w</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1"> </span><span class="s11">&lt;=</span><span class="s1"> <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s18">bool</span><span class="s1">, for all </span><span class="s23"><i>i</i></span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i>Returns</i>: If v</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">()</span><span class="s1">, </span><span class="s20">true</span><span class="s1">; otherwise if w</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">()</span><span class="s1">, </span><span class="s20">false</span><span class="s1">; otherwise, if v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">&lt;</span><span class="s1"> w</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">, </span><span class="s20">true</span><span class="s1">; otherwise if v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">&gt;</span><span class="s1"> w</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">, </span><span class="s20">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1"> </span><span class="s11">&lt;=</span><span class="s1"> <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1"> with </span><span class="s23"><i>i</i></span><span class="s1"> being v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()<a href="https://eel.is/c++draft/variant#relops-10.sentence-1"><span class="s43">.</span></a></span></p>
<p class="p15"><span class="s1"><a href="https://eel.is/c++draft/variant#relops-10.sentence-1"></a></span><br></p>
<p class="p24"><span class="s1">template&lt;class Allocator, class... Types&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">bool</span><span class="s1"> </span><span class="s18">operator</span><span class="s11">&gt;=</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> v, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> w</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1"> </span><span class="s11">&gt;=</span><span class="s1"> <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s18">bool</span><span class="s1">, for all </span><span class="s23"><i>i</i></span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i>Returns</i>: If w</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">()</span><span class="s1">, </span><span class="s20">true</span><span class="s1">; otherwise if v</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">()</span><span class="s1">, </span><span class="s20">false</span><span class="s1">; otherwise, if v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">&gt;</span><span class="s1"> w</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">, </span><span class="s20">true</span><span class="s1">; otherwise if v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">&lt;</span><span class="s1"> w</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">, </span><span class="s20">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1"> </span><span class="s11">&gt;=</span><span class="s1"> <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1"> with </span><span class="s23"><i>i</i></span><span class="s1"> being v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">template&lt;class Allocator, class... Types&gt;</span><span class="s13"> </span><span class="s1">requires</span><span class="s13"> </span><span class="s14">(<a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable"><span class="s6">three_way_comparable</span></a></span><span class="s11">&lt;</span><span class="s13">Types</span><span class="s11">&gt;</span><span class="s13"> </span><span class="s11">&amp;&amp;</span><span class="s13"> </span><span class="s11">...</span><span class="s14">)</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> common_comparison_category_t</span><span class="s11">&lt;</span><span class="s1">compare_three_way_result_t</span><span class="s11">&lt;</span><span class="s1">Types</span><span class="s11">&gt;...&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s18">operator</span><span class="s11">&lt;=&gt;</span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> v, </span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s11">&amp;</span><span class="s1"> w</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Effects</i>: Equivalent to:</span></p>
<p class="p22"><span class="s18"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if</span><span class="s1"> </span><span class="s14">(</span><span class="s1">v</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">()</span><span class="s1"> </span><span class="s11">&amp;&amp;</span><span class="s1"> w</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">())</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s18">return</span><span class="s1"> strong_ordering</span><span class="s11">::</span><span class="s1">equal;</span></p>
<p class="p22"><span class="s18"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if</span><span class="s1"> </span><span class="s14">(</span><span class="s1">v</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">())</span><span class="s1"> </span><span class="s18">return</span><span class="s1"> strong_ordering</span><span class="s11">::</span><span class="s1">less;</span></p>
<p class="p22"><span class="s18"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if</span><span class="s1"> </span><span class="s14">(</span><span class="s1">w</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">())</span><span class="s1"> </span><span class="s18">return</span><span class="s1"> strong_ordering</span><span class="s11">::</span><span class="s1">greater;</span></p>
<p class="p22"><span class="s18"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if</span><span class="s1"> </span><span class="s14">(</span><span class="s18">auto</span><span class="s1"> c </span><span class="s11">=</span><span class="s1"> v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> </span><span class="s11">&lt;=&gt;</span><span class="s1"> w</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">; c </span><span class="s11">!=</span><span class="s1"> </span><span class="s20">0</span><span class="s14">)</span><span class="s1"> </span><span class="s18">return</span><span class="s1"> c;</span></p>
<p class="p22"><span class="s18"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>return</span><span class="s1"> \exposid</span><span class="s14">{</span><span class="s1">GET</span><span class="s14">}</span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">)</span><span class="s1"> </span><span class="s11">&lt;=&gt;</span><span class="s1"> \exposid</span><span class="s14">{</span><span class="s1">GET</span><span class="s14">}</span><span class="s11">&lt;</span><span class="s23"><i>i</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span>with </span><span class="s23"><i>i</i></span><span class="s1"> being v</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s13"><b>Visitation </b></span><span class="s1"><b>[basic.variant.visit]</b></span></h3>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span>Let <i>as-basic-variant</i> denote the following exposition-only function templates:</span></p>
<p class="p24"><span class="s1"><span class="Apple-tab-span">	</span>template&lt;class Allocator, class</span><span class="s11">...</span><span class="s13"> Ts</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s18">auto</span><span class="s11">&amp;&amp;</span><span class="s1"> <i>as-basic-variant</i></span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Ts</span><span class="s11">...&gt;&amp;</span><span class="s1"> var</span><span class="s14">)</span><span class="s1"> </span><span class="s14">{</span><span class="s1"> </span><span class="s18">return</span><span class="s1"> var; </span><span class="s14">}</span></p>
<p class="p24"><span class="s1"><span class="Apple-tab-span">	</span>template&lt;class Allocator, class</span><span class="s11">...</span><span class="s13"> Ts</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s18">auto</span><span class="s11">&amp;&amp;</span><span class="s1"> <i>as-basic-variant</i></span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Ts</span><span class="s11">...&gt;&amp;</span><span class="s1"> var</span><span class="s14">)</span><span class="s1"> </span><span class="s14">{</span><span class="s1"> </span><span class="s18">return</span><span class="s1"> var; </span><span class="s14">}</span></p>
<p class="p24"><span class="s1"><span class="Apple-tab-span">	</span>template&lt;class Allocator, class</span><span class="s11">...</span><span class="s13"> Ts</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s18">auto</span><span class="s11">&amp;&amp;</span><span class="s1"> <i>as-basic-variant</i></span><span class="s14">(</span><span class="s1">basic_variant&lt;Allocator, Ts</span><span class="s11">...&gt;&amp;&amp;</span><span class="s1"> var</span><span class="s14">)</span><span class="s1"> </span><span class="s14">{</span><span class="s1"> </span><span class="s18">return</span><span class="s1"> std</span><span class="s11">::</span><span class="s1">move</span><span class="s14">(</span><span class="s1">var</span><span class="s14">)</span><span class="s1">; </span><span class="s14">}</span></p>
<p class="p24"><span class="s1"><span class="Apple-tab-span">	</span>template&lt;class Allocator, class</span><span class="s11">...</span><span class="s13"> Ts</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span> </span></span><span class="s18">auto</span><span class="s11">&amp;&amp;</span><span class="s1"> <i>as-basic-variant</i></span><span class="s14">(</span><span class="s18">const</span><span class="s1"> basic_variant&lt;Allocator, Ts</span><span class="s11">...&gt;&amp;&amp;</span><span class="s1"> var</span><span class="s14">)</span><span class="s1"> </span><span class="s14">{</span><span class="s1"> </span><span class="s18">return</span><span class="s1"> std</span><span class="s11">::</span><span class="s1">move</span><span class="s14">(</span><span class="s1">var</span><span class="s14">)</span><span class="s1">; </span><span class="s14">}</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span>Let </span><span class="s23"><i>n</i></span><span class="s1"> be </span><span class="s18">sizeof</span><span class="s11">...</span><span class="s14">(</span><span class="s1">Variants</span><span class="s14">)<a href="https://eel.is/c++draft/variant#visit-1.sentence-2"><span class="s43">.</span></a></span><span class="s1"> For each 0≤<i>i</i>&lt;<i>n</i>, let </span><span class="s23">V</span><span class="s33"><i>i</i></span><span class="s1"> denote the type </span><span class="s18">decltype</span><span class="s14">(</span><span class="s1"><i>as-basic-variant</i></span><span class="s14">(</span><span class="s1">std</span><span class="s11"> :: </span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s23">Variants</span><span class="s33"><i>,</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s23">vars</span><span class="s33"><i>i</i></span><span class="s14">)))</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: </span><span class="s23">V</span><span class="s33"><i>i</i></span><span class="s1"> is a valid type for all 0≤<i>i</i>&lt;<i>n.</i></span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span>Let V denote the pack of types </span><span class="s23">V</span><span class="s33"><i>i.</i></span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span>Let </span><span class="s23"><i>m</i></span><span class="s1"> be a pack of </span><span class="s23"><i>n</i></span><span class="s1"> values of type size_t<a href="https://eel.is/c++draft/variant#visit-4.sentence-1"><span class="s8">.</span></a> Such a pack is valid if 0≤<i>m</i></span><span class="s33"><i>i</i></span><span class="s1">&lt;</span><span class="s23">variant_size_v</span><span class="s36">&lt;</span><span class="s23">remove_reference_t</span><span class="s36">&lt;</span><span class="s23">V</span><span class="s81"><i>i</i></span><span class="s36">&gt;&gt;</span><span class="s1"> for all 0≤<i>i</i>&lt;<i>n.</i></span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span>For each valid pack </span><span class="s23"><i>m</i></span><span class="s1">, let </span><span class="s23"><i>e</i>(<i>m</i>)</span><span class="s1"> denote the expression:</span></p>
<p class="p22"><span class="s1"><i><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>INVOKE</i></span><span class="s14">(</span><span class="s1">std</span><span class="s11">::</span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">Visitor</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">vis</span><span class="s14">)</span><span class="s1">, <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>m</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">std</span><span class="s11">::</span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">V</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">vars</span><span class="s14">))</span><span class="s11">...</span><span class="s14">)</span><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s12"><i>// see </i><a href="https://eel.is/c++draft/func.require"><span class="s6"><i>[func.require]</i></span></a></span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span>for the first form and</span></p>
<p class="p22"><span class="s1"><i><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>INVOKE</i></span><span class="s11">&lt;</span><span class="s1">R</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">std</span><span class="s11">::</span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">Visitor</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">vis</span><span class="s14">)</span><span class="s1">, <i>GET</i></span><span class="s11">&lt;</span><span class="s23"><i>m</i></span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">std</span><span class="s11">::</span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">V</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">vars</span><span class="s14">))</span><span class="s11">...</span><span class="s14">)</span><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s12"><i>// see </i><a href="https://eel.is/c++draft/func.require"><span class="s6"><i>[func.require]</i></span></a></span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span>for the second form.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p17"><span class="s1"><i>Mandates</i>: For each valid pack </span><span class="s23"><i>m</i></span><span class="s1">, </span><span class="s23"><i>e</i>(<i>m</i>)</span><span class="s1"> is a valid expression<a href="https://eel.is/c++draft/variant#visit-5.sentence-1"><span class="s8">.</span></a> All such expressions are of the same type and value category.</span></p>
<p class="p17"><span class="s1"><i>Returns</i>: </span><span class="s23"><i>e</i>(<i>m</i>)</span><span class="s1">, where </span><span class="s23"><i>m</i></span><span class="s1"> is the pack for which <i>m</i></span><span class="s33"><i>i</i></span><span class="s1"> is <i>as-basic-variant</i></span><span class="s14">(</span><span class="s1">vars</span><span class="s33"><i>i</i></span><span class="s14">)</span><span class="s11">.</span><span class="s1">index</span><span class="s14">()</span><span class="s1"> for all 0≤<i>i</i>&lt;<i>n.</i> The return type is </span><span class="s58">decltype</span><span class="s56">(</span><span class="s23"><i>e</i>(<i>m</i>)</span><span class="s56">)</span><span class="s1"> for the first form.</span></p>
<p class="p17"><span class="s1"><i>Throws</i>: bad_variant_access if </span><span class="s14">(</span><span class="s1"><i>as-basic-variant</i></span><span class="s14">(</span><span class="s1">vars</span><span class="s14">)</span><span class="s11">.</span><span class="s1">valueless_by_exception</span><span class="s14">()</span><span class="s1"> </span><span class="s11">||</span><span class="s1"> </span><span class="s11">...</span><span class="s14">)</span><span class="s1"> is </span><span class="s20">true</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Complexity</i>: For </span><span class="s23"><i>n</i> </span><span class="s82"> </span><span class="s23">≤</span><span class="s82"> </span><span class="s23">1</span><span class="s1">, the invocation of the callable object is implemented in constant time, i.e., for <i>n</i>=1, it does not depend on the number of alternative types of </span><span class="s23">V</span><span class="s33">0</span><span class="s37">.</span><span class="s1"> For <i>n</i>&gt;1, the invocation of the callable object has no complexity requirements<a href="https://eel.is/c++draft/variant#visit-8.sentence-2"><span class="s8">.</span></a></span></p>
<p class="p72"><span class="s1"><a href="https://eel.is/c++draft/variant#lib:visit,variant_">🔗<span class="s79"></span></a></span></p>
<p class="p24"><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> Self, </span><span class="s1">class</span><span class="s13"> Visitor</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> </span><span class="s18">decltype</span><span class="s14">(</span><span class="s18">auto</span><span class="s14">)</span><span class="s1"> visit</span><span class="s14">(</span><span class="s18">this</span><span class="s1"> Self</span><span class="s11">&amp;&amp;</span><span class="s1"> self, Visitor</span><span class="s11">&amp;&amp;</span><span class="s1"> vis</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s1">Let V be <i>OVERRIDE_REF</i></span><span class="s14">(</span><span class="s1">Self</span><span class="s11">&amp;&amp;</span><span class="s1">, <i>COPY_CONST</i></span><span class="s14">(</span><span class="s1">remove_reference_t</span><span class="s11">&lt;</span><span class="s1">Self</span><span class="s11">&gt;</span><span class="s1">, variant</span><span class="s14">))</span><span class="s1"> (<a href="https://eel.is/c++draft/forward"><span class="s16">[forward]</span></a>)<a href="https://eel.is/c++draft/variant#visit-9.sentence-1"><span class="s8">.</span></a></span></p>
<p class="p17"><span class="s1"><i>Constraints</i>: The call to visit does not use an explicit <a href="https://eel.is/c++draft/temp.names#nt:template-argument-list"><span class="s16"><i>template-argument-list</i></span></a> that begins with a type <a href="https://eel.is/c++draft/temp.names#nt:template-argument"><span class="s16"><i>template-argument</i></span></a><a href="https://eel.is/c++draft/variant#visit-10.sentence-1"><span class="s8">.</span></a></span></p>
<p class="p17"><span class="s1"><i>Effects</i>: Equivalent to: </span><span class="s18">return</span><span class="s1"> std</span><span class="s11"> :: </span><span class="s1">visit</span><span class="s14">(</span><span class="s1">std</span><span class="s11"> :: </span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">Visitor</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">vis</span><span class="s14">)</span><span class="s1">, </span><span class="s14">(</span><span class="s1">V</span><span class="s14">)</span><span class="s1">self</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p72"><span class="s1"><a href="https://eel.is/c++draft/variant#lib:visit,variant__">🔗<span class="s79"></span></a></span></p>
<p class="p24"><span class="s1">template</span><span class="s11">&lt;</span><span class="s1">class</span><span class="s13"> R, </span><span class="s1">class</span><span class="s13"> Self, </span><span class="s1">class</span><span class="s13"> Visitor</span><span class="s11">&gt;</span></p>
<p class="p22"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s1"> R visit</span><span class="s14">(</span><span class="s18">this</span><span class="s1"> Self</span><span class="s11">&amp;&amp;</span><span class="s1"> self, Visitor</span><span class="s11">&amp;&amp;</span><span class="s1"> vis</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p17"><span class="s1">Let V be <i>OVERRIDE_REF</i></span><span class="s14">(</span><span class="s1">Self</span><span class="s11">&amp;&amp;</span><span class="s1">, <i>COPY_CONST</i></span><span class="s14">(</span><span class="s1">remove_reference_t</span><span class="s11">&lt;</span><span class="s1">Self</span><span class="s11">&gt;</span><span class="s1">, variant</span><span class="s14">))</span><span class="s1"> (<a href="https://eel.is/c++draft/forward"><span class="s16">[forward]</span></a>)<a href="https://eel.is/c++draft/variant#visit-12.sentence-1"><span class="s8">.</span></a></span></p>
<p class="p17"><span class="s1"><i>Effects</i>: Equivalent to: </span><span class="s18">return</span><span class="s1"> std</span><span class="s11"> :: </span><span class="s1">visit</span><span class="s11">&lt;</span><span class="s1">R</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">std</span><span class="s11"> :: </span><span class="s1">forward</span><span class="s11">&lt;</span><span class="s1">Visitor</span><span class="s11">&gt;</span><span class="s14">(</span><span class="s1">vis</span><span class="s14">)</span><span class="s1">, </span><span class="s14">(</span><span class="s1">V</span><span class="s14">)</span><span class="s1">self</span><span class="s14">)</span><span class="s1">;</span></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; color: #0000e9; -webkit-text-stroke: #0000e9; min-height: 19.0px"><span class="s1"><b></b></span><br></h3>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s13"><b>Specialized algorithms</b></span><span class="s1"><b> [basic.variant.specalg]</b></span></h3>
<h3 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times"><span class="s18">template</span><span class="s11">&lt;</span><span class="s35">class</span><span class="s1"> Allocator,<span class="Apple-converted-space">  </span></span><span class="s18">class</span><span class="s11">...</span><span class="s5"> Types</span><span class="s11">&gt;</span></h3>
<h3 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #440045"><span class="s5"><span class="Apple-converted-space">  </span></span><span class="s18">constexpr</span><span class="s5"> </span><span class="s18">void</span><span class="s5"> swap</span><span class="s14">(</span><span class="s46">basic_</span><span class="s5">variant</span><span class="s46">&lt;Allocator, </span><span class="s5">Types</span><span class="s46">...&gt;&amp;</span><span class="s5"> v, </span><span class="s46">basic_</span><span class="s5">variant</span><span class="s46">&lt;Allocator, </span><span class="s5">Types</span><span class="s46">...&gt;&amp;</span><span class="s5"> w</span><span class="s14">)</span><span class="s5"> </span><span class="s18">noexcept</span><span class="s14">(</span><span class="s5"><i>see below</i></span><span class="s14">)</span><span class="s5">;</span></h3>
<p class="p18"><span class="s1"><a href="https://eel.is/c++draft/variant#specalg-1">1<span class="s7"></span></a></span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: is_move_constructible_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> </span><span class="s11">&amp;&amp;</span><span class="s1"> is_swappable_v</span><span class="s11">&lt;</span><span class="s23">T</span><span class="s33"><i>i</i></span><span class="s11">&gt;</span><span class="s1"> is </span><span class="s20">true</span><span class="s1"> for all </span><span class="s23"><i>i</i></span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>: Equivalent to v</span><span class="s11">.</span><span class="s1">swap</span><span class="s14">(</span><span class="s1">w</span><span class="s14">)</span><span class="s1">.</span></p>
<p class="p17"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: The exception specification is equivalent to </span><span class="s18">noexcept</span><span class="s14">(</span><span class="s1">v</span><span class="s11">.</span><span class="s1">swap</span><span class="s14">(</span><span class="s1">w</span><span class="s14">))<a href="https://eel.is/c++draft/variant#specalg-3.sentence-1"><span class="s43">.</span></a></span></p>
<p class="p15"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s13"><b>Hash support</b></span><span class="s1"><b> [basic.variant.hash]</b></span></h3>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #440045"><span class="s18">template</span><span class="s46">&lt;</span><span class="s18">class</span><span class="s5"> Allocator, </span><span class="s18">class</span><span class="s46">...</span><span class="s5"> Types</span><span class="s46">&gt;</span><span class="s5"> </span><span class="s18">struct</span><span class="s5"> hash</span><span class="s46">&lt;basic_</span><span class="s5">variant</span><span class="s46">&lt;Allocator, </span><span class="s5">Types</span><span class="s46">...&gt;&gt;</span><span class="s5">;</span></h3>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000"><span class="s1">The specialization hash</span><span class="s11">&lt;basic_</span><span class="s1">variant</span><span class="s11">&lt;</span><span class="s76">Allocator , </span><span class="s1">Types</span><span class="s11">...&gt;&gt;</span><span class="s1"> is enabled (<a href="https://eel.is/c++draft/unord.hash"><span class="s16">[unord.hash]</span></a>) if and only if every specialization in hash</span><span class="s11">&lt;</span><span class="s1">remove_const_t</span><span class="s11">&lt;</span><span class="s1">Types</span><span class="s11">&gt;&gt;...</span><span class="s1"> is enabled<a href="https://eel.is/c++draft/variant#hash-1.sentence-1"><span class="s8">.</span></a> The member functions are not guaranteed to be </span><span class="s18">noexcept</span><span class="s1">.</span></h3>
<p class="p15"><span class="s1"></span><br></p>
<p class="p7"><span class="s1"></span><br></p>
</body>
</html>
