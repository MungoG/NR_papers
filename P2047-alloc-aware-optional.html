<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>An allocator-aware optional type</title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2113.3">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 13.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 13.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p3 {margin: 0.0px 0.0px 6.0px 0.0px; font: 13.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 16.0px}
    p.p6 {margin: 0.0px 0.0px 12.0px 0.0px; text-align: justify; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p8 {margin: 0.0px 0.0px 12.0px 0.0px; text-align: justify; font: 13.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 16.0px}
    p.p9 {margin: 0.0px 0.0px 12.0px 0.0px; text-align: justify; font: 13.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 16.0px}
    p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p13 {margin: 0.0px 0.0px 21.4px 0.0px; font: 32.0px Times; -webkit-text-stroke: #000000}
    p.p14 {margin: 0.0px 0.0px 19.9px 0.0px; font: 24.0px Times; -webkit-text-stroke: #000000}
    p.p15 {margin: 0.0px 0.0px 16.0px 0.0px; font: 16.0px Times; -webkit-text-stroke: #000000}
    p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; font: 10.4px Courier; -webkit-text-stroke: #000000}
    p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; font: 10.4px Courier; -webkit-text-stroke: #000000; min-height: 13.0px}
    p.p18 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Courier; -webkit-text-stroke: #000000; min-height: 16.0px}
    p.p22 {margin: 0.0px 0.0px 12.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p25 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0a4d69; -webkit-text-stroke: #0a4d69}
    p.p26 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #0f7001; -webkit-text-stroke: #0f7001}
    p.p27 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; -webkit-text-stroke: #000000}
    p.p28 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #0f7001; -webkit-text-stroke: #0f7001; background-color: #21ff06}
    p.p29 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p30 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p31 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p32 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0a4d69; -webkit-text-stroke: #0a4d69; background-color: #21ff06}
    p.p33 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06}
    p.p34 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p35 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; -webkit-text-stroke: #0a4d69; background-color: #21ff06}
    p.p36 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; background-color: #21ff06}
    p.p37 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p38 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p39 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #9d0612; -webkit-text-stroke: #9d0612; min-height: 14.0px}
    p.p40 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p41 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #0d3c56; background-color: #21ff06}
    p.p42 {margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p43 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #9d0612; -webkit-text-stroke: #9d0612}
    p.p45 {margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06}
    p.p46 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #0a4d69; -webkit-text-stroke: #0a4d69; background-color: #21ff06}
    p.p47 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p48 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #000000; background-color: #21ff06; min-height: 14.0px}
    p.p49 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06}
    p.p50 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #0a4d69; background-color: #21ff06}
    p.p51 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #440045; background-color: #21ff06}
    p.p52 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #136002; background-color: #21ff06}
    p.p53 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p54 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; background-color: #21ff06}
    p.p55 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; background-color: #21ff06}
    p.p56 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; -webkit-text-stroke: #000000; background-color: #21ff06; min-height: 14.0px}
    p.p57 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #0a4d69; background-color: #21ff06}
    p.p58 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06; min-height: 14.0px}
    p.p59 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000e3; background-color: #21ff06}
    p.p60 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06}
    p.p61 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #9d0612; -webkit-text-stroke: #9d0612; background-color: #21ff06}
    p.p62 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p63 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; -webkit-text-stroke: #000000; background-color: #21ff06; min-height: 16.0px}
    p.p64 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p65 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06; min-height: 16.0px}
    p.p66 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000; background-color: #21ff06; min-height: 16.0px}
    p.p67 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p68 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #0a4d69; -webkit-text-stroke: #0a4d69; background-color: #21ff06; min-height: 14.0px}
    p.p69 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 10.0px 'Apple Color Emoji'; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06}
    p.p70 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 10.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06; min-height: 13.0px}
    p.p71 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; background-color: #21ff06}
    p.p72 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; background-color: #21ff06}
    p.p73 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; background-color: #21ff06; min-height: 14.0px}
    p.p75 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0a4d69; -webkit-text-stroke: #0a4d69; background-color: #21ff06; min-height: 16.0px}
    p.p76 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #2cff0b}
    p.p77 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06; min-height: 14.0px}
    p.p78 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: center; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p79 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: center; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06; min-height: 14.0px}
    p.p80 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #2cff0b}
    p.p81 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06; min-height: 16.0px}
    p.p82 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #2cff0b}
    p.p83 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p84 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; background-color: #2cff0b}
    p.p85 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; background-color: #21ff06; min-height: 14.0px}
    p.p86 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: center; font: 12.0px Times; color: #000000; background-color: #21ff06}
    p.p87 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: center; font: 12.0px Times; color: #000000; background-color: #21ff06; min-height: 14.0px}
    p.p88 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; background-color: #21ff06}
    p.p89 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; background-color: #2cff0b}
    p.p90 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 10.0px 'Apple Color Emoji'; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06; min-height: 17.0px}
    p.p91 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px 'Lucida Grande'; -webkit-text-stroke: #000000; background-color: #21ff06; min-height: 16.0px}
    p.p92 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p93 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #21ff06}
    p.p94 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000}
    p.p95 {margin: 0.0px 0.0px 0.0px 0.0px; font: 15.6px Times; color: #0000e9; -webkit-text-stroke: #0000e9; min-height: 19.0px}
    p.p96 {margin: 0.0px 0.0px 0.0px 0.0px; font: 15.6px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p97 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #0a4d69; -webkit-text-stroke: #0a4d69}
    p.p98 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #000000}
    p.p99 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 10.0px Menlo; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p100 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #0a4d69; -webkit-text-stroke: #0a4d69; min-height: 14.0px}
    p.p101 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times}
    p.p102 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000; min-height: 16.0px}
    p.p103 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p104 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p106 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 15.6px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p107 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 10.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9; min-height: 13.0px}
    p.p108 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 10.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9; min-height: 13.0px}
    p.p110 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06}
    p.p111 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Courier; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    li.li15 {margin: 0.0px 0.0px 16.0px 0.0px; font: 16.0px Times; -webkit-text-stroke: #000000}
    span.s1 {font-kerning: none}
    span.s2 {text-decoration: underline ; font-kerning: none}
    span.s3 {font: 16.0px Courier; font-kerning: none}
    span.s4 {font: 13.0px Courier; font-kerning: none}
    span.s5 {font: 16.0px Times; text-decoration: underline ; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s6 {font: 13.0px Courier}
    span.s7 {color: #1600ff}
    span.s8 {font-kerning: none; color: #1600ff; -webkit-text-stroke: 0px #1600ff}
    span.s9 {font: 19.5px Courier; font-kerning: none}
    span.s10 {font: 16.0px Times; font-kerning: none}
    span.s11 {font: 18.0px Times; font-kerning: none; color: #000000}
    span.s12 {font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s13 {font-kerning: none; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s14 {font-kerning: none; color: #9d0612; -webkit-text-stroke: 0px #9d0612}
    span.s15 {font: 12.0px Times; font-kerning: none; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s16 {font: 13.3px Times; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s17 {font: 12.0px Times; font-kerning: none}
    span.s18 {font-kerning: none; color: #440045; -webkit-text-stroke: 0px #440045}
    span.s19 {font-kerning: none; color: #0a4d69; -webkit-text-stroke: 0px #0a4d69}
    span.s20 {font: 13.3px Times; font-kerning: none; color: #0f7001; -webkit-text-stroke: 0px #0f7001}
    span.s21 {font-kerning: none; background-color: #21ff06}
    span.s22 {font-kerning: none; color: #0a4d69; background-color: #21ff06; -webkit-text-stroke: 0px #0a4d69}
    span.s23 {font-kerning: none; -webkit-text-stroke: 0px #0000e9}
    span.s24 {font-kerning: none; color: #440045; background-color: #21ff06; -webkit-text-stroke: 0px #440045}
    span.s25 {font-kerning: none; color: #9d0612; background-color: #21ff06; -webkit-text-stroke: 0px #9d0612}
    span.s26 {font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s27 {font-kerning: none; color: #0a4d69}
    span.s28 {font-kerning: none; background-color: #21ff06; -webkit-text-stroke: 0px #000000}
    span.s29 {font-kerning: none; color: #0f7001; -webkit-text-stroke: 0px #0f7001}
    span.s30 {font: 12.0px Times; font-kerning: none; color: #0f7001; -webkit-text-stroke: 0px #0f7001}
    span.s31 {font-kerning: none; -webkit-text-stroke: 0px #340035}
    span.s32 {font-kerning: none; color: #000000}
    span.s33 {font-kerning: none; color: #440045}
    span.s34 {font-kerning: none; color: #440045; -webkit-text-stroke: 0px #000000}
    span.s35 {font-kerning: none; -webkit-text-stroke: 0px #440045}
    span.s36 {font-kerning: none; -webkit-text-stroke: 0px #9d0612}
    span.s37 {font-kerning: none; color: #9d0612}
    span.s38 {font-kerning: none; color: #0a4d69; -webkit-text-stroke: 0px #000000}
    span.s39 {font-kerning: none; -webkit-text-stroke: 0px #136002}
    span.s40 {text-decoration: underline ; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e3}
    span.s41 {font-kerning: none; -webkit-text-stroke: 0px #890010}
    span.s42 {font-kerning: none; -webkit-text-stroke: 0px #0d3c56}
    span.s43 {font: 13.3px Times; font-kerning: none; color: #000000}
    span.s44 {font: 13.3px Times; font-kerning: none}
    span.s45 {font: 13.3px Times; font-kerning: none; color: #440045; -webkit-text-stroke: 0px #440045}
    span.s46 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s47 {font-kerning: none; color: #8c550a; -webkit-text-stroke: 0px #8c550a}
    span.s48 {font-kerning: none; color: #0000ff; -webkit-text-stroke: 0px #0000ff}
    span.s49 {font: 13.3px Times; font-kerning: none; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s50 {font: 13.3px Times; font-kerning: none; color: #8c550a; -webkit-text-stroke: 0px #8c550a}
    span.s51 {font: 10.0px 'Apple Color Emoji'; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s52 {font: 13.3px Times; font-kerning: none; color: #9d0612; -webkit-text-stroke: 0px #9d0612}
    span.s53 {font: 13.3px Times; font-kerning: none; color: #0a4d69; -webkit-text-stroke: 0px #0a4d69}
    span.s54 {font-kerning: none; color: #8c550a}
    span.s55 {font: 12.0px Times; font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s56 {font: 13.3px Times; font-kerning: none; color: #440045}
    span.s57 {font: 13.3px Times; font-kerning: none; color: #9d0612}
    span.s58 {font: 13.3px Times; font-kerning: none; color: #000000; background-color: #21ff06}
    span.s59 {font-kerning: none; -webkit-text-stroke: 0px #78430b}
    span.s60 {font: 13.3px Times; font-kerning: none; color: #000000; background-color: #2cff0b}
    span.s61 {font-kerning: none; color: #440045; background-color: #21ff06; -webkit-text-stroke: 0px #000000}
    span.s62 {font-kerning: none; color: #000000; background-color: #21ff06; -webkit-text-stroke: 0px #000000}
    span.s63 {font-kerning: none; background-color: #2cff0b; -webkit-text-stroke: 0px #78430b}
    span.s64 {font-kerning: none; background-color: #2cff0b}
    span.s65 {font: 13.3px Times; font-kerning: none; color: #000000; background-color: #21ff06; -webkit-text-stroke: 0px #000000}
    span.s66 {font: 13.3px Times; font-kerning: none; color: #000000; background-color: #2cff0b; -webkit-text-stroke: 0px #000000}
    span.s67 {font-kerning: none; color: #440045; background-color: #21ff06}
    span.s68 {font-kerning: none; color: #000000; background-color: #21ff06}
    span.s69 {font: 13.3px Times; text-decoration: underline ; font-kerning: none; color: #0000e9}
    span.s70 {font: 13.3px Times; font-kerning: none; color: #440045; -webkit-text-stroke: 0px #000000}
    span.s71 {font: 13.3px 'Lucida Grande'; font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s72 {font: 13.3px Times; font-kerning: none; background-color: #2cff0b}
    span.s73 {font: 13.3px Times; font-kerning: none; color: #0a4d69}
    span.s74 {font: 13.3px 'Lucida Grande'; font-kerning: none}
    span.s75 {font-kerning: none; color: #000000; -webkit-text-stroke: 0px #9d0612}
    span.s76 {font: 13.3px Times; text-decoration: underline ; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e3}
    span.s77 {font-kerning: none; color: #000000; background-color: #2cff0b; -webkit-text-stroke: 0px #000000}
    span.s78 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #0000e3}
    span.s79 {font: 12.0px 'Lucida Grande'; font-kerning: none}
    span.s80 {font: 12.0px Times; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s81 {font: 12.0px Times; font-kerning: none; color: #000000}
    span.s82 {font: 15.6px Times; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s83 {font-kerning: none; color: #0a4d69; background-color: #21ff06}
    span.s84 {font-kerning: none; color: #9d0612; background-color: #21ff06}
    span.s85 {font: 15.6px Times; font-kerning: none}
    span.s86 {font: 12.0px Times; font-kerning: none; color: #440045; -webkit-text-stroke: 0px #000000}
    span.Apple-tab-span {white-space:pre}
    table.t1 {border-style: solid; border-width: 1.0px 1.0px 1.0px 1.0px; border-color: #6d6d6d #6d6d6d #6d6d6d #6d6d6d}
    td.td1 {width: 75.0px; margin: 0.5px 0.5px 0.5px 0.5px; border-style: solid; border-width: 1.0px 1.0px 1.0px 1.0px; border-color: #6d6d6d #6d6d6d #6d6d6d #6d6d6d; padding: 1.0px 1.0px 1.0px 1.0px}
    td.td2 {width: 494.0px; margin: 0.5px 0.5px 0.5px 0.5px; border-style: solid; border-width: 1.0px 1.0px 1.0px 1.0px; border-color: #6d6d6d #6d6d6d #6d6d6d #6d6d6d; padding: 1.0px 1.0px 1.0px 1.0px}
    td.td3 {width: 439.0px; margin: 0.5px 0.5px 0.5px 0.5px; border-style: solid; border-width: 1.0px 1.0px 1.0px 1.0px; border-color: #6d6d6d #6d6d6d #6d6d6d #6d6d6d; padding: 1.0px 1.0px 1.0px 1.0px}
    ol.ol1 {list-style-type: decimal}
    ul.ul1 {list-style-type: disc}
  </style>
</head>
<body>
<p class="p1"><span class="s1"><i>Document number: P2047R7<span class="Apple-converted-space"> </span></i></span></p>
<p class="p1"><span class="s1"><i>Audience: LEWG<span class="Apple-converted-space"> </span></i></span></p>
<p class="p2"><span class="s2"><a href="mailto:phalpern@halpernwightsoftware.com"><i>Pablo Halpern</i></a></span></p>
<p class="p2"><span class="s2"><a href="mailto:dinka.ranns@gmail.com"><i>Nina Dinka Ranns</i></a></span></p>
<p class="p2"><span class="s2"><a href="mailto:ville.voutilainen@gmail.com"><i>Ville Voutilainen</i></a></span></p>
<p class="p1"><span class="s1"><i>2024-02-12</i></span></p>
<p class="p3"><span class="s1"></span><br></p>
<h1 style="margin: 0.0px 0.0px 16.1px 0.0px; text-align: center; font: 32.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>An allocator-aware optional type</b></span></h1>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 32.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Abstract</b></span></h2>
<p class="p6"><span class="s1">Library types that can potentially hold <i>allocator-aware (AA)</i> objects should, themselves, be allocator-aware. A PMR container, for example, depends on AA types following a known AA protocol so that it (the container) can uniformly manage its memory. Even types that don't manage their own memory, such as </span><span class="s3">tuple</span><span class="s1">, follow the AA rules when they hold one more more AA elements. (A special case is </span><span class="s3">pair</span><span class="s1">, which is not actually AA but effectively follows the rules through special handling in <i>uses-allocator construction</i>.)<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1">The current definition of </span><span class="s3">std::optional</span><span class="s1"> does not follow the rules for an AA type, even when holding an AA value. This limitation makes </span><span class="s3">std::optional</span><span class="s1"> unsuitable for storage in an AA container when memory allocation customization is needed.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1">In this paper, we propose a new, allocator-aware </span><span class="s3">std::basic_optional</span><span class="s1"> usable as a container element type of allocator aware containers, and in any other context where allocator propagation is expected. This new type would not replace the current </span><span class="s3">std::optional</span><span class="s1"> as the desired behaviour is not compatible with how </span><span class="s3">std::optional</span><span class="s1"> handles allocator aware types at the moment. We do propose having a special treatement for </span><span class="s3">std::basic_optional</span><span class="s1"> and </span><span class="s3">std::optional</span><span class="s1"> that allows for certain implicit conversions between the two types. We also propose an </span><span class="s3">std::pmr::optional</span><span class="s1"> type which is a specialisation of </span><span class="s3">std::basic_optional</span><span class="s1"> for </span><span class="s3">std::pmr::polymorphic_allocator&lt;&gt;</span><span class="s1">.<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="s1">This is a complete proposal with formal wording.</span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p9"><span class="s1"><br>
change history : <br>
- replaced </span><span class="s4">alloc_optional</span><span class="s1"> with additional overloads of </span><span class="s4">make_optional</span><span class="s1"> that take an </span><span class="s4">allocator_arg_t</span><span class="s1"> : it was observed that </span><span class="s4">alloc_optional</span><span class="s1"> doesn't actually do any allocation, and that the name is not appropriate <br>
- fixed the order of arguments in the <i>Returns</i> clause of what used to be </span><span class="s4">alloc_optional</span><span class="s1"> <br>
- adjusted for LWG 2833 <br>
- added discussion on deduction guides <br>
- removed mentions of using a type alias since the type alias approach has proven to be problematic <br>
- modified the specification of std::pmr::optional to cover both AA and non AA types <br>
- added CTAD specification <br>
- modified the specification of </span><span class="s4">std::pmr::optional</span><span class="s1"> to be expressed in terms of </span><span class="s4">std::pmr::polymorphic_allocator&lt;&gt;</span><span class="s1">, as opposed to </span><span class="s4">std::pmr::memory_resource</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p10"><span class="s1"></span><br></p>
<p class="p11"><span class="s1">- moved </span><span class="s4">std::pmr::optional</span><span class="s1"> to </span><span class="s4">optional</span><span class="s1"> header as discussed in the reflector discussion<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">- added request for discussion on making </span><span class="s4">std::pmr::optional</span><span class="s1"> a more allocator generic type.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">- added free swap function to be in line with P0178<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">R3:<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">- replaced instances of <i>M_alloc</i> with <i>alloc</i><span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">- clarified pmr::optional constructor descriptions to call out uses-allocator construction<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">- expanded </span><span class="s4">basic_optional</span><span class="s1"> discussion<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">R4:<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">- switched to </span><span class="s4">std::pmr::optional</span><span class="s1"> being a specialisation of </span><span class="s4">std::basic_optional</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">- modified the wording to cover </span><span class="s4">std::basic_optional</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">R5:<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">- various clean up of proposed wording<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">- setting the default allocator to be </span><span class="s4">remove_cv_t</span><span class="s1"> version of value_type<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">- removed make facilities<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">R6:<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">- cleaning up html format<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">- clean up of proposed wording<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">R7:<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">- added design considerations for special member functions and swap</span></p>
<p class="p11"><span class="s1">- improved motivation and summary</span></p>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 23.0px"><span class="s1"><b></b></span><br></h2>
<p class="p13"><span class="s1"><b>Motivation</b></span></p>
<p class="p14"><span class="s1"><b>General Motivation for allocator-aware types</b></span></p>
<p class="p15"><span class="s1"><i>Note: The text below is borrowed nearly verbetim from </i><a href="http://wg21.link/P3002R1"><span class="s5"><i>P3002</i></span></a><i>, which proposes a general policy for when types should use allocators</i></span></p>
<p class="p15"><span class="s1">Memory management is a major part of building software. Numerous facilities in the C++ Standard library exist to give the programmer maximum control over how their program uses memory:</span></p>
<ul class="ul1">
  <li class="li15"><span class="s6"></span><span class="s4">std::unique_ptr</span><span class="s1"> and </span><span class="s4">std::shared_ptr</span><span class="s1"> are parameterized with <i>deleter</i> objects that control, among other things, how memory resources are reclaimed.</span></li>
  <li class="li15"><span class="s6"></span><span class="s4">std::vector</span><span class="s1"> is preferred over other containers in many cases because its use of contiguous memory provides optimal cache locality and minimizes allocate/deallocate operations. Indeed, the LEWG has spent a lot of time on </span><span class="s4">flat_set</span><span class="s1"> (<a href="http://wg21.link/P1222R0"><span class="s5">P1222R0</span></a>) and </span><span class="s4">flat_map</span><span class="s1"> (<a href="http://wg21.link/P0429R3"><span class="s5">P0429R3</span></a>), whose underlying structure defaults to </span><span class="s4">vector</span><span class="s1"> for this reason.</span></li>
  <li class="li15"><span class="s1">Operators </span><span class="s4">new</span><span class="s1"> and </span><span class="s4">delete</span><span class="s1"> are replaceable, giving programmers global control over how memory is allocated.</span></li>
  <li class="li15"><span class="s1">The C++ object model makes a clear distinction between an object’s memory footprint and it’s lifetime.</span></li>
  <li class="li15"><span class="s1">Language constructs such as </span><span class="s4">void*</span><span class="s1"> and </span><span class="s4">reinterpet_cast</span><span class="s1"> provide fine-grained access to objects’ underlying memory.</span></li>
  <li class="li15"><span class="s1">Standard containers and strings are parameterized with allocators, providing object-level control over memory allocation and element construction.</span></li>
</ul>
<p class="p15"><span class="s1">This fine-grained control over memory that C++ gives the programmer is a large part of why C++ is applicable to so many domains — from embedded systems with limited memory budgets to games, high-frequency trading, and scientific simulations that require cache locality, thread affinity, and other memory-related performance optimizations.</span></p>
<p class="p15"><span class="s1">An in-depth description of the value proposition for allocator-aware software can be found in <a href="http://wg21.link/P2035R0"><span class="s5">P2035R0</span></a>. Standard containers are the most ubiquitous examples of <i>allocator-aware</i> types. Their </span><span class="s4">allocator_type</span><span class="s1"> and </span><span class="s4">get_allocator</span><span class="s1"> members and allocator-parameterized constructors allow them to be used like Lego® parts that can be combined and nested as necessary while retaining full programmer control over how the whole assembly allocates memory. For <i>scoped allocators</i> — those that apply not only to the top-level container, but also to its elements — having each element of a container support a predictable allocator-aware interface is crucial to giving the programmer the ability to allocate all memory from a single memory resource, such as an arena or pool. Note that the allocator is a <i>configuration</i> parameter of an object and does not contribute to its value.</span></p>
<p class="p15"><span class="s1">In short, the principles underlying this policy proposal are:</span></p>
<ol class="ol1">
  <li class="li15"><span class="s7"></span><span class="s8">The Standard Library should be general and flexible</span><span class="s1">. To the extent possible, the user of a library class should have control over how memory is allocated.</span></li>
  <li class="li15"><span class="s7"></span><span class="s8">The Standard Library should be consistent</span><span class="s1">. The use of allocators should be consistent with the existing allocator-aware classes and class templates, especially those in the containers library.</span></li>
  <li class="li15"><span class="s7"></span><span class="s8">The parts of the Standard Library should work together</span><span class="s1">. If one part of the library gives the user control over memory allocation but another part does not, then the second part undermines the utility of the first.</span></li>
  <li class="li15"><span class="s7"></span><span class="s8">The Standard Library should encapsulate complexity</span><span class="s1">. Fully general application of allocators is potentially complex and is best left to the experts implementing the Standard Library. Users can choose their own subset of desirable allocator behavior only if the underlying Library classes allow them to choose their preferred approach, whether it be stateless allocators, statically typed allocators, polymorphic allocators, or no allocators.</span></li>
</ol>
<p class="p14"><span class="s1"><b>Motivation for an Allocator-aware </b></span><span class="s9"><b>optional</b></span></p>
<p class="p15"><span class="s1">Although the engaged object in an </span><span class="s4">std::optional</span><span class="s1"> can be initialized with any set of valid constructor arguments, including allocator arguments, the fact that the </span><span class="s4">optional</span><span class="s1"> itself is not allocator-aware prevents it from working consistently with other parts of the standard library, specifically those parts that depend on <i>uses-allocator construction</i> (section [allocator.uses.construction]) in the standard). For example:</span></p>
<p class="p16"><span class="s1">pmr::monotonic_buffer_resource rsrc;</span></p>
<p class="p16"><span class="s1">pmr::polymorphic_allocator&lt;&gt; alloc{ &amp;rsrc };</span></p>
<p class="p16"><span class="s1">using Opt = optional&lt;pmr::string&gt;;</span></p>
<p class="p16"><span class="s1">Opt o = make_obj_using_allocator&lt;Opt&gt;(alloc, in_place, "hello");</span></p>
<p class="p16"><span class="s1">assert(o-&gt;get_allocator() == alloc);<span class="Apple-converted-space">  </span>// FAILS</span></p>
<p class="p15"><span class="s1">Even though an allocator is supplied, it is not used to construct the </span><span class="s4">pmr::string</span><span class="s1"> within the resulting </span><span class="s4">optional</span><span class="s1"> object because </span><span class="s4">optional</span><span class="s1"> does not have the necessary hooks for </span><span class="s4">make_obj_using_allocator</span><span class="s1"> to recognize it as being allocator-aware. Note that, although this example and the ones that follow use </span><span class="s4">pmr::polymorphic_allocator</span><span class="s1">, the same issues would apply to any scoped allocator.</span></p>
<p class="p15"><span class="s1"><i>Uses-allocator construction</i> is rarely used directly in user code. Instead, it is used within the implementation of standard containers and scoped allocators to ensure that the allocator used to construct the container is also used to construct its elements. Continuing the example above, consider what happens if an </span><span class="s4">optional</span><span class="s1"> is stored in a </span><span class="s4">pmr::vector</span><span class="s1">, compared to storing a truly allocator-aware type (</span><span class="s4">pmr::string</span><span class="s1">):</span></p>
<p class="p16"><span class="s1">pmr::vector&lt;pmr::string&gt; vs(alloc);</span></p>
<p class="p16"><span class="s1">pmr::vector&lt;Opt&gt; <span class="Apple-converted-space">        </span>vo(alloc);</span></p>
<p class="p17"><span class="s1"></span><br></p>
<p class="p16"><span class="s1">vs.emplace_back("hello");</span></p>
<p class="p16"><span class="s1">vo.emplace_back("hello");</span></p>
<p class="p17"><span class="s1"></span><br></p>
<p class="p16"><span class="s1">assert(vs.back().get_allocator() == alloc); <span class="Apple-converted-space">  </span>// OK</span></p>
<p class="p16"><span class="s1">assert(vo.back()-&gt;get_allocator() == alloc);<span class="Apple-converted-space">  </span>// FAILS</span></p>
<p class="p18"><span class="s1"></span><br></p>
<p class="p15"><span class="s1">An important invariant when using a scoped allocator such as </span><span class="s4">pmr::polymorphic_allocator</span><span class="s1"> is that the same allocator is used throughout an object hierarchy. It is impossible to ensure that this invariant is preserved when using </span><span class="s4">std::optional</span><span class="s1">, even if the element is originally inserted with the correct allocator, because </span><span class="s4">optional</span><span class="s1"> does not remember the allocator used to construct it and cannot therefore re-instate the allocator going from disengaged to engaged:</span></p>
<p class="p16"><span class="s1">vo.emplace_back(in_place, "hello", alloc);</span></p>
<p class="p16"><span class="s1">assert(vo.back()-&gt;get_allocator() == alloc);<span class="Apple-converted-space">  </span>// OK</span></p>
<p class="p17"><span class="s1"></span><br></p>
<p class="p16"><span class="s1">vo.back() = nullopt;<span class="Apple-converted-space">    </span>// Disengage</span></p>
<p class="p16"><span class="s1">vo.back() = "goodbye";<span class="Apple-converted-space">  </span>// Re-engage</span></p>
<p class="p16"><span class="s1">assert(vo.back()-&gt;get_allocator() == alloc);<span class="Apple-converted-space">  </span>// FAILS</span></p>
<p class="p15"><span class="s1">Finally, when using assignment, the value stored in the </span><span class="s4">optional</span><span class="s1"> is set sometimes by construction and other times by assignment. Depending on the allocator type’s propagation traits, it is difficult to reason about the resulting allocator:</span></p>
<p class="p16"><span class="s1">Opt o1{nullopt};<span class="Apple-converted-space">    </span>// Disengaged -- does not use an allocator</span></p>
<p class="p16"><span class="s1">Opt o2{ "hello" };<span class="Apple-converted-space">  </span>// String uses a default-constructed allocator</span></p>
<p class="p16"><span class="s1">o1 = pmr::string("goodbye", alloc);<span class="Apple-converted-space">    </span>// Constructs the string</span></p>
<p class="p16"><span class="s1">o2 = pmr::string("goodbye", alloc);<span class="Apple-converted-space">    </span>// Assigns to the string</span></p>
<p class="p16"><span class="s1">assert(o1-&gt;get_allocator() == alloc);<span class="Apple-converted-space">  </span>// OK, set by move construction</span></p>
<p class="p16"><span class="s1">assert(o2-&gt;get_allocator() == alloc);<span class="Apple-converted-space">  </span>// ERROR, set by assignment</span></p>
<p class="p17"><span class="s1"></span><br></p>
<p class="p18"><span class="s1"></span><br></p>
<p class="p13"><span class="s1"><b>Summary of the proposed feature</b></span></p>
<p class="p15"><span class="s1">This paper proposes an allocator-aware </span><span class="s4">optional</span><span class="s1">. Unfortunately, it would be complicated to add an allocator to the current </span><span class="s4">std::optional</span><span class="s1"> without causing API and ABI compatibility issues and/or imposing long compile times on code that does not benefit from the change. For this reason, we are proposing a new class template, </span><span class="s4">basic_optional</span><span class="s1">, which works like </span><span class="s4">optional</span><span class="s1">, but adds allocator support.</span></p>
<p class="p15"><span class="s1">The key attributes of </span><span class="s4">basic_optional</span><span class="s1"> that make it different from </span><span class="s4">optional</span><span class="s1"> are:</span></p>
<ul class="ul1">
  <li class="li15"><span class="s1">It has an optional </span><span class="s4">Allocator</span><span class="s1"> template parameter. If not supplied, </span><span class="s4">Allocator</span><span class="s1"> is determined from </span><span class="s4">T::allocator_type</span><span class="s1"> if that exists, otherwise </span><span class="s4">std::allocator&lt;byte&gt;</span><span class="s1">.</span></li>
  <li class="li15"><span class="s1">It has a public </span><span class="s4">allocator_type</span><span class="s1"> member to advertise that it is allocator-aware.</span></li>
  <li class="li15"><span class="s1">There are allocator-enabled versions of every constructor.</span></li>
  <li class="li15"><span class="s1">The supplied allocator is forwarded to the constructor of the engaged object, if that object uses a compatible allocator type. The allocator is retained so that it can be supplied to the contained object whenever the </span><span class="s4">basic_optional</span><span class="s1"> goes from disengaged to engaged. Allocator traits, including propagation traits, are respected.</span></li>
  <li class="li15"><span class="s1">It has an alias, </span><span class="s4">pmr::optional</span><span class="s1">, for which </span><span class="s4">Allocator</span><span class="s1"> is hard-coded to </span><span class="s4">pmr::polymorphic_allocator&lt;&gt;</span><span class="s1">.</span></li>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 32.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Design decisions</b></span></h2>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Default constructor considerations</b></span></h3>
<p class="p6"><span class="s1">Default constructor always does uses_allocator construction in case the default allocator construction produces different allocators each time. Possible optimisation opportunity for allocators which have is_always_equal set to true, but no benefit in triviality or constexpr - uses_allocator construction will be constexpr if it can be constexpr either way.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1">No conditional triviality of the default constructor - the internal state needs to be initialised. This is the same as in std::optional.</span></p>
<p class="p6"><span class="s1">Possible additional consideration is for basic_optional where the value type is not allocator aware - such a basic_variant constexpr considerations would only depend on the constexpr construction of the 0th alternative. We do not propose standardising such optimisations.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Copy constructor considerations</b></span></h3>
<p class="p6"><span class="s1">Copy construction does not do uses_allocator construction - the value type is expected to behave according to the traits and get the right allocator. This allows for triviality if allocator is always equal and the constructed type can be trivially copy constructed. If allocator is not always equal, we need to check the traits to get the right allocator and that initialisation can not be trivial. Possible additional consideration is for basic_optional where the value type is not allocator aware - such a basic_optional does not need to store the allocator and triviality only depends on the triviality of the value type. This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 13.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 16.0px"><span class="s1"><b></b></span><br></h3>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Move constructor considerations</b></span></h3>
<p class="p6"><span class="s1">Move construction does not do uses_allocator construction - the value type is expected to behave according to the traits and get the right allocator. This allows for triviality if allocator can be trivially copy constructed and the constructed type can be trivially move constructed. Possible additional consideration is for basic_optional where the value type is not allocator aware - such a basic_optional does not need to store the allocator and triviality only depends on the triviality of the value type. This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Value constructor considerations</b></span></h3>
<p class="p6"><span class="s1">Value construction must do uses_allocator construction if allocators aren't always equal- the plain copy/move construction may use the wrong allocator.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1">The paper does not propose exception specification on this value constructor and considers it QOI</span></p>
<p class="p6"><span class="s1">Exception specification considerations<span class="Apple-converted-space">  </span>: <br>
- for non AA type, the exception specification is equivalent to is_nothrow_constructible_v&lt;ValueType, T&gt; <br>
- for AA type, to get a possibly no throw construction, we need to delegate to plain copy/move which can possibly reuse the allocation. The delegation can only happen if allocators are always equal. If this constructor checked for allocators being always equal before deciding whether to do uses allocator construction or not, it would make sense for all inplace constructors and allocator extended constructors to do the same. This paper does not propose such considerations.</span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Copy assignment constructor considerations</b></span></h3>
<p class="p6"><span class="s1">First the allocator is possibly modified based on the traits, then the assignment/construction is done as normal. Triviality can only happen if allocator is always equal as any other situation possibly requires a modification in the allocator that can not be checked at compiler time (the resulting allocator in copy construction can not be checked against the POCCA trait) Exception can be thrown by the assignment or the copy construction. The assignment never has to use the possibly modified allocator as the type is expected to follow the allocator traits. The construction doesn't need to use the allocator if allocator is always equal or if the value type is not allocator aware. In all other cases, the copy construction needs to explicitly provide the allocator.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1">With the introduction of allocators, we now have to consider when we can do plain copy construction and when allocator extended construction is needed. <br>
If type is non AA, we can do plain copy construction. <br>
If the type is AA and allocator is always equal, we can also do plain copy construction. Note that, for allocator is always equal case, plain copy construction and allocator copy construction will effectively result in the same allocator. We do not consider the possibility of doing non allocator extended copy construction for the case where the copy assignment allocator propagation matches the resulting allocator at copy construction as that case can't be checked at compile time. In all other cases, copy construction must use allocator extended copy construction to guarantee that the right allocator is used for the value_type.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Move assignment constructor considerations</b></span></h3>
<p class="p6"><span class="s1">First the allocator is possibly modified based on the traits, then the assignment/construction is done as normal. <br>
In addition to usual triviality requirements, triviality can only happen if the allocator is propagated for move assignment(POCMA=true) or if the allocator is always equal. <br>
Possible additional consideration is for basic_optional where the value type is not allocator aware - such a basic_optional does not need to store the allocator and the triviality only depends on the triviality of the value type operations. This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1">The exception specification needs to consider assignment and move construction operations. Move assignment can be done without explicilty using the allocator even for AA types. - an AA type is expected to follow the allocator traits. Move construction can be done directly for AA types if the allocator is always equal or if POCMA=true. Otherwise, the move construction needs to explicitly specify the allocator<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Value assignment constructor considerations</b></span></h3>
<p class="p6"><span class="s1">Value construction must do uses_allocator construction if allocators aren't always equal- the plain copy/move construction may use the wrong allocator. Exception specification : <br>
- for non AA type, the exception specification is equivalent to is_nothrow_assignable_v&lt;Tj, T&gt; &amp; &amp; is_nothrow_constructible_v&lt;Tj, T&gt; <br>
- for AA type, any allocation is potentially throwing. To get a possibly no throw construction, we need to delegate to plain move which can possibly reuse the allocation. Such delegation can only happen if allocators are always equal. <br>
Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to ever allocate and exception specification depends only on the alternatives This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Swap considerations</b></span></h3>
<p class="p6"><span class="s1">First the allocator is possibly modified based on the traits, then the swap/construction is done as normal. Exception specification : To get a possibly no throw construction, we need to delegate to plain move which can possibly reuse the allocation. The delegation can only happen if allocators are always equal or if propagate_on_container_swap == true (for such a type, the resulting allocator in move construction is the required allocator as move construction always propagates the allocator.) This means that swap can only be noexcept if <br>
- value type is is_nothrow_move_constructible and is_nothrow_constructible_v, and <br>
- allocator is always equal or propagate_on_container_swap == true<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s3"><b>basic_optional</b></span><span class="s1"><b> supports non-scoped propagating allocators<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p6"><span class="s1">There are two ways of viewing </span><span class="s3">basic_optional&lt;T&gt;</span><span class="s1"> from allocator propagation perspective : <br>
#1 </span><span class="s3">basic_optional&lt;T&gt;</span><span class="s1"> is like a </span><span class="s3">std::tuple</span><span class="s1">, i.e. it only accepts the allocator at construction so it can forward it to the value_type object. One can use a non-scoped propagation allocator, and when using a scoped propagation allocator </span><span class="s3">basic_optional&lt;T&gt;</span><span class="s1"> will not "consume" an allocator level. An optional object is in a way like a tuple object as it does not use the allocator itself, it only passes it into the value_type object. <br>
#2 </span><span class="s3">basic_optional&lt;T&gt;</span><span class="s1"> is like a </span><span class="s3">std::vector</span><span class="s1">, i.e. it is a container of one or zero elements, and one should use a scoped propagating allocator if one wants the value_type object to use the allocator. In this approach </span><span class="s3">basic_optional&lt;T&gt;</span><span class="s1"> will "consume" an allocator level. Using non-scoped propagating allocators makes little sense in this scenario.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1"></span><br></p>
<p class="p6"><span class="s1">The proposal implements #1 as </span><span class="s3">basic_optional</span><span class="s1"> itself does not allocate any memory so it makes little sense for it to consume an alloctor level.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1">The basic design of an AA optional is straight-forward: Add an allocator to all of its constructors and use that allocator to construct the value object each type the optional is engaged. However, when holding a non-AA type, there is no reason to pay the overhead of storing an allocator.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s3">uses_allocator&lt;basic_optional&lt;T,Alloc&gt;&gt;</span><span class="s1"> corresponds to </span><span class="s3">uses_allocator&lt;T,Alloc&gt;</span><span class="s1">. We believe there is no need to support the AA constructor interface for non-AA types. Generic programming should use uses-allocator construction and </span><span class="s3">std::make_obj_using_allocator</span><span class="s1"> to invoke the correct constructors.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Courier; color: #000000; -webkit-text-stroke: #000000"><span class="s10"><b>Conversions between </b></span><span class="s1"><b>std::optional&lt;T&gt;</b></span><span class="s10"><b> and </b></span><span class="s1"><b>std::basic_optional&lt;T,Alloc&gt;</b></span></h3>
<p class="p6"><span class="s1">Consider: </span><span class="s3"><br>
<br>
basic_optional&lt;T,Alloc&gt; x; <br>
optional&lt;T&gt; y = x; // #1 <br>
basic_optional&lt;T,Alloc&gt; z = y; // #2 <br>
<br>
optional&lt;T&gt; foo_constref(const optional&lt;T&gt;&amp; ); <br>
foo_constref(x); // #3 <br>
<br>
void foo_ref(optional&lt;T&gt;&amp;); <br>
foo_ref(x) // #4 </span><span class="s1"><br>
<br>
In the example above, we do not believe #1,#2, and #3 are ever problematic, but may be useful for code which currently uses </span><span class="s3">optional</span><span class="s1">. However, #4, if allowed, would potentially modify the </span><span class="s3">basic_optional</span><span class="s1"> in a way that does not preserve the allocator requirements. Note that #4 is only problematic if </span><span class="s3">uses_allocator&lt;basic_optional&lt;T,Alloc&gt;&gt; == true</span><span class="s1">.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1">Allowing #4 for cases where </span><span class="s3">uses_allocator&lt;basic_optional&lt;T,Alloc&gt;&gt; == false</span><span class="s1"> would make re-using codebases which traffic in non allocator aware </span><span class="s3">optional</span><span class="s1"> possible when allocator does not matter. However, it adds to the complexity of design. It is also questionable whether there is a need for this conversion. One can have two reasons to use </span><span class="s3">basic_optional</span><span class="s1"> with non allocator aware types: <br>
- writing generic code which serves both allocator and non allocator aware types. Allowing interoperability with </span><span class="s3">optional</span><span class="s1"> for only certain cases seems unhelpful in such a case. <br>
- using </span><span class="s3">basic_optional</span><span class="s1"> for all optional types for simplicity purposes. Allowing interoperability with </span><span class="s3">optional</span><span class="s1"> would be useful in this case. <br>
We propose to not implement conversion #4 until the time it is needed. However, library implementors might want to consider this as a possible extension because it might inform the implementation design they go for.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 13.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 16.0px"><span class="s1"><b></b></span><br></h3>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Allocator used in value_or<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p6"><span class="s1">It is not all that obvious which allocator should be used for the object returned by </span><span class="s3">value_or</span><span class="s1">. Should the decision be left to the type or should it be mandated by the optional ? That is, should the object be constructed by plain copy/move construction or with uses-allocator construction? The proposal leaves the decision to the value_type. If the user cares about the allocator of the returned object, it should be explicitly provided by the user. We may consider providing allocator extended version of </span><span class="s3">value_or</span><span class="s1"> in the future, if this use case proves to be common enough.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Non allocator aware </b></span><span class="s3"><b>basic_optional</b></span><span class="s1"><b> is not an alias for </b></span><span class="s3"><b>optional</b></span><span class="s1"><b><span class="Apple-converted-space"> </span></b></span></h3>
<p class="p6"><span class="s1">An early draft of this proposal suggested using a type alias where a non-AA </span><span class="s3">basic_optional</span><span class="s1"> aliases </span><span class="s3">std::optional</span><span class="s1">, and AA </span><span class="s3">basic_optional</span><span class="s1"> aliases a new unnamed type. However, this causes usability issues. Type deduction in cases like : <br>
</span><span class="s3"><br>
template &lt;typename T&gt; <br>
void foo(basic_optional&lt;T&gt;); <br>
</span><span class="s1"><br>
did not work. The above was equivalent to <br>
</span><span class="s3"><br>
template &lt;typename T, typename Alloc&gt; <br>
void foo(std::conditional&lt;std::uses_allocator &lt;T, Alloc&lt;&gt;&gt;::value, <br>
<i>__basic_optional</i>&lt;T&gt;, <br>
std::optional&lt;T&gt;&gt;:type); <br>
</span><span class="s1"><br>
and using the nested </span><span class="s3">type</span><span class="s1"> of the </span><span class="s3">std::conditional</span><span class="s1"> as the function template parameter made for an undeduced context.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Make facilities are not provided<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p6"><span class="s1">Make facilities have been deemed unnecessary with the availability of CTAD. The current version of the paper doesn't propose </span><span class="s3">std::make_basic_optional</span><span class="s1"> nor </span><span class="s3">std::pmr::make_optional</span><span class="s1">. Previous version suggested those be included, but with implementation experience, we found a complexity in allowing the allocator type to be both specifiable and defaulted in non allocator extended version of the make facility. We deem such complexity unnecessary with the advent of the CTAD feature.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Allocator aware types are assumed to be move enabled<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p6"><span class="s3">basic_optional</span><span class="s1"> uses explicit allocator construction except in cases where invoking a direct </span><span class="s3">value_type</span><span class="s1"> operation allows for move operations to remain noexcept. This is the case in move constructor for all allocators, and in move assignment for allocators that have </span><span class="s3">propagate_on_container_move_assignment==true</span><span class="s1">. If the </span><span class="s3">value_type</span><span class="s1"> is allocator aware, but does not support move semantics (i.e. moves deteriorate to copies), it is possible that the allocator of the </span><span class="s3">value_type</span><span class="s1"> object will get out of sync with the allocator of the </span><span class="s3">basic_optional</span><span class="s1">. We do not expect such types to exist.<span class="Apple-converted-space"> </span></span></p>
<p class="p22"><span class="s1"></span><br></p>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Proposed wording</b></span></h2>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 23.0px"><span class="s1"><b></b></span><br></h2>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 14.0px Times; -webkit-text-stroke: #000000"><span class="s11"><b>Modify </b></span><span class="s12"><b>22.5.2</b></span><span class="s1"><b> Header &lt;optional&gt; synopsis</b></span></h2>
<p class="p25"><span class="s1">namespace</span><span class="s13"> std </span><span class="s14">{</span></p>
<p class="p26"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/optional#optional"><span class="s16"><i>[optional.optional]</i></span></a><i>, class template </i></span><span class="s17">optional</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">class</span><span class="s1"> optional; <span class="Apple-converted-space">                                                    </span></span><span class="s20"><i>// partially freestanding</i></span></p>
<p class="p28"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s12"><i>[optional.basic.optional]</i></span><span class="s1"><i>, class template basic_</i></span><span class="s17">optional</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> T, class Allocator</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s21"><span class="Apple-converted-space">    </span></span><span class="s22">class</span><span class="s21"> basic_optional; <span class="Apple-converted-space">       </span></span><span class="s1"> <span class="Apple-converted-space">                                            </span></span><span class="s20"><i>// partially freestanding</i></span></p>
<p class="p30"><span class="s1">…</span></p>
<p class="p26"><span class="s15"><span class="Apple-converted-space"> </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/optional#relops"><span class="s16"><i>[optional.relops]</i></span></a><i>, relational operators</i></span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">==</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">!=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p31"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s13"> T, <a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable_with"><span class="s23">three_way_comparable_with</span></a></span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;</span><span class="s13"> U</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> compare_three_way_result_t</span><span class="s18">&lt;</span><span class="s1">T, U</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s19">operator</span><span class="s18">&lt;=&gt;</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&amp;</span><span class="s1">, </span><span class="s19">const</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s1">;<span class="Apple-converted-space"> </span></span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class AllocatorT, class U, class AllocatorU&gt;</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">bool</span><span class="s1"> </span><span class="s19">operator</span><span class="s18">==</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s18">&amp;</span><span class="s1">, </span><span class="s19">const</span><span class="s1"> basic_optional&lt;U, AllocatorU&gt;</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class AllocatorT, class U, class AllocatorU&gt;</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">bool</span><span class="s1"> </span><span class="s19">operator</span><span class="s18">!=</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s18">&amp;</span><span class="s1">, </span><span class="s19">const</span><span class="s1"> basic_optional&lt;U, AllocatorU&gt;</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class AllocatorT, class U, class AllocatorU&gt;</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">bool</span><span class="s1"> </span><span class="s19">operator</span><span class="s18">&lt;</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s18">&amp;</span><span class="s1">, </span><span class="s19">const</span><span class="s1"> basic_optional&lt;U, AllocatorU&gt;</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class AllocatorT, class U, class AllocatorU&gt;</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">bool</span><span class="s1"> </span><span class="s19">operator</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s18">&amp;</span><span class="s1">, </span><span class="s19">const</span><span class="s1"> basic_optional&lt;U, AllocatorU&gt;</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class AllocatorT, class U, class AllocatorU&gt;</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">bool</span><span class="s1"> </span><span class="s19">operator</span><span class="s18">&lt;=</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s18">&amp;</span><span class="s1">, </span><span class="s19">const</span><span class="s1"> basic_optional&lt;U, AllocatorU&gt;</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class AllocatorT, class U, class AllocatorU&gt;</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">bool</span><span class="s1"> </span><span class="s19">operator</span><span class="s18">&gt;=</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s18">&amp;</span><span class="s1">, </span><span class="s19">const</span><span class="s1"> basic_optional&lt;U, AllocatorU&gt;</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p33"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s13"> T, <a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable_with"><span class="s23">three_way_comparable_with</span></a></span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;</span><span class="s13"> U</span><span class="s18">&gt;</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> compare_three_way_result_t</span><span class="s18">&lt;</span><span class="s1">T, U</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s21"><span class="Apple-converted-space">      </span></span><span class="s22">operator</span><span class="s24">&lt;=&gt;</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s24">&amp;</span><span class="s21">, </span><span class="s22">const</span><span class="s21"> basic_optional&lt;U, AllocatorU&gt;</span><span class="s24">&amp;</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p34"><span class="s1"></span><br></p>
<p class="p26"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/optional#nullops"><span class="s16"><i>[optional.nullops]</i></span></a><i>, comparison with </i></span><span class="s17">nullopt</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">==</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13">, nullopt_t</span><span class="s14">)</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> strong_ordering </span><span class="s19">operator</span><span class="s18">&lt;=&gt;</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&amp;</span><span class="s1">, nullopt_t</span><span class="s14">)</span><span class="s1"> </span><span class="s19">noexcept</span><span class="s1">;</span></p>
<p class="p35"><span class="s26"><span class="Apple-converted-space">  </span></span><span class="s27">template</span><span class="s18">&lt;</span><span class="s27">class</span><span class="s26"> T, class Allocator</span><span class="s18">&gt;</span><span class="s26"> </span><span class="s27">constexpr</span><span class="s26"> </span><span class="s27">bool</span><span class="s26"> </span><span class="s27">operator</span><span class="s18">==</span><span class="s14">(</span><span class="s27">const</span><span class="s26"> basic_optional</span><span class="s18">&lt;</span><span class="s26">T, Allocator</span><span class="s18">&gt;&amp;</span><span class="s26">, nullopt_t</span><span class="s14">)</span><span class="s26"> </span><span class="s27">noexcept</span><span class="s26">;</span></p>
<p class="p36"><span class="s26"><span class="Apple-converted-space">  </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s26"> T, </span><span class="s1">class Allocator</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s21"><span class="Apple-converted-space">    </span></span><span class="s22">constexpr</span><span class="s21"> strong_ordering </span><span class="s22">operator</span><span class="s24">&lt;=&gt;</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_optional</span><span class="s24">&lt;</span><span class="s21">T, </span><span class="s28">Allocator</span><span class="s24">&gt;&amp;</span><span class="s21">, nullopt_t</span><span class="s25">)</span><span class="s21"> </span><span class="s22">noexcept</span><span class="s21">;</span></p>
<p class="p37"><span class="s1"></span><br></p>
<p class="p38"><span class="s29"><i>// </i><a href="https://eel.is/c++draft/optional#comp.with.t"><span class="s12"><i>[optional.comp.with.t]</i></span></a><i>, comparison with </i></span><span class="s30">T</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">==</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">==</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">!=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">!=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span></p>
<p class="p31"><span class="s13"><span class="Apple-converted-space">      </span></span><span class="s19">requires</span><span class="s13"> </span><span class="s14">(</span><span class="s18">!<a href="https://eel.is/c++draft/optional#concept:is-derived-from-optional"><span class="s12"><i>is-derived-from-optional</i></span></a>&lt;</span><span class="s13">U</span><span class="s18">&gt;</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13"> <a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable_with"><span class="s23">three_way_comparable_with</span></a></span><span class="s18">&lt;</span><span class="s13">T, U</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> compare_three_way_result_t</span><span class="s18">&lt;</span><span class="s1">T, U</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s19">operator</span><span class="s18">&lt;=&gt;</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&amp;</span><span class="s1">, </span><span class="s19">const</span><span class="s1"> U</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class AllocatorT, class U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">==</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class U, class AllocatorU</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">==</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const basic_optional&lt;U,AllocatorU&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class AllocatorT, class U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">!=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class U, class AllocatorU</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">!=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const basic_optional&lt;U,AllocatorU&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class AllocatorT, class U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class U, class AllocatorU</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const basic_optional&lt;U,AllocatorU&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class AllocatorT, class U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class U, class AllocatorU</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const basic_optional&lt;U,AllocatorU&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class AllocatorT, class U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class U, class AllocatorU</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const basic_optional&lt;U,AllocatorU&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class AllocatorT, class U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class U, class AllocatorU</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13">, </span><span class="s1">const basic_optional&lt;U,AllocatorU&gt;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class T, class AllocatorT, class U</span><span class="s18">&gt;</span></p>
<p class="p33"><span class="s13"><span class="Apple-converted-space">      </span></span><span class="s19">requires</span><span class="s13"> </span><span class="s14">(</span><span class="s18">!<a href="https://eel.is/c++draft/optional#concept:is-derived-from-optional"><span class="s12"><i>is-derived-from-optional</i></span></a>&lt;</span><span class="s13">U</span><span class="s18">&gt;</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13"> <a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable_with"><span class="s23">three_way_comparable_with</span></a></span><span class="s18">&lt;</span><span class="s13">T, U</span><span class="s18">&gt;</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> compare_three_way_result_t</span><span class="s18">&lt;</span><span class="s1">T, U</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s21"><span class="Apple-converted-space">      </span></span><span class="s22">operator</span><span class="s24">&lt;=&gt;</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_optional&lt;T, AllocatorT&gt;</span><span class="s24">&amp;</span><span class="s21">, </span><span class="s22">const</span><span class="s21"> U</span><span class="s24">&amp;</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p34"><span class="s1"></span><br></p>
<p class="p26"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/optional#specalg"><span class="s16"><i>[optional.specalg]</i></span></a><i>, specialized algorithms</i></span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">void</span><span class="s1"> swap</span><span class="s14">(</span><span class="s1">optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&amp;</span><span class="s1">, optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s1"> </span><span class="s19">noexcept</span><span class="s14">(</span><span class="s1"><i>see below</i></span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p34"><span class="s1"></span><br></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> T, class Allocator</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s21"><span class="Apple-converted-space">    </span></span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">void</span><span class="s21"> swap</span><span class="s25">(</span><span class="s21">basic_optional&lt;T, Allocator&gt;</span><span class="s24">&amp;</span><span class="s21">, basic_optional&lt;T, Allocator&gt;</span><span class="s24">&amp;</span><span class="s25">)</span><span class="s21"> </span><span class="s22">noexcept</span><span class="s25">(</span><span class="s21"><i>see below</i></span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p34"><span class="s1"></span><br></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1"><i>see below</i></span><span class="s18">&gt;</span><span class="s1"> make_optional</span><span class="s14">(</span><span class="s1">T</span><span class="s18">&amp;&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s18">...</span><span class="s13"> Args</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> make_optional</span><span class="s14">(</span><span class="s1">Args</span><span class="s18">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U, </span><span class="s1">class</span><span class="s18">...</span><span class="s13"> Args</span><span class="s18">&gt;</span></p>
<p class="p27"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> make_optional</span><span class="s14">(</span><span class="s1">initializer_list</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s1"> il, Args</span><span class="s18">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p34"><span class="s1"></span><br></p>
<p class="p26"><span class="s15"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i><a href="https://eel.is/c++draft/optional#hash"><span class="s16"><i>[optional.hash]</i></span></a><i>, hash support</i></span></p>
<p class="p25"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">struct</span><span class="s13"> hash;</span></p>
<p class="p27"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> T</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">struct</span><span class="s1"> hash</span><span class="s18">&lt;</span><span class="s1">optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&gt;</span><span class="s1">;</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> T,<span class="Apple-converted-space"> </span></span><span class="s26"> class Allocator</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">struct</span><span class="s1"> hash</span><span class="s18">&lt;</span><span class="s1">basic_optional&lt;T, Allocator&gt;</span><span class="s18">&gt;</span><span class="s1">;</span></p>
<p class="p39"><span class="s1"></span><br></p>
<p class="p40"><span class="s1"><span class="Apple-converted-space">  </span>namespace pmr {</span></p>
<p class="p41"><span class="s26"><span class="Apple-converted-space">            </span></span><span class="s1">template</span><span class="s31">&lt;</span><span class="s1">class</span><span class="s31"> T&gt;</span></p>
<p class="p40"><span class="s1"><span class="Apple-converted-space">    <span class="Apple-tab-span">	</span></span>using optional = basic_optional&lt;T, polymorphic_allocator&lt;&gt;&gt;;</span></p>
<p class="p42"><span class="s21"><span class="Apple-converted-space">  </span>}<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1">}</span></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 14.0px Times; -webkit-text-stroke: #000000"><span class="s1"><b>Add new section after 22.5.3</b></span></h3>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 14.0px Times; -webkit-text-stroke: #000000"><span class="s1"><b>Class template basic_optional</b></span><span class="s12"><b> [basic.optional]</b></span></h3>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06"><span class="s1"><b>22.5.x.1</b></span><span class="s13"><b> General</b></span><span class="s1"><b> [basic.optional.general]</b></span></h4>
<p class="p46"><span class="s1">namespace</span><span class="s13"> std </span><span class="s14">{</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> T, class Allocator = <i>see below</i></span><span class="s18">&gt;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s19">class</span><span class="s1"> basic_optional </span><span class="s14">{</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">public</span><span class="s18">:</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">using</span><span class="s1"> value_type </span><span class="s18">=</span><span class="s1"> T;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">using</span><span class="s1"> allocator_type </span><span class="s18">=</span><span class="s1"> Allocator;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p49"><span class="s15"><span class="Apple-converted-space">    </span></span><span class="s29"><i>// </i></span><span class="s1"><i>[basic.optional.ctor]</i></span><span class="s29"><i>, constructors</i></span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> basic_optional</span><span class="s14">()</span><span class="s1"> </span><span class="s19">noexcept</span><span class="s1">;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> basic_optional</span><span class="s14">(</span><span class="s1">nullopt_t</span><span class="s14">)</span><span class="s1"> </span><span class="s19">noexcept</span><span class="s1">;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> basic_optional</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> optional</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> basic_optional</span><span class="s14">(</span><span class="s1">optional</span><span class="s18">&amp;&amp;</span><span class="s14">)</span><span class="s1"> </span><span class="s19">noexcept</span><span class="s14">(</span><span class="s1"><i>see below</i></span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s18">...</span><span class="s13"> Args</span><span class="s18">&gt;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s1"> basic_optional</span><span class="s14">(</span><span class="s1">in_place_t, Args</span><span class="s18">&amp;&amp;...</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U, </span><span class="s1">class</span><span class="s18">...</span><span class="s13"> Args</span><span class="s18">&gt;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s1"> basic_optional</span><span class="s14">(</span><span class="s1">in_place_t, initializer_list</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s1">, Args</span><span class="s18">&amp;&amp;...</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U </span><span class="s18">=</span><span class="s13"> T</span><span class="s18">&gt;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s14">(</span><span class="s1"><i>see below</i></span><span class="s14">)</span><span class="s1"> basic_optional</span><span class="s14">(</span><span class="s1">U</span><span class="s18">&amp;&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">   </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U </span><span class="s33">, </span><span class="s1">class</span><span class="s33"> AllocatorU&gt;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s14">(</span><span class="s1"><i>see below</i></span><span class="s14">)</span><span class="s1"> basic_optional</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> basic_optional </span><span class="s18">&lt;</span><span class="s1">U, </span><span class="s34">AllocatorU</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p51"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s19">template</span><span class="s35">&lt;</span><span class="s19">class</span><span class="s13"> U</span><span class="s32"> </span><span class="s1">, </span><span class="s27">class</span><span class="s1"> AllocatorU</span><span class="s35">&gt;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s14">(</span><span class="s1"><i>see below</i></span><span class="s14">)</span><span class="s1"> basic_optional</span><span class="s14">(</span><span class="s36">basic_optional</span><span class="s18">&lt;</span><span class="s1">U, AllocatorU</span><span class="s18">&gt;&amp;&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s14">(</span><span class="s1"><i>see below</i></span><span class="s14">)</span><span class="s1"> basic_optional</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> optional </span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s14">(</span><span class="s1"><i>see below</i></span><span class="s14">)</span><span class="s1"> basic_optional</span><span class="s14">(</span><span class="s36">optional</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p52"><span class="s1"><i>// allocator-extended constructors</i></span></p>
<p class="p53"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s32"> basic_optional</span><span class="s14">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a</span><span class="s14">)</span><span class="s32">;</span></p>
<p class="p53"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s32"> basic_optional</span><span class="s14">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a, </span><span class="s32">nullopt_t</span><span class="s14">)</span><span class="s32">;</span></p>
<p class="p54"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s13"> basic_optional</span><span class="s14">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a, </span><span class="s19">const</span><span class="s13"> optional</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p54"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s13"> basic_optional</span><span class="s14">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a, </span><span class="s13">optional</span><span class="s18">&amp;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s18">...</span><span class="s13"> Args</span><span class="s18">&gt;</span></p>
<p class="p54"><span class="s13"><span class="Apple-converted-space">      </span></span><span class="s19">constexpr</span><span class="s13"> basic_optional</span><span class="s14">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a, </span><span class="s13">in_place_t, Args</span><span class="s18">&amp;&amp;...</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U, </span><span class="s1">class</span><span class="s18">...</span><span class="s13"> Args</span><span class="s18">&gt;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s19">constexpr</span><span class="s1"> basic_optional</span><span class="s14">(</span><span class="s13">allocator_arg_t, const allocator_type&amp; a, </span><span class="s1">in_place_t, initializer_list</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s1">, Args</span><span class="s18">&amp;&amp;...</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U </span><span class="s18">=</span><span class="s13"> T</span><span class="s18">&gt;</span></p>
<p class="p54"><span class="s13"><span class="Apple-converted-space">      </span></span><span class="s19">constexpr</span><span class="s13"> basic_optional</span><span class="s14">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a, </span><span class="s13">U</span><span class="s18">&amp;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">   </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U </span><span class="s33">, </span><span class="s1">class</span><span class="s33"> AllocatorU&gt;</span></p>
<p class="p54"><span class="s32"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s32"> basic_optional</span><span class="s37">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a, </span><span class="s27">const</span><span class="s32"> basic_optional </span><span class="s33">&lt;</span><span class="s32">U, </span><span class="s33">AllocatorU&gt;&amp;</span><span class="s37">)</span><span class="s32">;</span></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U </span><span class="s33">, </span><span class="s1">class</span><span class="s33"> AllocatorU&gt;</span></p>
<p class="p55"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s1"> basic_optional</span><span class="s37">(</span><span class="s32">allocator_arg_t, const allocator_type&amp; a, </span><span class="s1">basic_optional</span><span class="s33">&lt;</span><span class="s1">U, AllocatorU</span><span class="s33">&gt;&amp;&amp;</span><span class="s37">)</span><span class="s1">;</span></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U</span><span class="s33">&gt;</span></p>
<p class="p54"><span class="s32"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s32"> basic_optional</span><span class="s37">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a, </span><span class="s27">const</span><span class="s32"> optional </span><span class="s33">&lt;</span><span class="s32">U</span><span class="s33">&gt;&amp;</span><span class="s37">)</span><span class="s32">;</span></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U</span><span class="s33">&gt;</span></p>
<p class="p54"><span class="s32"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s32"> basic_optional</span><span class="s37">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a, </span><span class="s32">optional</span><span class="s33">&lt;</span><span class="s32">U</span><span class="s33">&gt;&amp;&amp;</span><span class="s37">)</span><span class="s32">;</span></p>
<p class="p56"><span class="s1"></span><br></p>
<p class="p49"><span class="s15"><span class="Apple-converted-space">    </span></span><span class="s29"><i>// </i></span><span class="s1"><i>[basic.optional.dtor]</i></span><span class="s29"><i>, destructor</i></span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s18">~</span><span class="s1">optional</span><span class="s14">()</span><span class="s1">;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p49"><span class="s15"><span class="Apple-converted-space">    </span></span><span class="s29"><i>// </i></span><span class="s1"><i>[basic.optional.assign]</i></span><span class="s29"><i>, assignment</i></span></p>
<p class="p57"><span class="s26"><span class="Apple-converted-space">    </span></span><span class="s27">constexpr</span><span class="s26"> basic_optional</span><span class="s18">&amp;</span><span class="s26"> </span><span class="s27">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s26">nullopt_t</span><span class="s14">)</span><span class="s26"> </span><span class="s27">noexcept</span><span class="s26">;</span></p>
<p class="p55"><span class="s26"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s26"> </span><span class="s1">basic_optional</span><span class="s18">&amp;</span><span class="s26"> </span><span class="s19">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s19">const</span><span class="s26"> </span><span class="s1">basic_optional</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s26">;</span></p>
<p class="p55"><span class="s26"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s26"> </span><span class="s1">basic_optional</span><span class="s18">&amp;</span><span class="s26"> </span><span class="s19">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s1">basic_optional</span><span class="s18">&amp;&amp;</span><span class="s14">)</span><span class="s26"> </span><span class="s19">noexcept</span><span class="s14">(</span><span class="s26"><i>see below</i></span><span class="s14">)</span><span class="s26">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U </span><span class="s18">=</span><span class="s13"> T</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> basic_optional</span><span class="s18">&amp;</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s13">U</span><span class="s18">&amp;&amp;</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> U, </span><span class="s38">class </span><span class="s1">AllocatorU</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> basic_optional</span><span class="s18">&amp;</span><span class="s1"> </span><span class="s19">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> basic_optional </span><span class="s18">&lt;</span><span class="s1">U, AllocatorU</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> U, </span><span class="s38">class </span><span class="s26">AllocatorU</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> basic_optional</span><span class="s18">&amp;</span><span class="s1"> </span><span class="s19">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s36">basic_optional </span><span class="s18">&lt;</span><span class="s1">U, AllocatorU</span><span class="s18">&gt;&amp;&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> U</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> basic_optional</span><span class="s18">&amp;</span><span class="s1"> </span><span class="s19">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> optional </span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p57"><span class="s26"><span class="Apple-converted-space">    </span></span><span class="s27">template</span><span class="s18">&lt;</span><span class="s27">class</span><span class="s26"> U</span><span class="s18">&gt;</span><span class="s26"> </span><span class="s27">constexpr</span><span class="s26"> basic_optional</span><span class="s18">&amp;</span><span class="s26"> </span><span class="s27">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s36">optional </span><span class="s18">&lt;</span><span class="s26">U</span><span class="s18">&gt;&amp;&amp;</span><span class="s14">)</span><span class="s26">;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s18">...</span><span class="s1"> Args</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> T</span><span class="s18">&amp;</span><span class="s1"> emplace</span><span class="s14">(</span><span class="s1">Args</span><span class="s18">&amp;&amp;...</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> U, </span><span class="s19">class</span><span class="s18">...</span><span class="s1"> Args</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> T</span><span class="s18">&amp;</span><span class="s1"> emplace</span><span class="s14">(</span><span class="s1">initializer_list</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s1">, Args</span><span class="s18">&amp;&amp;...</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p49"><span class="s15"><span class="Apple-converted-space">    </span></span><span class="s29"><i>// </i></span><span class="s1"><i>[basic.optional.swap]</i></span><span class="s29"><i>, swap</i></span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">void</span><span class="s1"> swap</span><span class="s14">(</span><span class="s26">basic_optional</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s1"> </span><span class="s19">noexcept</span><span class="s14">(</span><span class="s1"><i>see below</i></span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p58"><span class="s1"></span><br></p>
<p class="p59"><span class="s39"><i><span class="Apple-converted-space">   </span>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s40"><i>[</i></span></a></span><span class="s1"><i>basic.optional.al]</i></span><span class="s39"><i>, allocator</i></span></p>
<p class="p40"><span class="s1"><span class="Apple-converted-space">    </span>allocator_type get_allocator</span><span class="s41">()</span><span class="s1"> </span><span class="s42">const</span><span class="s1">;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p49"><span class="s15"><span class="Apple-converted-space">    </span></span><span class="s29"><i>// </i></span><span class="s1"><i>[basic.optional.observe]</i></span><span class="s29"><i>, observers</i></span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> T</span><span class="s18">*</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">-&gt;</span><span class="s14">()</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> T</span><span class="s18">*</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">-&gt;</span><span class="s14">()</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">*</span><span class="s14">()</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">*</span><span class="s14">()</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> T</span><span class="s18">&amp;&amp;</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">*</span><span class="s14">()</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;&amp;</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">*</span><span class="s14">()</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">explicit</span><span class="s13"> </span><span class="s1">operator</span><span class="s13"> </span><span class="s1">bool</span><span class="s14">()</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> has_value</span><span class="s14">()</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">const</span><span class="s1"> T</span><span class="s18">&amp;</span><span class="s1"> value</span><span class="s14">()</span><span class="s1"> </span><span class="s19">const</span><span class="s1"> </span><span class="s18">&amp;</span><span class="s1">; <span class="Apple-converted-space">                                </span></span><span class="s20"><i>// freestanding-deleted</i></span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> T</span><span class="s18">&amp;</span><span class="s1"> value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">&amp;</span><span class="s1">; <span class="Apple-converted-space">                                            </span></span><span class="s20"><i>// freestanding-deleted</i></span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> T</span><span class="s18">&amp;&amp;</span><span class="s1"> value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">&amp;&amp;</span><span class="s1">; <span class="Apple-converted-space">                                          </span></span><span class="s20"><i>// freestanding-deleted</i></span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">const</span><span class="s1"> T</span><span class="s18">&amp;&amp;</span><span class="s1"> value</span><span class="s14">()</span><span class="s1"> </span><span class="s19">const</span><span class="s1"> </span><span class="s18">&amp;&amp;</span><span class="s1">; <span class="Apple-converted-space">                              </span></span><span class="s20"><i>// freestanding-deleted</i></span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> T value_or</span><span class="s14">(</span><span class="s13">U</span><span class="s18">&amp;&amp;</span><span class="s14">)</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13">;</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> T value_or</span><span class="s14">(</span><span class="s13">U</span><span class="s18">&amp;&amp;</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13">;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p60"><span class="s29"><i>// </i></span><span class="s1"><i>[basic_optional.monadic]</i></span><span class="s29"><i>, monadic operations</i></span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> and_then</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> and_then</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> and_then</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> and_then</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> transform</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> transform</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> transform</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13">;</span></p>
<p class="p32"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> transform</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13">;</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> F</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> optional or_else</span><span class="s14">(</span><span class="s1">F</span><span class="s18">&amp;&amp;</span><span class="s1"> f</span><span class="s14">)</span><span class="s1"> </span><span class="s18">&amp;&amp;</span><span class="s1">;</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> F</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> optional or_else</span><span class="s14">(</span><span class="s1">F</span><span class="s18">&amp;&amp;</span><span class="s1"> f</span><span class="s14">)</span><span class="s1"> </span><span class="s19">const</span><span class="s1"> </span><span class="s18">&amp;</span><span class="s1">;</span></p>
<p class="p56"><span class="s1"></span><br></p>
<p class="p49"><span class="s15"><span class="Apple-converted-space">    </span></span><span class="s29"><i>// </i></span><span class="s1"><i>[basic.optional.mod]</i></span><span class="s29"><i>, modifiers</i></span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">void</span><span class="s13"> reset</span><span class="s14">()</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">  </span></span><span class="s1">private</span><span class="s18">:</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span>T </span><span class="s18">*</span><span class="s1">val; <span class="Apple-converted-space">        </span></span><span class="s20"><i>// exposition only</i></span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">    </span>Allocator_type </span><span class="s18">*</span><span class="s1">alloc; <span class="Apple-converted-space">        </span></span><span class="s20"><i>// exposition only</i></span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s14">}</span><span class="s1">;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p61"><span class="s1">}</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p62"><span class="s1">Any instance of basic_optional</span><span class="s18">&lt;</span><span class="s1">T, Allocator</span><span class="s18">&gt;</span><span class="s1"> at any given time either contains a value or does not contain a value<a href="https://eel.is/c++draft/optional#optional.general-1.sentence-1"><span class="s43">.</span></a> When an instance of </span><span class="s44">basic_optional</span><span class="s45">&lt;</span><span class="s44">T, Allocator</span><span class="s45">&gt;</span><span class="s1"> <a href="https://eel.is/c++draft/optional#def:contains_a_value,optional"><span class="s43"><i>contains a value</i></span></a>, it means that an object of type T, referred to as the </span><span class="s46">basic_optional</span><span class="s1"> object's <a href="https://eel.is/c++draft/optional#def:contained_value,optional"><span class="s43"><i>contained value</i></span></a>, is allocated within the storage of the basic_optional object. Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value<a href="https://eel.is/c++draft/optional#optional.general-1.sentence-3"><span class="s43">.</span></a> When an object of type </span><span class="s44">basic_optional</span><span class="s45">&lt;</span><span class="s44">T, Allocator</span><span class="s45">&gt;</span><span class="s1"> is contextually converted to </span><span class="s19">bool</span><span class="s1">, the conversion returns </span><span class="s47">true</span><span class="s1"> if the object contains a value; otherwise the conversion returns </span><span class="s47">false</span><span class="s1">.</span></p>
<p class="p63"><span class="s1"></span><br></p>
<p class="p62"><span class="s1">When a </span><span class="s44">basic_optional</span><span class="s45">&lt;</span><span class="s44">T, Allocator</span><span class="s45">&gt;</span><span class="s44"> </span><span class="s1"> object contains a value, member val points to the contained value.</span></p>
<p class="p63"><span class="s1"></span><br></p>
<p class="p62"><span class="s1">T shall be a type other than <i>cv</i> in_place_t or <i>cv</i> nullopt_t that meets the <i>Cpp17Destructible</i> requirements (Table <a href="https://eel.is/c++draft/utility.arg.requirements#tab:cpp17.destructible"><span class="s16">35</span></a>)<a href="https://eel.is/c++draft/optional#optional.general-3.sentence-1"><span class="s43">.</span></a></span></p>
<p class="p63"><span class="s1"></span><br></p>
<p class="p64"><span class="s1">Template argument Allocator shall satisfy the <i>Cpp17Allocator </i>requirements (</span><span class="s48">16.4.4.6.1</span><span class="s1">). A an instance of Allocator is maintained by the basic_optional object during the lifetime of the object or until the allocator is replaced. The allocator instance is set at basic_optional object creation time and may be replaced only via assignment or swap as specified below. The allocator instance is used to pass to uses-allocator construction of a value object as specified below. <span class="Apple-converted-space"> </span></span></p>
<p class="p65"><span class="s1"></span><br></p>
<p class="p64"><span class="s1">Default template argument for the template parameter Allocator is T::allocator_type if </span><span class="s26">T::allocator_type designates a type, and std::allocator&lt;T&gt; otherwise.</span></p>
<p class="p66"><span class="s1"></span><br></p>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06"><span class="s44"><b>22.5.x.2</b></span><span class="s49"><b> Constructors</b></span><span class="s44"><b> [basic.optional.ctor]</b></span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000; background-color: #21ff06"><span class="s1">The exposition-only variable template <i>converts-from-any-cvref</i> is used by some constructors for basic_optional.</span></h4>
<p class="p68"><span class="s1"></span><br></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> W</span><span class="s18">&gt;</span></p>
<p class="p47"><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">bool</span><span class="s1"> <i>converts-from-any-cvref</i> </span><span class="s18">=</span><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20"><i>// exposition only</i></span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">  </span>disjunction_v</span><span class="s18">&lt;</span><span class="s1">is_constructible</span><span class="s18">&lt;</span><span class="s1">T, W</span><span class="s18">&amp;&gt;</span><span class="s1">, is_convertible</span><span class="s18">&lt;</span><span class="s1">W</span><span class="s18">&amp;</span><span class="s1">, T</span><span class="s18">&gt;</span><span class="s1">,</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">                </span>is_constructible</span><span class="s18">&lt;</span><span class="s1">T, W</span><span class="s18">&gt;</span><span class="s1">, is_convertible</span><span class="s18">&lt;</span><span class="s1">W, T</span><span class="s18">&gt;</span><span class="s1">,</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">                </span>is_constructible</span><span class="s18">&lt;</span><span class="s1">T, </span><span class="s19">const</span><span class="s1"> W</span><span class="s18">&amp;&gt;</span><span class="s1">, is_convertible</span><span class="s18">&lt;</span><span class="s19">const</span><span class="s1"> W</span><span class="s18">&amp;</span><span class="s1">, T</span><span class="s18">&gt;</span><span class="s1">,</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">                </span>is_constructible</span><span class="s18">&lt;</span><span class="s1">T, </span><span class="s19">const</span><span class="s1"> W</span><span class="s18">&gt;</span><span class="s1">, is_convertible</span><span class="s18">&lt;</span><span class="s19">const</span><span class="s1"> W, T</span><span class="s18">&gt;&gt;</span><span class="s1">;</span></p>
<p class="p68"><span class="s1"></span><br></p>
<p class="p47"><span class="s19">constexpr</span><span class="s1"> basic_optional</span><span class="s14">()</span><span class="s1"> </span><span class="s19">noexcept</span><span class="s1">;</span></p>
<p class="p47"><span class="s19">constexpr</span><span class="s1"> basic_optional</span><span class="s14">(</span><span class="s1">nullopt_t</span><span class="s14">)</span><span class="s1"> </span><span class="s19">noexcept</span><span class="s1">;</span></p>
<p class="p67"><span class="s1"><i>Postconditions</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> does not contain a value<a href="https://eel.is/c++draft/optional#ctor-2.sentence-1"><span class="s43">.</span></a>.</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: alloc is default initialised. No contained value is initialized<a href="https://eel.is/c++draft/optional#ctor-3.sentence-1"><span class="s43">.</span></a> If Allocator’s default construct is a constexpr construct these constructors are constexpr constructors (<a href="https://eel.is/c++draft/dcl.constexpr"><span class="s16">[dcl.constexpr]</span></a>)<a href="https://eel.is/c++draft/optional#ctor-3.sentence-2"><span class="s43">.</span></a></span></p>
<p class="p68"><span class="s1"></span><br></p>
<p class="p47"><span class="s19">constexpr</span><span class="s1"> basic_optional</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> basic_optional</span><span class="s18">&amp;</span><span class="s1"> rhs</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p64"><span class="s43"><i>Effects</i>: </span><span class="s1">If allocator_traits&lt;Allocator&gt;::is_always_equal::value is true, alloc is default-initialized. Otherwise, alloc is direct-initialized with an allocator_traits&lt;Allocator&gt;::select_on_container_copy_construction(rhs.get_allocator()). </span><span class="s43">If rhs contains a value, direct-non-list-initializes the contained value with </span><span class="s45">*</span><span class="s43">rhs</span></p>
<p class="p67"><span class="s1"><i>Postconditions</i>: rhs</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">==</span><span class="s1"> </span><span class="s19">this</span><span class="s18">-&gt;</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p67"><span class="s1"><i>Throws</i>: Any exception thrown by the selected constructor of T.</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: This constructor is defined as deleted unless is_copy_constructible_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1">. This constructor is trivial if :</span></p>
<p class="p67"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- </span><span class="s44">is_trivially_copy_constructible_v</span><span class="s45">&lt;</span><span class="s44">T</span><span class="s45">&gt;</span><span class="s44"> is </span><span class="s50">true</span><span class="s44">,<span class="Apple-converted-space"> </span></span></p>
<p class="p64"><span class="s43"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- </span><span class="s1">allocator_traits&lt;Allocator&gt;::is_always_equal::value is true, and</span></p>
<p class="p64"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_copy_constructible_v&lt;Allocator&gt; is true</span></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p69"><span class="s1"><a href="https://eel.is/c++draft/optional#lib:optional,constructor__">🔗<span class="s51"></span></a></span></p>
<p class="p55"><span class="s19">constexpr</span><span class="s26"> </span><span class="s1">basic_optional</span><span class="s14">(</span><span class="s26">optional</span><span class="s18">&amp;&amp;</span><span class="s26"> rhs</span><span class="s14">)</span><span class="s26"> </span><span class="s1">basic_optional</span><span class="s14">(</span><span class="s26"><i>see below</i></span><span class="s14">)</span><span class="s26">;</span></p>
<p class="p67"><span class="s1"><i>Constraints</i>: is_move_constructible_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span></p>
<p class="p67"><span class="s1"><i>Effects</i>:</span><span class="s43"> alloc is direct-initialized with w.get_allocator().<span class="Apple-converted-space"> </span></span><span class="s1"> If rhs contains a value, direct-non-list-initializes the contained value with std</span><span class="s18"> :: </span><span class="s1">move</span><span class="s14">(</span><span class="s18">*</span><span class="s1">rhs</span><span class="s14">)<a href="https://eel.is/c++draft/optional#ctor-9.sentence-1"><span class="s49">.</span></a></span><span class="s1"> rhs</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> is unchanged</span></p>
<p class="p67"><span class="s1"><i>Postconditions</i>: rhs</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">==</span><span class="s1"> </span><span class="s19">this</span><span class="s18">-&gt;</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p67"><span class="s1"><i>Throws</i>: Any exception thrown by the selected constructor of T.</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: The exception specification is equivalent to is_nothrow_move_constructible_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1">. </span><span class="s44">This constructor is trivial if :</span></p>
<p class="p67"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- is_trivially_move_constructible_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1">, a</span><span class="s43">nd</span></p>
<p class="p64"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_move_constructible_v&lt;Allocator&gt; is true</span></p>
<p class="p65"><span class="s1"></span><br></p>
<p class="p47"><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s18">...</span><span class="s1"> Args</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s1"> </span><span class="s26">basic_optional</span><span class="s14">(</span><span class="s1">in_place_t, Args</span><span class="s18">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p67"><span class="s1"><i>Constraints</i>: is_constructible_v</span><span class="s18">&lt;</span><span class="s1">T, Args</span><span class="s18">...&gt;</span><span class="s1"> is </span><span class="s47">true<a href="https://eel.is/c++draft/optional#ctor-13.sentence-1"><span class="s13">.</span></a></span></p>
<p class="p64"><span class="s43"><i>Effects</i>: </span><span class="s1">alloc is default-initialized.<span class="Apple-converted-space">  </span>The contained value is constructed by uses-allocator construction with allocator </span><span class="s31">alloc</span><span class="s1"> and std</span><span class="s31"> :: </span><span class="s1">forward</span><span class="s31">&lt;</span><span class="s1">Args</span><span class="s31">&gt;</span><span class="s41">(</span><span class="s1">args</span><span class="s41">)</span><span class="s31">...</span></p>
<p class="p67"><span class="s1"><i>Postconditions</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value<a href="https://eel.is/c++draft/optional#ctor-15.sentence-1"><span class="s43">.</span></a>.</span></p>
<p class="p67"><span class="s1"><i>Throws</i>: Any exception thrown by the selected constructor of T.</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: If </span><span class="s43">Allocator’s default constructor and </span><span class="s1">T's selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p70"><span class="s1"></span><br></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U, </span><span class="s1">class</span><span class="s18">...</span><span class="s13"> Args</span><span class="s18">&gt;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s1"> </span><span class="s26">basic_optional</span><span class="s14">(</span><span class="s1">in_place_t, initializer_list</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s1"> il, Args</span><span class="s18">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p67"><span class="s1"><i>Constraints</i>: is_constructible_v</span><span class="s18">&lt;</span><span class="s1">T, initializer_list</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;</span><span class="s1">, Args</span><span class="s18">...&gt;</span><span class="s1"> is </span><span class="s47">true<a href="https://eel.is/c++draft/optional#ctor-18.sentence-1"><span class="s13">.</span></a></span></p>
<p class="p71"><span class="s49"><i>Effects</i>: </span><span class="s1">alloc is default-initialized.<span class="Apple-converted-space">  </span>The contained value is constructed by uses-allocator construction with allocator alloc and il, std :: forward&lt;Args&gt;(args)...</span></p>
<p class="p67"><span class="s1"><i>Postconditions</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value<a href="https://eel.is/c++draft/optional#ctor-20.sentence-1"><span class="s43">.</span></a></span></p>
<p class="p67"><span class="s1"><i>Throws</i>: Any exception thrown by the selected constructor of T.</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: </span><span class="s44">If </span><span class="s43">Allocator’s default constructor and </span><span class="s44">T's selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p68"><span class="s1"></span><br></p>
<p class="p57"><span class="s27">template</span><span class="s18">&lt;</span><span class="s27">class</span><span class="s26"> U </span><span class="s18">=</span><span class="s26"> T</span><span class="s18">&gt;</span><span class="s26"> </span><span class="s27">constexpr</span><span class="s26"> </span><span class="s27">explicit</span><span class="s14">(</span><span class="s26"><i>see below</i></span><span class="s14">)</span><span class="s26"> basic_optional</span><span class="s14">(</span><span class="s26">U</span><span class="s18">&amp;&amp;</span><span class="s26"> v</span><span class="s14">)</span><span class="s26">;</span></p>
<p class="p67"><span class="s1"><i>Constraints</i>:</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s18">&lt;</span><span class="s1">T, U</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1">,,</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_same_v</span><span class="s18">&lt;</span><span class="s1">remove_cvref_t</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s1">, in_place_t</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">false</span><span class="s1">,</span></p>
<p class="p67"><span class="s44"><span class="Apple-tab-span">	</span>- is_same_v</span><span class="s45">&lt;</span><span class="s44">remove_cvref_t</span><span class="s45">&lt;</span><span class="s44">U</span><span class="s45">&gt;</span><span class="s44">, allocator_arg_t</span><span class="s45">&gt;</span><span class="s44"> is </span><span class="s50">false</span><span class="s44">,</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_same_v</span><span class="s18">&lt;</span><span class="s1">remove_cvref_t</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s1">, </span><span class="s44">basic_optional</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">false</span><span class="s1">, and</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- if T is <i>cv</i> </span><span class="s19">bool</span><span class="s1">, remove_cvref_t</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s1"> is not a specialization of basic_optional<a href="https://eel.is/c++draft/optional#ctor-23.sentence-1"><span class="s43">.</span></a></span></p>
<p class="p71"><span class="s49"><i>Effects</i>: </span><span class="s1">alloc is default-initialized.<span class="Apple-converted-space">  </span>The contained value is constructed by uses-allocator construction with allocator alloc and std :: forward&lt;U&gt;(v).</span></p>
<p class="p67"><span class="s1"><i>Postconditions</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value<a href="https://eel.is/c++draft/optional#ctor-25.sentence-1"><span class="s43">.</span></a></span></p>
<p class="p67"><span class="s1"><i>Throws</i>: Any exception thrown by the selected constructor of T<a href="https://eel.is/c++draft/optional#ctor-26.sentence-1"><span class="s43">.</span></a></span></p>
<p class="p72"><span class="s46"><i>Remarks</i>: </span><span class="s1">If </span><span class="s43">Allocator’s default constructor and </span><span class="s1">T's selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p57"><span class="s27">template</span><span class="s18">&lt;</span><span class="s27">class</span><span class="s26"> U</span><span class="s18">&gt;</span><span class="s26"> </span><span class="s27">constexpr</span><span class="s26"> </span><span class="s27">explicit</span><span class="s14">(</span><span class="s26"><i>see below</i></span><span class="s14">)</span><span class="s26"> basic_optional</span><span class="s14">(</span><span class="s27">const</span><span class="s26"> basic_optional</span><span class="s46"> </span><span class="s18">&lt;</span><span class="s26">U, Allocator</span><span class="s18">&gt;&amp;</span><span class="s26"> rhs</span><span class="s14">)</span><span class="s26">;</span></p>
<p class="p67"><span class="s1"><i>Constraints</i>:</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s18">&lt;</span><span class="s1">T, </span><span class="s19">const</span><span class="s1"> U</span><span class="s18">&amp;&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1">,<span class="Apple-converted-space"> </span></span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- if T is not <i>cv</i> </span><span class="s19">bool</span><span class="s1">, <i>converts-from-any-cvref</i></span><span class="s18">&lt;</span><span class="s1">T, </span><span class="s46">basic_optional </span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&gt;</span><span class="s1"> is </span><span class="s47">false</span><span class="s1">.</span></p>
<p class="p71"><span class="s49"><i>Effects</i>: </span><span class="s1">alloc is default-initialized.<span class="Apple-converted-space">  </span></span><span class="s49">If rhs contains a value, t</span><span class="s1">he contained value is constructed by uses-allocator construction with allocator alloc and</span><span class="s45">*</span><span class="s49">rhs<a href="https://eel.is/c++draft/optional#ctor-29.sentence-1"><span class="s32">.</span></a></span></p>
<p class="p67"><span class="s1"><i>Postconditions</i>: rhs</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">==</span><span class="s1"> </span><span class="s19">this</span><span class="s18">-&gt;</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p67"><span class="s1"><i>Throws</i>: Any exception thrown by the selected constructor of T.</span></p>
<p class="p72"><span class="s46"><i>Remarks</i>: </span><span class="s1">If </span><span class="s43">Allocator’s default constructor and </span><span class="s1">T's selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p67"><span class="s46"><span class="Apple-tab-span">	</span></span><span class="s1">The expression inside </span><span class="s19">explicit</span><span class="s1"> is equivalent to:</span></p>
<p class="p47"><span class="s18"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>!</span><span class="s1">is_convertible_v</span><span class="s18">&lt;</span><span class="s19">const</span><span class="s1"> U</span><span class="s18">&amp;</span><span class="s1">, T</span><span class="s18">&gt;</span></p>
<p class="p68"><span class="s1"></span><br></p>
<p class="p47"><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> U</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s14">(</span><span class="s1"><i>see below</i></span><span class="s14">)</span><span class="s1"> </span><span class="s26">basic_optional</span><span class="s14">(</span><span class="s1">optional</span><span class="s18">&lt;</span><span class="s1">U, Allocator</span><span class="s18">&gt;&amp;&amp;</span><span class="s1"> rhs</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p67"><span class="s1"><i>Constraints</i>:</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s18">&lt;</span><span class="s1">T, U</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1">, and</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- if T is not <i>cv</i> </span><span class="s19">bool</span><span class="s1">, <i>converts-from-any-cvref</i></span><span class="s18">&lt;</span><span class="s1">T, </span><span class="s46">basic_optional </span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&gt;</span><span class="s1"> is </span><span class="s47">false</span><span class="s1">.</span></p>
<p class="p64"><span class="s43"><i>Effects</i>: </span><span class="s26">alloc is default-initialized.<span class="Apple-converted-space">  </span></span><span class="s43">If rhs contains a value, t</span><span class="s1">he contained value is constructed by uses-allocator construction with allocator alloc</span><span class="s43">std</span><span class="s45"> :: </span><span class="s43">move</span><span class="s52">(</span><span class="s45">*</span><span class="s43">rhs</span><span class="s52">)<a href="https://eel.is/c++draft/optional#ctor-34.sentence-1"><span class="s13">.</span></a></span><span class="s43"> rhs</span><span class="s45">.</span><span class="s43">has_value</span><span class="s52">()</span><span class="s43"> is unchanged.</span></p>
<p class="p67"><span class="s1"><i>Postconditions</i>: rhs</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">==</span><span class="s1"> </span><span class="s19">this</span><span class="s18">-&gt;</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p67"><span class="s1"><i>Throws</i>: Any exception thrown by the selected constructor of T.</span></p>
<p class="p72"><span class="s46"><i>Remarks</i>: </span><span class="s1">If </span><span class="s43">Allocator’s default constructor and </span><span class="s1">T's selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p67"><span class="s46"><span class="Apple-tab-span">	</span></span><span class="s1">The expression inside </span><span class="s19">explicit</span><span class="s1"> is equivalent to:</span></p>
<p class="p47"><span class="s18"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>!</span><span class="s1">is_convertible_v</span><span class="s18">&lt;</span><span class="s1">U, T</span><span class="s18">&gt;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">   </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U </span><span class="s33">, </span><span class="s1">class</span><span class="s33"> </span><span class="s32">AllocatorU</span><span class="s33">&gt;</span></p>
<p class="p55"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s14">(</span><span class="s26"><i>see below</i></span><span class="s14">)</span><span class="s26"> </span><span class="s1">basic_optional</span><span class="s37">(</span><span class="s27">const</span><span class="s1"> basic_optional </span><span class="s33">&lt;</span><span class="s1">U, </span><span class="s32">AllocatorU</span><span class="s33">&gt;&amp;</span><span class="s37">)</span><span class="s1">;</span></p>
<p class="p67"><span class="s44"><i>Constraints</i>:</span></p>
<p class="p67"><span class="s44"><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s45">&lt;</span><span class="s44">T, </span><span class="s53">const</span><span class="s44"> U</span><span class="s45">&amp;&gt;</span><span class="s44"> is </span><span class="s50">true</span><span class="s44">,</span></p>
<p class="p72"><span class="s26"><span class="Apple-converted-space">           </span></span><span class="s1">- is_convertible_v</span><span class="s33">&lt;</span><span class="s1">const AllocatorU&amp;, </span><span class="s27">Allocator&gt;</span><span class="s1"> is </span><span class="s54">true</span><span class="s1">,</span></p>
<p class="p67"><span class="s44"><span class="Apple-tab-span">	</span>- if T is not <i>cv</i> </span><span class="s53">bool</span><span class="s44">, <i>converts-from-any-cvref</i></span><span class="s45">&lt;</span><span class="s44">T, basic_optional </span><span class="s45">&lt;</span><span class="s44">U</span><span class="s45">&gt;&gt;</span><span class="s44"> is </span><span class="s50">false<a href="https://eel.is/c++draft/optional#ctor-28.sentence-1"><span class="s13">.</span></a></span></p>
<p class="p64"><span class="s43"><i>Effects</i>: </span><span class="s1">alloc is default-initialized.<span class="Apple-converted-space">  </span></span><span class="s43">If rhs contains a value, t</span><span class="s1">he contained value is constructed by uses-allocator construction with allocator alloc and</span><span class="s45">*</span><span class="s43">rhs<a href="https://eel.is/c++draft/optional#ctor-29.sentence-1">.</a></span></p>
<p class="p67"><span class="s44"><i>Postconditions</i>: rhs</span><span class="s45">.</span><span class="s44">has_value</span><span class="s52">()</span><span class="s44"> </span><span class="s45">==</span><span class="s44"> </span><span class="s53">this</span><span class="s45">-&gt;</span><span class="s44">has_value</span><span class="s52">()</span><span class="s44">.</span></p>
<p class="p67"><span class="s44"><i>Throws</i>: Any exception thrown by the selected constructor of T.</span></p>
<p class="p72"><span class="s26"><i>Remarks</i>: </span><span class="s1">If </span><span class="s43">Allocator’s default constructor and </span><span class="s1">T's selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p67"><span class="s46"><span class="Apple-tab-span">	</span></span><span class="s44">The expression inside </span><span class="s53">explicit</span><span class="s44"> is equivalent to:</span></p>
<p class="p47"><span class="s18"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>!</span><span class="s1">is_convertible_v</span><span class="s18">&lt;</span><span class="s19">const</span><span class="s1"> U</span><span class="s18">&amp;</span><span class="s1">, T</span><span class="s18">&gt;</span></p>
<p class="p73"><span class="s1"></span><br></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U </span><span class="s33">, </span><span class="s1">class</span><span class="s33"> </span><span class="s32">AllocatorU</span><span class="s33">&gt;</span></p>
<p class="p55"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s14">(</span><span class="s26"><i>see below</i></span><span class="s14">)</span><span class="s26"> </span><span class="s1">basic_optional</span><span class="s37">(</span><span class="s1">basic_optional</span><span class="s33">&lt;</span><span class="s1">U, AllocatorU</span><span class="s33">&gt;&amp;&amp;</span><span class="s37">)</span><span class="s1">;</span></p>
<p class="p67"><span class="s44"><i>Constraints</i>:</span></p>
<p class="p67"><span class="s44"><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s45">&lt;</span><span class="s44">T, U</span><span class="s45">&gt;</span><span class="s44"> is </span><span class="s50">true</span><span class="s44">,<span class="Apple-converted-space"> </span></span></p>
<p class="p72"><span class="s1"><span class="Apple-converted-space">           </span>- is_convertible_v</span><span class="s33">&lt;</span><span class="s1">AllocatorU, </span><span class="s32">Allocator</span><span class="s27">&gt;</span><span class="s1"> is </span><span class="s54">true</span><span class="s1">,</span></p>
<p class="p67"><span class="s44"><span class="Apple-tab-span">	</span>- if T is not <i>cv</i> </span><span class="s53">bool</span><span class="s44">, <i>converts-from-any-cvref</i></span><span class="s45">&lt;</span><span class="s44">T, basic_optional </span><span class="s45">&lt;</span><span class="s44">U, </span><span class="s55">AllocatorU</span><span class="s45">&gt;&gt;</span><span class="s44"> is </span><span class="s50">false</span><span class="s44">.</span></p>
<p class="p64"><span class="s43"><i>Effects</i>: </span><span class="s1">alloc is default-initialized.<span class="Apple-converted-space">  </span></span><span class="s43">If rhs contains a value, t</span><span class="s1">he contained value is constructed by uses-allocator construction with allocator alloc and </span><span class="s43">std</span><span class="s45"> :: </span><span class="s43">move</span><span class="s52">(</span><span class="s45">*</span><span class="s43">rhs</span><span class="s52">)<a href="https://eel.is/c++draft/optional#ctor-34.sentence-1"><span class="s49">.</span></a></span><span class="s43"> rhs</span><span class="s45">.</span><span class="s43">has_value</span><span class="s52">()</span><span class="s43"> is unchanged.</span></p>
<p class="p67"><span class="s44"><i>Postconditions</i>: rhs</span><span class="s45">.</span><span class="s44">has_value</span><span class="s52">()</span><span class="s44"> </span><span class="s45">==</span><span class="s44"> </span><span class="s53">this</span><span class="s45">-&gt;</span><span class="s44">has_value</span><span class="s52">()</span><span class="s44">.</span></p>
<p class="p67"><span class="s44"><i>Throws</i>: Any exception thrown by the selected constructor of T.</span></p>
<p class="p72"><span class="s26"><i>Remarks</i>: </span><span class="s1">If </span><span class="s43">Allocator’s default constructor and </span><span class="s1">T's selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p67"><span class="s46"><span class="Apple-tab-span">	</span></span><span class="s44">The expression inside </span><span class="s53">explicit</span><span class="s44"> is equivalent to:</span></p>
<p class="p47"><span class="s18"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>!</span><span class="s1">is_convertible_v</span><span class="s18">&lt;</span><span class="s1">U, T</span><span class="s18">&gt;</span></p>
<p class="p73"><span class="s1"></span><br></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U</span><span class="s33">&gt;</span></p>
<p class="p55"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s14">(</span><span class="s26"><i>see below</i></span><span class="s14">)</span><span class="s26"> </span><span class="s1">basic_optional</span><span class="s37">(</span><span class="s27">const</span><span class="s1"> optional </span><span class="s33">&lt;</span><span class="s1">U</span><span class="s33">&gt;&amp;</span><span class="s37">)</span><span class="s1">;</span></p>
<p class="p72"><span class="s1"><i>Constraints</i>:</span></p>
<p class="p72"><span class="s1"><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s33">&lt;</span><span class="s1">T, </span><span class="s27">const</span><span class="s1"> U</span><span class="s33">&amp;&gt;</span><span class="s1"> is </span><span class="s54">true</span><span class="s1">,</span></p>
<p class="p72"><span class="s1"><span class="Apple-tab-span">	</span>- if T is not <i>cv</i> </span><span class="s27">bool</span><span class="s1">, <i>converts-from-any-cvref</i></span><span class="s33">&lt;</span><span class="s1">T, optional </span><span class="s33">&lt;</span><span class="s1">U</span><span class="s33">&gt;&gt;</span><span class="s1"> is </span><span class="s54">false<a href="https://eel.is/c++draft/optional#ctor-28.sentence-1"><span class="s32">.</span></a></span></p>
<p class="p71"><span class="s43"><i>Effects</i>: </span><span class="s1">alloc is default-initialized.<span class="Apple-converted-space">  </span></span><span class="s43">If rhs contains a value, t</span><span class="s1">he contained value is constructed by uses-allocator construction with allocator alloc and</span><span class="s56">*</span><span class="s43">rhs<a href="https://eel.is/c++draft/optional#ctor-29.sentence-1"><span class="s49">.</span></a></span></p>
<p class="p72"><span class="s1"><i>Postconditions</i>: rhs</span><span class="s33">.</span><span class="s1">has_value</span><span class="s37">()</span><span class="s1"> </span><span class="s33">==</span><span class="s1"> </span><span class="s27">this</span><span class="s33">-&gt;</span><span class="s1">has_value</span><span class="s37">()</span><span class="s1">.</span></p>
<p class="p72"><span class="s1"><i>Throws</i>: Any exception thrown by the selected constructor of T.</span></p>
<p class="p72"><span class="s1"><i>Remarks</i>: If </span><span class="s43">Allocator’s default constructor and </span><span class="s1">T's selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p72"><span class="s1"><span class="Apple-tab-span">	</span>The expression inside </span><span class="s27">explicit</span><span class="s1"> is equivalent to:</span></p>
<p class="p55"><span class="s33"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>!</span><span class="s1">is_convertible_v</span><span class="s33">&lt;</span><span class="s27">const</span><span class="s1"> U</span><span class="s33">&amp;</span><span class="s1">, T</span><span class="s33">&gt;</span></p>
<p class="p73"><span class="s1"></span><br></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U</span><span class="s33">&gt;</span></p>
<p class="p55"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s1"> </span><span class="s19">explicit</span><span class="s14">(</span><span class="s26"><i>see below</i></span><span class="s14">)</span><span class="s26"> </span><span class="s1">basic_optional</span><span class="s37">(</span><span class="s1">optional</span><span class="s33">&lt;</span><span class="s1">U</span><span class="s33">&gt;&amp;&amp;</span><span class="s37">)</span><span class="s1">;</span></p>
<p class="p72"><span class="s1"><i>Constraints</i>:</span></p>
<p class="p72"><span class="s1"><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s33">&lt;</span><span class="s1">T, U</span><span class="s33">&gt;</span><span class="s1"> is </span><span class="s54">true</span><span class="s1">,<span class="Apple-converted-space"> </span></span></p>
<p class="p72"><span class="s1"><span class="Apple-tab-span">	</span>- if T is not <i>cv</i> </span><span class="s27">bool</span><span class="s1">, <i>converts-from-any-cvref</i></span><span class="s33">&lt;</span><span class="s1">T, optional </span><span class="s33">&lt;</span><span class="s1">U</span><span class="s33">&gt;&gt;</span><span class="s1"> is </span><span class="s54">false</span><span class="s1">.</span></p>
<p class="p71"><span class="s43"><i>Effects</i>: </span><span class="s1">alloc is default-initialized.<span class="Apple-converted-space">  </span></span><span class="s43">If rhs contains a value, t</span><span class="s1">he contained value is constructed by uses-allocator construction with allocator alloc and </span><span class="s43">std</span><span class="s56"> :: </span><span class="s43">move</span><span class="s57">(</span><span class="s56">*</span><span class="s43">rhs</span><span class="s57">)<a href="https://eel.is/c++draft/optional#ctor-34.sentence-1"><span class="s32">.</span></a></span><span class="s43"> rhs</span><span class="s56">.</span><span class="s43">has_value</span><span class="s57">()</span><span class="s43"> is unchanged.</span></p>
<p class="p72"><span class="s1"><i>Postconditions</i>: rhs</span><span class="s33">.</span><span class="s1">has_value</span><span class="s37">()</span><span class="s1"> </span><span class="s33">==</span><span class="s1"> </span><span class="s27">this</span><span class="s33">-&gt;</span><span class="s1">has_value</span><span class="s37">()</span><span class="s1">.</span></p>
<p class="p72"><span class="s1"><i>Throws</i>: Any exception thrown by the selected constructor of T.</span></p>
<p class="p72"><span class="s1"><i>Remarks</i>: If </span><span class="s43">Allocator’s default constructor and </span><span class="s1">T's selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p72"><span class="s1"><span class="Apple-tab-span">	</span>The expression inside </span><span class="s27">explicit</span><span class="s1"> is equivalent to:</span></p>
<p class="p55"><span class="s33"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>!</span><span class="s1">is_convertible_v</span><span class="s33">&lt;</span><span class="s1">U, T</span><span class="s33">&gt;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p54"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s27">constexpr</span><span class="s32"> basic_optional</span><span class="s37">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a</span><span class="s37">)</span><span class="s32">;</span></p>
<p class="p54"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s27">constexpr</span><span class="s32"> basic_optional</span><span class="s37">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a, </span><span class="s32">nullopt_t</span><span class="s37">)</span><span class="s32">;</span></p>
<p class="p54"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s27">constexpr</span><span class="s32"> basic_optional</span><span class="s37">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a, </span><span class="s27">const</span><span class="s32"> optional</span><span class="s33">&amp;</span><span class="s37">)</span><span class="s32">;</span></p>
<p class="p54"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s27">constexpr</span><span class="s32"> basic_optional</span><span class="s37">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a, </span><span class="s32">optional</span><span class="s33">&amp;&amp;</span><span class="s37">)</span><span class="s32">;</span></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s33">...</span><span class="s32"> Args</span><span class="s33">&gt;</span></p>
<p class="p54"><span class="s32"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s32"> </span><span class="s27">explicit</span><span class="s32"> basic_optional</span><span class="s37">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a, </span><span class="s32">in_place_t, Args</span><span class="s33">&amp;&amp;...</span><span class="s37">)</span><span class="s32">;</span></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U, </span><span class="s1">class</span><span class="s33">...</span><span class="s32"> Args</span><span class="s33">&gt;</span></p>
<p class="p55"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s1"> </span><span class="s27">explicit</span><span class="s1"> basic_optional</span><span class="s37">(</span><span class="s32">allocator_arg_t, const allocator_type&amp; a, </span><span class="s1">in_place_t, initializer_list</span><span class="s33">&lt;</span><span class="s1">U</span><span class="s33">&gt;</span><span class="s1">, Args</span><span class="s33">&amp;&amp;...</span><span class="s37">)</span><span class="s1">;</span></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U </span><span class="s33">=</span><span class="s32"> T</span><span class="s33">&gt;</span></p>
<p class="p54"><span class="s32"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s32"> </span><span class="s27">explicit</span><span class="s37">(</span><span class="s32"><i>see below</i></span><span class="s37">)</span><span class="s32"> basic_optional</span><span class="s37">(</span><span class="s1">allocator_arg_t, const allocator_type&amp; a, </span><span class="s32">U</span><span class="s33">&amp;&amp;</span><span class="s37">)</span><span class="s32">;</span></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">   </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U </span><span class="s33">, </span><span class="s1">class</span><span class="s33"> AllocatorU&gt;</span></p>
<p class="p55"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s1"> basic_optional</span><span class="s37">(</span><span class="s27">const</span><span class="s1"> basic_optional </span><span class="s33">&lt;</span><span class="s1">U, </span><span class="s33">AllocatorU&gt;&amp;</span><span class="s37">)</span><span class="s1">;</span></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U </span><span class="s33">, </span><span class="s1">class</span><span class="s33"> AllocatorU&gt;</span></p>
<p class="p55"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s1"> basic_optional</span><span class="s37">(</span><span class="s1">basic_optional</span><span class="s33">&lt;</span><span class="s1">U, AllocatorU</span><span class="s33">&gt;&amp;&amp;</span><span class="s37">)</span><span class="s1">;</span></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U</span><span class="s33">&gt;</span></p>
<p class="p55"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s1"> basic_optional</span><span class="s37">(</span><span class="s27">const</span><span class="s1"> optional </span><span class="s33">&lt;</span><span class="s1">U</span><span class="s33">&gt;&amp;</span><span class="s37">)</span><span class="s1">;</span></p>
<p class="p50"><span class="s32"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s33">&lt;</span><span class="s1">class</span><span class="s32"> U</span><span class="s33">&gt;</span></p>
<p class="p55"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s27">constexpr</span><span class="s1"> basic_optional</span><span class="s37">(</span><span class="s1">optional</span><span class="s33">&lt;</span><span class="s1">U</span><span class="s33">&gt;&amp;&amp;</span><span class="s37">)</span><span class="s1">;</span></p>
<p class="p64"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Behaves the same as non allocator extended version of the constructor except it initializes alloc with the specified allocator before initializing the alternative, if any, by uses-allocator construction.</span></p>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06; min-height: 16.0px"><span class="s1"><b></b></span><br></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06; min-height: 16.0px"><span class="s1"><b></b></span><br></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06"><span class="s44"><b>22.5.x.3</b></span><span class="s49"><b> Destructor</b></span><span class="s44"><b>[basic.optional.dtor]</b></span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06; min-height: 16.0px"><span class="s1"><b></b></span><br></h4>
<p class="p47"><span class="s19">constexpr</span><span class="s1"> </span><span class="s18">~basic_</span><span class="s1">optional</span><span class="s14">()</span><span class="s1">;</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: If is_trivially_destructible_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s18">!=</span><span class="s1"> </span><span class="s47">true</span><span class="s1"> and </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value, calls</span></p>
<p class="p47"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>val</span><span class="s18">-&gt;</span><span class="s1">T</span><span class="s18">::~</span><span class="s1">T</span><span class="s14">()</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: If is_trivially_destructible_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1">, then this destructor is trivial</span></p>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06; min-height: 16.0px"><span class="s1"><b></b></span><br></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06"><span class="s44"><b>22.5.x.4</b></span><span class="s49"><b> Assignment</b></span><span class="s44"><b> [basic.optional.assign]</b></span></h4>
<p class="p68"><span class="s1"></span><br></p>
<p class="p47"><span class="s19">onstexpr</span><span class="s1"> </span><span class="s18">basic_</span><span class="s1">optional </span><span class="s18">&lt;</span><span class="s1">T, Allocator</span><span class="s18">&gt;&amp;</span><span class="s1"> </span><span class="s19">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s1">nullopt_t</span><span class="s14">)</span><span class="s1"> </span><span class="s19">noexcept</span><span class="s1">;</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: If </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value, calls val</span><span class="s18">-&gt;</span><span class="s1">T</span><span class="s18"> :: ~</span><span class="s1">T</span><span class="s14">()</span><span class="s1"> to destroy the contained value; otherwise no effect</span></p>
<p class="p67"><span class="s1"><i>Postconditions</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> does not contain a value</span></p>
<p class="p67"><span class="s1"><i>Returns</i>: </span><span class="s18">*</span><span class="s19">this</span></p>
<p class="p75"><span class="s1"></span><br></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p55"><span class="s19">constexpr</span><span class="s26"> </span><span class="s33">basic_</span><span class="s1">optional </span><span class="s18">&lt;</span><span class="s26">T, Allocator</span><span class="s18">&gt;&lt;</span><span class="s26">T</span><span class="s18">&gt;&amp;</span><span class="s26"> </span><span class="s19">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s19">const</span><span class="s26"> </span><span class="s33">basic_</span><span class="s1">optional</span><span class="s18">&amp;</span><span class="s26"> rhs</span><span class="s14">)</span><span class="s26">;</span></p>
<p class="p76"><span class="s58"><i>Effects</i>: </span><span class="s1"><span class="Apple-converted-space">  </span>If allocator_traits&lt;Allocator&gt;::propagate_on_container_copy_assignment::value is </span><span class="s59">true, sets alloc to rhs.alloc.</span></p>
<p class="p67"><span class="s60"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>Then, </span><span class="s1">see Table x</span></p>
<p class="p77"><span class="s2"></span><br></p>
<p class="p78"><span class="s2">Table — basic_optional operator=(const basic_optional&amp; rhs) effects</span></p>
<table cellspacing="0" cellpadding="0" class="t1">
  <tbody>
    <tr>
      <td valign="middle" class="td1">
        <p class="p79"><span class="s1"><b><span class="Apple-converted-space">            </span></b></span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p78"><span class="s2"><b>*this contains a value</b></span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p78"><span class="s2"><b>*this does not contain a value</b></span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p77"><span class="s2"></span><br></p>
        <p class="p40"><span class="s2">rhs contains a value</span></p>
        <p class="p77"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p77"><span class="s1"></span><br></p>
        <p class="p40"><span class="s2">assigns *rhs to the contained value</span></p>
        <p class="p77"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p80"><span class="s44"><span class="Apple-converted-space"> </span></span><span class="s1">if uses_allocator_v&lt;remove_cv_t&lt;T&gt;&gt;, Allocator&gt; is false or allocator_traits&lt;Allocator&gt;::is_always_equal::value is true, direct-non-list-initializes the contained value with *rhs. Otherwise, constructs the contained value by </span><span class="s28">uses-allocator construction with allocator alloc and</span><span class="s61">*</span><span class="s62">rhs</span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p40"><span class="s2">rhs does not contain a value</span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p77"><span class="s1"></span><br></p>
        <p class="p40"><span class="s2">Destroys the contained value by calling val-&gt;T::~T()</span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p40"><span class="s1">No additional effect</span></p>
      </td>
    </tr>
  </tbody>
</table>
<p class="p77"><span class="s1"></span><br></p>
<p class="p81"><span class="s1"></span><br></p>
<p class="p67"><span class="s1"><i>Postconditions</i>: rhs</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">==</span><span class="s1"> </span><span class="s19">this</span><span class="s18">-&gt;</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p67"><span class="s1"><i>Returns</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1">.</span></p>
<p class="p62"><span class="s1"><i>Remarks</i>: If any exception is thrown, the result of the expression </span><span class="s19">this</span><span class="s18">-&gt;</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> remains unchanged<a href="https://eel.is/c++draft/optional#assign-7.sentence-1"><span class="s43">.</span></a> If an exception is thrown during the call to T's selected copy constructor, no effect<a href="https://eel.is/c++draft/optional#assign-7.sentence-2"><span class="s43">.</span></a> If an exception is thrown during the call to T's copy assignment, the state of its contained value is as defined by the exception safety guarantee of T's copy assignment. This operator is defined as deleted unless is_copy_constructible_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1"> and is_copy_assignable_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1">.</span></p>
<p class="p82"><span class="s58"><span class="Apple-converted-space"> </span></span><span class="s1">The assignment operator is trivial if :</span></p>
<p class="p76"><span class="s1">-  is_trivially_copy_constructible_v</span><span class="s31">&lt;</span><span class="s1">T</span><span class="s31">&gt;</span><span class="s1"> </span><span class="s31">&amp;&amp;</span><span class="s1"> is_trivially_copy_assignable_v</span><span class="s31">&lt;</span><span class="s1">T</span><span class="s31">&gt;</span><span class="s1"> </span><span class="s31">&amp;&amp;</span><span class="s1"> is_trivially_destructible_v</span><span class="s31">&lt;</span><span class="s1">T</span><span class="s31">&gt;</span><span class="s1"> is </span><span class="s59">true</span><span class="s1"><i>,</i></span></p>
<p class="p76"><span class="s1">-  is_trivially_copy_constructible_v</span><span class="s31">&lt;</span><span class="s1">Allocator</span><span class="s31">&gt;</span><span class="s1"> </span><span class="s31">&amp;&amp;</span><span class="s1"> is_trivially_copy_assignable_v</span><span class="s31">&lt;</span><span class="s1">Allocator</span><span class="s31">&gt;</span><span class="s1"> </span><span class="s31">&amp;&amp;</span><span class="s1"> is_trivially_destructible_v</span><span class="s31">&lt;</span><span class="s1">Allocator</span><span class="s31">&gt;</span><span class="s1"> is true, and</span></p>
<p class="p83"><span class="s63">- </span><span class="s64">allocator_traits&lt;Allocator&gt;::is_always_equal::value is true</span></p>
<p class="p69"><span class="s1"><a href="https://eel.is/c++draft/optional#lib:operator=,optional__">🔗<span class="s51"></span></a></span></p>
<p class="p55"><span class="s19">constexpr</span><span class="s26"> </span><span class="s33">basic_</span><span class="s1">optional</span><span class="s18">&amp;</span><span class="s26"> </span><span class="s19">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s33">basic_</span><span class="s1">optional</span><span class="s18">&amp;&amp;</span><span class="s26"> rhs</span><span class="s14">)</span><span class="s26"> </span><span class="s19">noexcept</span><span class="s14">(</span><span class="s26"><i>see below</i></span><span class="s14">)</span><span class="s26">;</span></p>
<p class="p67"><span class="s1"><i>Constraints</i>: is_move_constructible_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1"> and is_move_assignable_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1">.</span></p>
<p class="p84"><span class="s65"><i>Effects</i>: </span><span class="s1">If allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value is true, sets alloc to rhs.alloc.</span></p>
<p class="p67"><span class="s66"><span class="Apple-tab-span">	</span> Then, </span><span class="s1">see TableX. The result of the expression rhs</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> remains unchanged</span></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p85"><span class="s2"></span><br></p>
<p class="p86"><span class="s2">Table — basic_optional operator=(basic_optional&amp;&amp; rhs) effects</span></p>
<table cellspacing="0" cellpadding="0" class="t1">
  <tbody>
    <tr>
      <td valign="middle" class="td1">
        <p class="p87"><span class="s1"><b><span class="Apple-converted-space">            </span></b></span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p86"><span class="s2"><b>*this contains a value</b></span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p86"><span class="s2"><b>*this does not contain a value</b></span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p85"><span class="s2"></span><br></p>
        <p class="p88"><span class="s2">rhs contains a value</span></p>
        <p class="p85"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p85"><span class="s1"></span><br></p>
        <p class="p88"><span class="s2">assigns std::move(*rhs) to the contained value</span></p>
        <p class="p85"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p89"><span class="s44"><span class="Apple-converted-space"> </span></span><span class="s1">if uses_allocator_v&lt;remove_cv_t&lt;T&gt;&gt;, Allocator&gt; is false or allocator_traits&lt;Allocator&gt;::is_always_equal::value is true or </span><span class="s26">or allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value is true</span><span class="s1">, direct-non-list-initializes the contained value with std::move(*rhs). Otherwise, constructs the contained value by </span><span class="s21">uses-allocator construction with allocator alloc and</span><span class="s67">*</span><span class="s68">rhs</span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p88"><span class="s2">rhs does not contain a value</span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p85"><span class="s1"></span><br></p>
        <p class="p88"><span class="s2">Destroys the contained value by calling val-&gt;T::~T()</span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p88"><span class="s1">No additional effect</span></p>
      </td>
    </tr>
  </tbody>
</table>
<p class="p67"><span class="s1"><i>Postconditions</i>: rhs</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">==</span><span class="s1"> </span><span class="s19">this</span><span class="s18">-&gt;</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1">.</span></p>
<p class="p67"><span class="s1"><i>Returns</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1">.</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: The exception specification is equivalent to:</span></p>
<p class="p88"><span class="s13">is_nothrow_move_assignable_v</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13"> is_nothrow_move_constructible_v</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;&amp; (!</span><span class="s1">uses_allocator_v&lt;remove_cv_t&lt;T&gt;&gt;, Allocator&gt; || allocator_traits&lt;Allocator&gt;::is_always_equal::value || allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value)</span></p>
<p class="p62"><span class="s1">If any exception is thrown, the result of the expression </span><span class="s19">this</span><span class="s18">-&gt;</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> remains unchanged.</span></p>
<p class="p62"><span class="s1">If an exception is thrown during the call to T's move constructor, the state of </span><span class="s18">*</span><span class="s1">rhs</span><span class="s18">.</span><span class="s1">val is determined by the exception safety guarantee of T's selected move constructor. If an exception is thrown during the call to T's move assignment, the state of </span><span class="s18">*</span><span class="s1">val and </span><span class="s18">*</span><span class="s1">rhs</span><span class="s18">.</span><span class="s1">val is determined by the exception safety guarantee of T's move assignment. </span></p>
<p class="p76"><span class="s1">If </span></p>
<p class="p76"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_move_constructible_v</span><span class="s31">&lt;</span><span class="s1">T</span><span class="s31">&gt;</span><span class="s1"> </span><span class="s31">&amp;&amp;</span><span class="s1"> is_trivially_move_assignable_v</span><span class="s31">&lt;</span><span class="s1">T</span><span class="s31">&gt;</span><span class="s1"> </span><span class="s31">&amp;&amp;</span><span class="s1"> is_trivially_destructible_v</span><span class="s31">&lt;</span><span class="s1">T</span><span class="s31">&gt;</span><span class="s1"> is </span><span class="s59">true</span><span class="s1">, and<span class="Apple-converted-space"> </span></span></p>
<p class="p76"><span class="s1"><span class="Apple-converted-space">                                </span>- is_trivially_move_constructible_v&lt;Allocator&gt; &amp;&amp; is_trivially_move_assignable_v&lt;Allocator&gt; &amp;&amp; is_trivially_destructible_v&lt;Allocator&gt; is true</span></p>
<p class="p76"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- allocator_traits&lt;Allocator&gt;::is_always_equal::value is true or allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value is true<span class="Apple-converted-space"> </span></span></p>
<p class="p76"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>this assignment operator is trivial<a href="https://eel.is/c++draft/variant#assign-10.sentence-1"><span class="s69">.</span></a> </span></p>
<p class="p90"><span class="s1"></span><br></p>
<p class="p70"><span class="s1"></span><br></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U </span><span class="s18">=</span><span class="s13"> T</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s34">basic_</span><span class="s13">optional </span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s13">U</span><span class="s18">&amp;&amp;</span><span class="s13"> v</span><span class="s14">)</span><span class="s13">.</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: If </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value, assigns std</span><span class="s18"> :: </span><span class="s1">forward</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s52">(</span><span class="s44">v</span><span class="s52">)</span><span class="s44"> to the contained value; otherwise </span><span class="s49">constructs the contained value by uses-allocator construction with allocator alloc and </span><span class="s44">std</span><span class="s45">::</span><span class="s44">forward</span><span class="s45">&lt;</span><span class="s44">U</span><span class="s45">&gt;</span><span class="s52">(</span><span class="s44">v</span><span class="s52">)</span><span class="s44">.</span></p>
<p class="p67"><span class="s1"><i>Postconditions</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value.</span></p>
<p class="p67"><span class="s1"><i>Returns</i>: </span><span class="s18">*</span><span class="s19">this</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: If any exception is thrown, the result of the expression </span><span class="s19">this</span><span class="s18">-&gt;</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> remains unchanged. If an exception is thrown during the call to T's constructor, the state of v is determined by the exception safety guarantee of T's selected constructor. If an exception is thrown during the call to T's assignment, the state of </span><span class="s18">*</span><span class="s1">val and v is determined by the exception safety guarantee of T's assignment.</span></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p47"><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> U, </span><span class="s38">class</span><span class="s26"> AllocatorU</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> </span><span class="s33">basic_</span><span class="s1">optional </span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&amp;</span><span class="s1"> </span><span class="s19">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> basic_optional </span><span class="s18">&lt;</span><span class="s1">U, AllocatorU</span><span class="s18">&gt;&amp;</span><span class="s1"> rhs</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p67"><span class="s44"><i>Constraints</i>:</span></p>
<p class="p67"><span class="s44"><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s45">&lt;</span><span class="s44">T, </span><span class="s53">const</span><span class="s44"> U</span><span class="s45">&amp;&gt;</span><span class="s44"> is </span><span class="s50">true</span><span class="s44">,</span></p>
<p class="p67"><span class="s44"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s45">&lt;</span><span class="s44">T</span><span class="s45">&amp;</span><span class="s44">, </span><span class="s53">const</span><span class="s44"> U</span><span class="s45">&amp;&gt;</span><span class="s44"> is </span><span class="s50">true</span><span class="s44">,</span></p>
<p class="p67"><span class="s44"><span class="Apple-tab-span">	</span>- <i>converts-from-any-cvref</i></span><span class="s45">&lt;</span><span class="s44">T, basic_optional</span><span class="s45">&lt;</span><span class="s44">U, AllocatorU</span><span class="s45">&gt;&gt;</span><span class="s44"> is </span><span class="s50">false</span><span class="s44">,</span></p>
<p class="p72"><span class="s26"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s26">T</span><span class="s18">&amp;</span><span class="s26">, </span><span class="s1">basic_optional</span><span class="s33">&lt;</span><span class="s1">U, AllocatorU</span><span class="s33">&gt;</span><span class="s18">&amp;&gt;</span><span class="s26"> is </span><span class="s47">false</span><span class="s26">,</span></p>
<p class="p72"><span class="s26"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s26">T</span><span class="s18">&amp;</span><span class="s26">, </span><span class="s1">basic_optional</span><span class="s33">&lt;</span><span class="s1">U, AllocatorU</span><span class="s33">&gt;</span><span class="s18">&amp;&amp;&gt;</span><span class="s26"> is </span><span class="s47">false</span><span class="s26">,</span></p>
<p class="p67"><span class="s44"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s45">&lt;</span><span class="s44">T</span><span class="s45">&amp;</span><span class="s44">, </span><span class="s53">const</span><span class="s44"> </span><span class="s46">basic_optional</span><span class="s70">&lt;</span><span class="s46">U, AllocatorU</span><span class="s70">&gt;</span><span class="s45">&amp;&gt;</span><span class="s44"> is </span><span class="s50">false</span><span class="s44">, and</span></p>
<p class="p72"><span class="s26"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s26">T</span><span class="s18">&amp;</span><span class="s26">, </span><span class="s19">const</span><span class="s26"> </span><span class="s1">basic_optional</span><span class="s33">&lt;</span><span class="s1">U, AllocatorU</span><span class="s33">&gt;</span><span class="s18">&amp;&amp;&gt;</span><span class="s26"> is </span><span class="s47">false</span><span class="s26">.</span></p>
<p class="p67"><span class="s44"><i>Effects</i>: See Table</span></p>
<p class="p72"><span class="s26"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Table optional</span><span class="s18"> ::</span><span class="s19">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s19">const</span><span class="s26"> </span><span class="s1">basic_optional</span><span class="s33">&lt;</span><span class="s1">U, AllocatorU</span><span class="s33">&gt;</span><span class="s18">&amp;</span><span class="s14">)</span><span class="s26"> effects</span><span class="s71"> </span></p>
<p class="p91"><span class="s1"></span><br></p>
<p class="p78"><span class="s2">Table — basic_optional operator=(const basic_optional&lt;U, AllocatorU&gt;&amp;) effects</span></p>
<table cellspacing="0" cellpadding="0" class="t1">
  <tbody>
    <tr>
      <td valign="middle" class="td1">
        <p class="p79"><span class="s1"><b><span class="Apple-converted-space">            </span></b></span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p78"><span class="s2"><b>*this contains a value</b></span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p78"><span class="s2"><b>*this does not contain a value</b></span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p77"><span class="s2"></span><br></p>
        <p class="p40"><span class="s2">rhs contains a value</span></p>
        <p class="p77"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p77"><span class="s1"></span><br></p>
        <p class="p40"><span class="s2">assigns *rhs to the contained value</span></p>
        <p class="p77"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p40"><span class="s72"><span class="Apple-converted-space"> </span></span><span class="s64">constructs the contained value by </span><span class="s1">uses-allocator construction with allocator alloc and </span><span class="s33">*</span><span class="s32">rhs</span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p40"><span class="s2">rhs does not contain a value</span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p77"><span class="s1"></span><br></p>
        <p class="p40"><span class="s2">Destroys the contained value by calling val-&gt;T::~T()</span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p40"><span class="s1">No additional effect</span></p>
      </td>
    </tr>
  </tbody>
</table>
<p class="p67"><span class="s44"><i>Postconditions</i>: rhs</span><span class="s56">.</span><span class="s44">has_value</span><span class="s57">()</span><span class="s44"> </span><span class="s56">==</span><span class="s44"> </span><span class="s73">this</span><span class="s56">-&gt;</span><span class="s44">has_value</span><span class="s57">()</span><span class="s44">.</span></p>
<p class="p67"><span class="s44"><i>Returns</i>: </span><span class="s45">*</span><span class="s53">this</span><span class="s44">.</span></p>
<p class="p67"><span class="s44"><i>Remarks</i>: If any exception is thrown, the result of the expression </span><span class="s53">this</span><span class="s45">-&gt;</span><span class="s44">has_value</span><span class="s52">()</span><span class="s44"> remains unchanged<a href="https://eel.is/c++draft/optional#assign-23.sentence-1"><span class="s1">.</span></a> If an exception is thrown during the call to T's constructor, the state of </span><span class="s45">*</span><span class="s44">rhs</span><span class="s45">.</span><span class="s44">val is determined by the exception safety guarantee of T's selected constructor If an exception is thrown during the call to T's assignment, the state of </span><span class="s45">*</span><span class="s44">val and </span><span class="s45">*</span><span class="s44">rhs</span><span class="s45">.</span><span class="s44">val is determined by the exception safety guarantee of T's assignment.</span></p>
<p class="p66"><span class="s44"></span><br></p>
<p class="p69"><span class="s1"><a href="https://eel.is/c++draft/optional#lib:operator=,optional_____">🔗<span class="s51"></span></a></span></p>
<p class="p55"><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s26"> U</span><span class="s1">, </span><span class="s27">class</span><span class="s1"> AllocatorU</span><span class="s18">&gt;</span><span class="s26"> </span><span class="s19">constexpr</span><span class="s26"> optional</span><span class="s18">&lt;</span><span class="s26">T</span><span class="s18">&gt;&amp;</span><span class="s26"> </span><span class="s19">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s1">basic_optional </span><span class="s33">&lt;</span><span class="s1">U, AllocatorU</span><span class="s33">&gt;</span><span class="s18">&amp;&amp;</span><span class="s26"> rhs</span><span class="s14">)</span><span class="s26">;</span></p>
<p class="p67"><span class="s44"><i>Constraints</i>:</span></p>
<p class="p67"><span class="s44"><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s45">&lt;</span><span class="s44">T, U</span><span class="s45">&gt;</span><span class="s44"> is </span><span class="s50">true</span><span class="s44">,</span></p>
<p class="p67"><span class="s44"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s45">&lt;</span><span class="s44">T</span><span class="s45">&amp;</span><span class="s44">, U</span><span class="s45">&gt;</span><span class="s44"> is </span><span class="s50">true</span><span class="s44">,</span></p>
<p class="p67"><span class="s44"><span class="Apple-tab-span">	</span>- <i>converts-from-any-cvref</i></span><span class="s45">&lt;</span><span class="s44">T, basic_optional &lt;U, AllocatorU&gt;</span><span class="s45">&gt;</span><span class="s44"> is </span><span class="s50">false</span><span class="s44">,</span></p>
<p class="p72"><span class="s26"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s26">T</span><span class="s18">&amp;</span><span class="s26">, </span><span class="s1">basic_optional &lt;U, AllocatorU&gt;</span><span class="s18">&amp;&gt;</span><span class="s26"> is </span><span class="s47">false</span><span class="s26">,</span></p>
<p class="p72"><span class="s26"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s26">T</span><span class="s18">&amp;</span><span class="s26">, </span><span class="s1">basic_optional &lt;U, AllocatorU&gt;</span><span class="s18">&amp;&amp;&gt;</span><span class="s26"> is </span><span class="s47">false</span><span class="s26">,</span></p>
<p class="p67"><span class="s44"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s45">&lt;</span><span class="s44">T</span><span class="s45">&amp;</span><span class="s44">, </span><span class="s53">const</span><span class="s44"> </span><span class="s46">basic_optional &lt;U, AllocatorU&gt;</span><span class="s45">&amp;&gt;</span><span class="s44"> is </span><span class="s50">false</span><span class="s44">, and</span></p>
<p class="p72"><span class="s26"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s26">T</span><span class="s18">&amp;</span><span class="s26">, </span><span class="s19">const</span><span class="s26"> </span><span class="s1">basic_optional &lt;U, AllocatorU&gt;</span><span class="s18">&amp;&amp;&gt;</span><span class="s26"> is </span><span class="s47">false</span></p>
<p class="p66"><span class="s44"></span><br></p>
<p class="p67"><span class="s44"><i>Effects</i>: See Table. The result of the expression rhs</span><span class="s45">.</span><span class="s44">has_value</span><span class="s52">()</span><span class="s44"> remains unchanged</span></p>
<p class="p78"><span class="s2">Table — basic_optional operator=(basic_optional &lt;U, AllocatorU&gt;&amp;&amp;) effects</span></p>
<table cellspacing="0" cellpadding="0" class="t1">
  <tbody>
    <tr>
      <td valign="middle" class="td1">
        <p class="p79"><span class="s1"><b><span class="Apple-converted-space">            </span></b></span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p78"><span class="s2"><b>*this contains a value</b></span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p78"><span class="s2"><b>*this does not contain a value</b></span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p77"><span class="s2"></span><br></p>
        <p class="p40"><span class="s2">rhs contains a value</span></p>
        <p class="p77"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p77"><span class="s1"></span><br></p>
        <p class="p40"><span class="s2">assigns std::move(*rhs) to the contained value</span></p>
        <p class="p77"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p40"><span class="s72"><span class="Apple-converted-space"> </span></span><span class="s64">constructs the contained value by </span><span class="s1">uses-allocator construction with allocator alloc and std::move(</span><span class="s33">*</span><span class="s32">rhs)</span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p40"><span class="s2">rhs does not contain a value</span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p77"><span class="s1"></span><br></p>
        <p class="p40"><span class="s2">Destroys the contained value by calling val-&gt;T::~T()</span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p40"><span class="s1">No additional effect</span></p>
      </td>
    </tr>
  </tbody>
</table>
<p class="p67"><span class="s44"><i>Postconditions</i>: rhs</span><span class="s56">.</span><span class="s44">has_value</span><span class="s57">()</span><span class="s44"> </span><span class="s56">==</span><span class="s44"> </span><span class="s73">this</span><span class="s56">-&gt;</span><span class="s44">has_value</span><span class="s57">()</span><span class="s44">.</span></p>
<p class="p67"><span class="s44"><i>Returns</i>: </span><span class="s56">*</span><span class="s73">this</span><span class="s44">.</span></p>
<p class="p67"><span class="s44"><i>Remarks</i>: If any exception is thrown, the result of the expression </span><span class="s73">this</span><span class="s56">-&gt;</span><span class="s44">has_value</span><span class="s57">()</span><span class="s44"> remains unchanged<a href="https://eel.is/c++draft/optional#assign-23.sentence-1"><span class="s1">.</span></a> If an exception is thrown during the call to T's constructor, the state of </span><span class="s56">*</span><span class="s44">rhs</span><span class="s56">.</span><span class="s44">val is determined by the exception safety guarantee of T's selected constructor If an exception is thrown during the call to T's assignment, the state of </span><span class="s56">*</span><span class="s44">val and </span><span class="s56">*</span><span class="s44">rhs</span><span class="s56">.</span><span class="s44">val is determined by the exception safety guarantee of T's assignment.</span></p>
<p class="p68"><span class="s1"></span><br></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s34">basic_</span><span class="s13">optional </span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional </span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s13"> rhs</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p67"><span class="s1"><i>Constraints</i>:</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s18">&lt;</span><span class="s1">T, </span><span class="s19">const</span><span class="s1"> U</span><span class="s18">&amp;&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1">,</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&amp;</span><span class="s1">, </span><span class="s19">const</span><span class="s1"> U</span><span class="s18">&amp;&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1">,</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- <i>converts-from-any-cvref</i></span><span class="s18">&lt;</span><span class="s1">T, optional</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&gt;</span><span class="s1"> is </span><span class="s47">false</span><span class="s1">,</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&amp;</span><span class="s1">, optional</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;&gt;</span><span class="s1"> is </span><span class="s47">false</span><span class="s1">,</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&amp;</span><span class="s1">, optional</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;&amp;&gt;</span><span class="s1"> is </span><span class="s47">false</span><span class="s1">,</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&amp;</span><span class="s1">, </span><span class="s19">const</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;&gt;</span><span class="s1"> is </span><span class="s47">false</span><span class="s1">, and</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&amp;</span><span class="s1">, </span><span class="s19">const</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;&amp;&gt;</span><span class="s1"> is </span><span class="s47">false</span><span class="s1">.</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: See Table</span></p>
<p class="p91"><span class="s74"></span><br></p>
<p class="p86"><span class="s2">Table — basic_optional operator=(const optional&lt;U&gt;&amp;) effects</span></p>
<table cellspacing="0" cellpadding="0" class="t1">
  <tbody>
    <tr>
      <td valign="middle" class="td1">
        <p class="p87"><span class="s1"><b><span class="Apple-converted-space">            </span></b></span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p86"><span class="s2"><b>*this contains a value</b></span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p86"><span class="s2"><b>*this does not contain a value</b></span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p85"><span class="s2"></span><br></p>
        <p class="p88"><span class="s2">rhs contains a value</span></p>
        <p class="p85"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p85"><span class="s1"></span><br></p>
        <p class="p88"><span class="s2">assigns *rhs to the contained value</span></p>
        <p class="p85"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p88"><span class="s72"><span class="Apple-converted-space"> </span></span><span class="s64">constructs the contained value by </span><span class="s1">uses-allocator construction with allocator alloc and </span><span class="s33">*</span><span class="s32">rhs</span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p88"><span class="s2">rhs does not contain a value</span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p85"><span class="s1"></span><br></p>
        <p class="p88"><span class="s2">Destroys the contained value by calling val-&gt;T::~T()</span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p88"><span class="s1">No additional effect</span></p>
      </td>
    </tr>
  </tbody>
</table>
<p class="p67"><span class="s44"><i>Postconditions</i>: rhs</span><span class="s45">.</span><span class="s44">has_value</span><span class="s52">()</span><span class="s44"> </span><span class="s45">==</span><span class="s44"> </span><span class="s53">this</span><span class="s45">-&gt;</span><span class="s44">has_value</span><span class="s52">()</span><span class="s44">.</span></p>
<p class="p67"><span class="s1"><i>Returns</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1">.</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: If any exception is thrown, the result of the expression </span><span class="s19">this</span><span class="s18">-&gt;</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> remains unchanged<a href="https://eel.is/c++draft/optional#assign-23.sentence-1"><span class="s43">.</span></a> If an exception is thrown during the call to T's constructor, the state of </span><span class="s18">*</span><span class="s1">rhs</span><span class="s18">.</span><span class="s1">val is determined by the exception safety guarantee of T's selected constructor If an exception is thrown during the call to T's assignment, the state of </span><span class="s18">*</span><span class="s1">val and </span><span class="s18">*</span><span class="s1">rhs</span><span class="s18">.</span><span class="s1">val is determined by the exception safety guarantee of T's assignment.</span></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p69"><span class="s1"><a href="https://eel.is/c++draft/optional#lib:operator=,optional_____">🔗<span class="s51"></span></a></span></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">=</span><span class="s14">(</span><span class="s13">optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;&amp;</span><span class="s13"> rhs</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p67"><span class="s1"><i>Constraints</i>:</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s18">&lt;</span><span class="s1">T, U</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1">,</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&amp;</span><span class="s1">, U</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1">,</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- <i>converts-from-any-cvref</i></span><span class="s18">&lt;</span><span class="s1">T, optional</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&gt;</span><span class="s1"> is </span><span class="s47">false</span><span class="s1">,</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&amp;</span><span class="s1">, optional</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;&gt;</span><span class="s1"> is </span><span class="s47">false</span><span class="s1">,</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&amp;</span><span class="s1">, optional</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;&amp;&gt;</span><span class="s1"> is </span><span class="s47">false</span><span class="s1">,</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&amp;</span><span class="s1">, </span><span class="s19">const</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;&gt;</span><span class="s1"> is </span><span class="s47">false</span><span class="s1">, and</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>- is_assignable_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&amp;</span><span class="s1">, </span><span class="s19">const</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;&amp;&gt;</span><span class="s1"> is </span><span class="s47">false</span></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p67"><span class="s1"><i>Effects</i>: See Table The result of the expression rhs</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> remains unchanged</span></p>
<p class="p86"><span class="s2">Table — basic_optional operator=(optional&lt;U&gt;&amp;&amp;) effects</span></p>
<table cellspacing="0" cellpadding="0" class="t1">
  <tbody>
    <tr>
      <td valign="middle" class="td1">
        <p class="p87"><span class="s1"><b><span class="Apple-converted-space">            </span></b></span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p86"><span class="s2"><b>*this contains a value</b></span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p86"><span class="s2"><b>*this does not contain a value</b></span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p85"><span class="s2"></span><br></p>
        <p class="p88"><span class="s2">rhs contains a value</span></p>
        <p class="p85"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p85"><span class="s1"></span><br></p>
        <p class="p88"><span class="s2">assigns std::move(*rhs) to the contained value</span></p>
        <p class="p85"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p88"><span class="s72"><span class="Apple-converted-space"> </span></span><span class="s64">constructs the contained value by </span><span class="s1">uses-allocator construction with allocator alloc and std::move(</span><span class="s33">*</span><span class="s32">rhs)</span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p88"><span class="s2">rhs does not contain a value</span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p85"><span class="s1"></span><br></p>
        <p class="p88"><span class="s2">Destroys the contained value by calling val-&gt;T::~T()</span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p88"><span class="s1">No additional effect</span></p>
      </td>
    </tr>
  </tbody>
</table>
<p class="p72"><span class="s1"><i>Postconditions</i>: rhs</span><span class="s33">.</span><span class="s1">has_value</span><span class="s37">()</span><span class="s1"> </span><span class="s33">==</span><span class="s1"> </span><span class="s27">this</span><span class="s33">-&gt;</span><span class="s1">has_value</span><span class="s37">()</span><span class="s1">.</span></p>
<p class="p67"><span class="s44"><i>Returns</i>: </span><span class="s45">*</span><span class="s53">this</span><span class="s44">.</span></p>
<p class="p67"><span class="s44"><i>Remarks</i>: If any exception is thrown, the result of the expression </span><span class="s53">this</span><span class="s45">-&gt;</span><span class="s44">has_value</span><span class="s52">()</span><span class="s44"> remains unchanged<a href="https://eel.is/c++draft/optional#assign-23.sentence-1"><span class="s1">.</span></a> If an exception is thrown during the call to T's constructor, the state of </span><span class="s45">*</span><span class="s44">rhs</span><span class="s45">.</span><span class="s44">val is determined by the exception safety guarantee of T's selected constructor If an exception is thrown during the call to T's assignment, the state of </span><span class="s45">*</span><span class="s44">val and </span><span class="s45">*</span><span class="s44">rhs</span><span class="s45">.</span><span class="s44">val is determined by the exception safety guarantee of T's assignment.</span></p>
<p class="p70"><span class="s1"></span><br></p>
<p class="p47"><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s18">...</span><span class="s1"> Args</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> T</span><span class="s18">&amp;</span><span class="s1"> emplace</span><span class="s14">(</span><span class="s1">Args</span><span class="s18">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p67"><span class="s1"><i>Mandates</i>: is_constructible_v</span><span class="s18">&lt;</span><span class="s1">T, Args</span><span class="s18">...&gt;</span><span class="s1"> is </span><span class="s47">true</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: Calls </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> </span><span class="s18">=</span><span class="s1"> nullopt<a href="https://eel.is/c++draft/optional#assign-30.sentence-1"><span class="s43">.</span></a> Then constructs the contained value by uses-allocator construction with allocator alloc and std</span><span class="s18"> :: </span><span class="s1">forward </span><span class="s18">&lt;</span><span class="s1">Args</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">args</span><span class="s14">)</span><span class="s18">…</span><span class="s1">.</span></p>
<p class="p67"><span class="s1"><i>Postconditions</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value.</span></p>
<p class="p67"><span class="s1"><i>Returns</i>: A reference to the new contained value.</span></p>
<p class="p67"><span class="s1"><i>Throws</i>: Any exception thrown by the selected constructor of T</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: If an exception is thrown during the call to T's constructor, </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> does not contain a value, and the previous </span><span class="s18">*</span><span class="s1">val (if any) has been destroyed.</span></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p66"><span class="s1"><a href="https://eel.is/c++draft/optional#assign-34.sentence-1"></a></span><br></p>
<p class="p47"><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> U, </span><span class="s19">class</span><span class="s18">...</span><span class="s1"> Args</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> T</span><span class="s18">&amp;</span><span class="s1"> emplace</span><span class="s14">(</span><span class="s1">initializer_list</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s1"> il, Args</span><span class="s18">&amp;&amp;...</span><span class="s1"> args</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p67"><span class="s1"><i>Constraints</i>: is_constructible_v</span><span class="s18">&lt;</span><span class="s1">T, initializer_list</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;</span><span class="s1">, Args</span><span class="s18">...&gt;</span><span class="s1"> is </span><span class="s47">true</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: Calls </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> </span><span class="s18">=</span><span class="s1"> nullopt<a href="https://eel.is/c++draft/optional#assign-36.sentence-1"><span class="s43">.</span></a> Then constructs the contained value by uses-allocator construction with allocator alloc and il, std</span><span class="s18"> :: </span><span class="s1">forward</span><span class="s18">&lt;</span><span class="s1">Args</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">args</span><span class="s14">)</span><span class="s18">…</span><span class="s1">.</span></p>
<p class="p67"><span class="s1"><i>Postconditions</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value</span></p>
<p class="p67"><span class="s1"><i>Returns</i>: A reference to the new contained value</span></p>
<p class="p67"><span class="s1"><i>Throws</i>: Any exception thrown by the selected constructor of T</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: If an exception is thrown during the call to T's constructor, </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> does not contain a value, and the previous </span><span class="s18">*</span><span class="s1">val (if any) has been destroyed.</span></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p66"><span class="s1"></span><br></p>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06"><span class="s44"><b>22.5.x.5</b></span><span class="s49"><b> Swap</b></span><span class="s44"><b> [optional.swap]</b></span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06; min-height: 16.0px"><span class="s1"><b></b></span><br></h4>
<p class="p47"><span class="s19">constexpr</span><span class="s1"> </span><span class="s19">void</span><span class="s1"> swap</span><span class="s14">(</span><span class="s75">basic_</span><span class="s32">optional</span><span class="s18">&amp;</span><span class="s1"> rhs</span><span class="s14">)</span><span class="s1"> </span><span class="s19">noexcept</span><span class="s14">(</span><span class="s1"><i>see below</i></span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p67"><span class="s1"><i>Mandates</i>: is_move_constructible_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span></p>
<p class="p67"><span class="s1"><i>Preconditions</i>: T meets the <i>Cpp17Swappable</i> requirements (<a href="https://eel.is/c++draft/swappable.requirements"><span class="s16">[swappable.requirements]</span></a>)</span></p>
<p class="p82"><span class="s58"><i>Effects</i>: </span><span class="s1">If allocator_traits</span><span class="s31">&lt;</span><span class="s1">Allocator</span><span class="s31">&gt;::</span><span class="s1">propagate_on_container_swap</span><span class="s31">::</span><span class="s1">value is </span><span class="s59">true</span><span class="s1">, then Allocator shall meet the <i>Cpp17Swappable</i> requirements and the allocators of *this and res shall also be exchanged by calling swap as described in <a href="https://eel.is/c++draft/swappable.requirements"><span class="s76">[swappable.requirements]</span></a><a href="https://eel.is/c++draft/container.reqmts#65.sentence-3"><span class="s69">.</span></a> Otherwise, the allocators shall not be swapped, and the behavior is undefined unless *this</span><span class="s31">.</span><span class="s1">get_allocator</span><span class="s41">()</span><span class="s1"> </span><span class="s31">==</span><span class="s1"> rhs</span><span class="s31">.</span><span class="s1">get_allocator</span><span class="s41">()</span><span class="s1">. Then, s</span><span class="s58">ee Tablex</span></p>
<p class="p63"><span class="s1"></span><br></p>
<p class="p86"><span class="s2">Table — basic_optional swap(basic_optional&lt;U&gt;&amp;) effects</span></p>
<table cellspacing="0" cellpadding="0" class="t1">
  <tbody>
    <tr>
      <td valign="middle" class="td1">
        <p class="p87"><span class="s1"><b><span class="Apple-converted-space">            </span></b></span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p86"><span class="s2"><b>*this contains a value</b></span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p86"><span class="s2"><b>*this does not contain a value</b></span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p85"><span class="s2"></span><br></p>
        <p class="p88"><span class="s2">rhs contains a value</span></p>
        <p class="p85"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p85"><span class="s1"></span><br></p>
        <p class="p29"><span class="s1">calls swap</span><span class="s14">(</span><span class="s18">*</span><span class="s14">(</span><span class="s18">*</span><span class="s19">this</span><span class="s14">)</span><span class="s1">, </span><span class="s18">*</span><span class="s1">rhs</span><span class="s14">)</span></p>
        <p class="p85"><span class="s1"></span><br></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p29"><span class="s66"><span class="Apple-converted-space"> </span></span><span class="s77">constructs the contained value in *this by </span><span class="s13">uses-allocator construction with allocator alloc and </span><span class="s1">std</span><span class="s18"> :: </span><span class="s1">move</span><span class="s14">(</span><span class="s18">*</span><span class="s1">rhs</span><span class="s14">)</span><span class="s1">, followed by rhs</span><span class="s18">.</span><span class="s1">val</span><span class="s18">-&gt;</span><span class="s1">T</span><span class="s18"> :: ~</span><span class="s1">T</span><span class="s14">()</span><span class="s1">; postcondition is that </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value and rhs does not contain a value</span></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p88"><span class="s2">rhs does not contain a value</span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p29"><span class="s77">constructs the contained value</span><span class="s1"> of rhs </span><span class="s77">by </span><span class="s13">uses-allocator construction with allocator alloc and </span><span class="s1"> std</span><span class="s18"> :: </span><span class="s1">move</span><span class="s14">(</span><span class="s18">*</span><span class="s14">(</span><span class="s18">*</span><span class="s19">this</span><span class="s14">))</span><span class="s1">, followed by val</span><span class="s18">-&gt;</span><span class="s1">T</span><span class="s18"> :: ~</span><span class="s1">T</span><span class="s14">()</span><span class="s1">; postcondition is that </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> does not contain a value and rhs contains a value</span></p>
      </td>
      <td valign="middle" class="td3">
        <p class="p88"><span class="s1">No additional effect</span></p>
      </td>
    </tr>
  </tbody>
</table>
<p class="p67"><span class="s1"><i>Throws</i>: Any exceptions thrown by the operations in the relevant part of Table.</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: The exception specification is equivalent to:</span></p>
<p class="p47"><span class="s1">is_nothrow_move_constructible_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s18">&amp;&amp;</span><span class="s1"> is_nothrow_swappable_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span></p>
<p class="p67"><span class="s1">If any exception is thrown, the results of the expressions </span><span class="s19">this</span><span class="s18">-&gt;</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> and rhs</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> remain unchanged<a href="https://eel.is/c++draft/optional#swap-6.sentence-1"><span class="s43">.</span></a> If an exception is thrown during the call to function swap, the state of </span><span class="s18">*</span><span class="s1">val and </span><span class="s18">*</span><span class="s1">rhs</span><span class="s18">.</span><span class="s1">val is determined by the exception safety guarantee of swap for lvalues of T. If an exception is thrown during the call to T's move constructor, the state of </span><span class="s18">*</span><span class="s1">val and </span><span class="s18">*</span><span class="s1">rhs</span><span class="s18">.</span><span class="s1">val is determined by the exception safety guarantee of T's selected move constructor.</span></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p92"><span class="s1"><b>22.5.x.6 Allocator [</b></span><span class="s78"><b>basic.optional.all]</b></span></p>
<p class="p77"><span class="s1"></span><br></p>
<p class="p40"><span class="s1">allocator_type get_allocator</span><span class="s41">()</span><span class="s1"> </span><span class="s42">const</span><span class="s1">;</span></p>
<p class="p93"><span class="s1"><i>Returns</i>: A copy of the Allocator that was passed to the object's constructor or, if that allocator has been replaced, a copy of the most recent replacement.</span></p>
<p class="p81"><span class="s1"><b></b></span><br></p>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06"><span class="s44"><b>22.5.x.7</b></span><span class="s49"><b> Observers</b></span><span class="s44"><b> [basic.optional.observe]</b></span></h4>
<p class="p46"><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> T</span><span class="s18">*</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">-&gt;</span><span class="s14">()</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p46"><span class="s1">constexpr</span><span class="s13"> T</span><span class="s18">*</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">-&gt;</span><span class="s14">()</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p67"><span class="s1"><i>Preconditions</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value</span></p>
<p class="p67"><span class="s1"><i>Returns</i>: val.</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: These functions are constexpr functions.</span></p>
<p class="p68"><span class="s1"></span><br></p>
<p class="p46"><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">*</span><span class="s14">()</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p46"><span class="s1">constexpr</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">*</span><span class="s14">()</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p67"><span class="s1"><i>Preconditions</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value.</span></p>
<p class="p67"><span class="s1"><i>Returns</i>: </span><span class="s18">*</span><span class="s1">val.</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: These functions are constexpr functions.</span></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p46"><span class="s1">constexpr</span><span class="s13"> T</span><span class="s18">&amp;&amp;</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">*</span><span class="s14">()</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p46"><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;&amp;</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">*</span><span class="s14">()</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p67"><span class="s1"><i>Preconditions</i>: </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value.</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: Equivalent to: </span><span class="s19">return</span><span class="s1"> std</span><span class="s18"> :: </span><span class="s1">move</span><span class="s14">(</span><span class="s18">*</span><span class="s1">val</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p46"><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">explicit</span><span class="s13"> </span><span class="s1">operator</span><span class="s13"> </span><span class="s1">bool</span><span class="s14">()</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p67"><span class="s1"><i>Returns</i>: </span><span class="s47">true</span><span class="s1"> if and only if </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: This function is a constexpr function<a href="https://eel.is/c++draft/optional#observe-10.sentence-1"><span class="s43">.</span></a></span></p>
<p class="p46"><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> has_value</span><span class="s14">()</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p67"><span class="s1"><i>Returns</i>: </span><span class="s47">true</span><span class="s1"> if and only if </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value.</span></p>
<p class="p67"><span class="s1"><i>Remarks</i>: This function is a constexpr function.</span></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p46"><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13"> value</span><span class="s14">()</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13">;</span></p>
<p class="p47"><span class="s19">constexpr</span><span class="s1"> T</span><span class="s18">&amp;</span><span class="s1"> value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">&amp;</span><span class="s1">;</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: Equivalent to:</span></p>
<p class="p47"><span class="s19"><span class="Apple-tab-span">	</span>return</span><span class="s1"> has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">?</span><span class="s1"> </span><span class="s18">*</span><span class="s1">val </span><span class="s18">:</span><span class="s1"> </span><span class="s19">throw</span><span class="s1"> bad_optional_access</span><span class="s14">()</span><span class="s1">;</span></p>
<p class="p70"><span class="s1"></span><br></p>
<p class="p47"><span class="s19">constexpr</span><span class="s1"> T</span><span class="s18">&amp;&amp;</span><span class="s1"> value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">&amp;&amp;</span><span class="s1">;</span></p>
<p class="p46"><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;&amp;</span><span class="s13"> value</span><span class="s14">()</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13">;</span></p>
<p class="p67"><span class="s17"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Effects</i>: Equivalent to:</span></p>
<p class="p47"><span class="s19">return</span><span class="s1"> has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">?</span><span class="s1"> std</span><span class="s18">::</span><span class="s1">move</span><span class="s14">(</span><span class="s18">*</span><span class="s1">val</span><span class="s14">)</span><span class="s1"> </span><span class="s18">:</span><span class="s1"> </span><span class="s19">throw</span><span class="s1"> bad_optional_access</span><span class="s14">()</span><span class="s1">;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> T value_or</span><span class="s14">(</span><span class="s13">U</span><span class="s18">&amp;&amp;</span><span class="s13"> v</span><span class="s14">)</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13">;</span></p>
<p class="p67"><span class="s1"><i>Mandates</i>: is_copy_constructible_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s18">&amp;&amp;</span><span class="s1"> is_convertible_v</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&amp;&amp;</span><span class="s1">, T</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: Equivalent to:</span></p>
<p class="p47"><span class="s19">return</span><span class="s1"> has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">?</span><span class="s1"> </span><span class="s18">**</span><span class="s19">this</span><span class="s1"> </span><span class="s18">:</span><span class="s1"> </span><span class="s19">static_cast</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">std</span><span class="s18">::</span><span class="s1">forward</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">))</span><span class="s1">;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> T value_or</span><span class="s14">(</span><span class="s13">U</span><span class="s18">&amp;&amp;</span><span class="s13"> v</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13">;</span></p>
<p class="p67"><span class="s1"><i>Mandates</i>: is_move_constructible_v</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s18">&amp;&amp;</span><span class="s1"> is_convertible_v</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&amp;&amp;</span><span class="s1">, T</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true</span><span class="s1">.</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: Equivalent to:</span></p>
<p class="p47"><span class="s19">return</span><span class="s1"> has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">?</span><span class="s1"> std</span><span class="s18">::</span><span class="s1">move</span><span class="s14">(</span><span class="s18">**</span><span class="s19">this</span><span class="s14">)</span><span class="s1"> </span><span class="s18">:</span><span class="s1"> </span><span class="s19">static_cast</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">std</span><span class="s18">::</span><span class="s1">forward</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">v</span><span class="s14">))</span><span class="s1">;</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p45"><span class="s44"><b>22.5.x.8</b></span><span class="s15"> </span><span class="s13"><b>Monadic operations </b></span><span class="s44"><b>[basic.optional.monadic]</b></span></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> and_then</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13">;</span></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> and_then</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13">;</span></p>
<p class="p67"><span class="s1">Let U be invoke_result_t</span><span class="s18">&lt;</span><span class="s1">F, </span><span class="s19">decltype</span><span class="s14">(</span><span class="s18">*</span><span class="s1">val</span><span class="s14">)</span><span class="s18">&gt;</span></p>
<p class="p67"><span class="s1"><i>Mandates</i>: remove_cvref_t</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s1"> is a specialization of basic_optional.</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: Equivalent to:</span></p>
<p class="p46"><span class="s1"><span class="Apple-tab-span">	</span>if</span><span class="s13"> </span><span class="s14">(</span><span class="s18">*</span><span class="s1">this</span><span class="s14">)</span><span class="s13"> </span><span class="s14">{</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s19">return</span><span class="s1"> invoke</span><span class="s14">(</span><span class="s1">std</span><span class="s18">::</span><span class="s1">forward</span><span class="s18">&lt;</span><span class="s1">F</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">f</span><span class="s14">)</span><span class="s1">, </span><span class="s18">*</span><span class="s1">val</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p46"><span class="s14"><span class="Apple-tab-span">	</span>}</span><span class="s13"> </span><span class="s1">else</span><span class="s13"> </span><span class="s14">{</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span> </span></span><span class="s19">return</span><span class="s1"> remove_cvref_t</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s14">()</span><span class="s1">;</span></p>
<p class="p61"><span class="s1"><span class="Apple-tab-span">	</span>}</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> and_then</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13">;</span></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> and_then</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13">;</span></p>
<p class="p67"><span class="s1">Let U be invoke_result_t</span><span class="s18">&lt;</span><span class="s1">F, </span><span class="s19">decltype</span><span class="s14">(</span><span class="s1">std</span><span class="s18"> :: </span><span class="s1">move</span><span class="s14">(</span><span class="s18">*</span><span class="s1">val</span><span class="s14">))</span><span class="s18">&gt;</span></p>
<p class="p67"><span class="s1"><i>Mandates</i>: remove_cvref_t</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s1"> is a specialization of </span><span class="s44">basic_optional</span><span class="s1">.</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: Equivalent to:</span></p>
<p class="p46"><span class="s1"><span class="Apple-tab-span">	</span>if</span><span class="s13"> </span><span class="s14">(</span><span class="s18">*</span><span class="s1">this</span><span class="s14">)</span><span class="s13"> </span><span class="s14">{</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s19">return</span><span class="s1"> invoke</span><span class="s14">(</span><span class="s1">std</span><span class="s18">::</span><span class="s1">forward</span><span class="s18">&lt;</span><span class="s1">F</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">f</span><span class="s14">)</span><span class="s1">, std</span><span class="s18">::</span><span class="s1">move</span><span class="s14">(</span><span class="s18">*</span><span class="s1">val</span><span class="s14">))</span><span class="s1">;</span></p>
<p class="p46"><span class="s14"><span class="Apple-tab-span">	</span>}</span><span class="s13"> </span><span class="s1">else</span><span class="s13"> </span><span class="s14">{</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span> </span></span><span class="s19">return</span><span class="s1"> remove_cvref_t</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;</span><span class="s14">()</span><span class="s1">;</span></p>
<p class="p61"><span class="s1"><span class="Apple-tab-span">	</span>}</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> transform</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13">;</span></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> transform</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13">;</span></p>
<p class="p67"><span class="s1">Let U be remove_cv_t</span><span class="s18">&lt;</span><span class="s1">invoke_result_t</span><span class="s18">&lt;</span><span class="s1">F, </span><span class="s19">decltype</span><span class="s14">(</span><span class="s18">*</span><span class="s1">val</span><span class="s14">)</span><span class="s18">&gt;&gt;</span></p>
<p class="p67"><span class="s1"><i>Mandates</i>: U is a non-array object type other than in_place_t or nullopt_t<a href="https://eel.is/c++draft/optional#monadic-8.sentence-1"><span class="s43">.</span></a> The declaration</span></p>
<p class="p47"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>U u</span><span class="s14">(</span><span class="s1">invoke</span><span class="s14">(</span><span class="s1">std</span><span class="s18">::</span><span class="s1">forward</span><span class="s18">&lt;</span><span class="s1">F</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">f</span><span class="s14">)</span><span class="s1">, </span><span class="s18">*</span><span class="s1">val</span><span class="s14">))</span><span class="s1">;</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>is well-formed for some invented variable u.</span></p>
<p class="p47"><span class="s1">[<i>Note </i></span><span class="s12"><i>1</i></span><span class="s1">:</span><span class="s79"> </span><span class="s1">There is no requirement that U is movable (<a href="https://eel.is/c++draft/dcl.init.general"><span class="s80">[dcl.init.general]</span></a>)<a href="https://eel.is/c++draft/optional#monadic-8.sentence-3"><span class="s81">.</span></a> — <i>end note</i>]</span></p>
<p class="p67"><span class="s1"><i>Returns</i>: If </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value, a </span><span class="s44">basic_optional</span><span class="s18">&lt;</span><span class="s1">U, Allocator</span><span class="s18">&gt;</span><span class="s1"> object whose contained value is direct-non-list-initialized with invoke</span><span class="s14">(</span><span class="s1">std</span><span class="s18">::</span><span class="s1">forward</span><span class="s18">&lt;</span><span class="s1">F</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">f</span><span class="s14">)</span><span class="s1">, </span><span class="s18">*</span><span class="s1">val</span><span class="s14">)</span><span class="s1">; otherwise, optional</span><span class="s18">&lt;</span><span class="s1">U, Allocator</span><span class="s18">&gt;</span><span class="s14">().</span></p>
<p class="p66"><span class="s1"></span><br></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> transform</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13">;</span></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">auto</span><span class="s13"> transform</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13">;</span></p>
<p class="p67"><span class="s1">Let U be remove_cv_t</span><span class="s18">&lt;</span><span class="s1">invoke_result_t</span><span class="s18">&lt;</span><span class="s1">F, </span><span class="s19">decltype</span><span class="s14">(</span><span class="s1">std</span><span class="s18"> :: </span><span class="s1">move</span><span class="s14">(</span><span class="s18">*</span><span class="s1">val</span><span class="s14">))</span><span class="s18">&gt;&gt;</span></p>
<p class="p67"><span class="s1"><i>Mandates</i>: U is a non-array object type other than in_place_t or nullopt_t<a href="https://eel.is/c++draft/optional#monadic-11.sentence-1"><span class="s43">.</span></a> The declaration</span></p>
<p class="p47"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>U u</span><span class="s14">(</span><span class="s1">invoke</span><span class="s14">(</span><span class="s1">std</span><span class="s18">::</span><span class="s1">forward</span><span class="s18">&lt;</span><span class="s1">F</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">f</span><span class="s14">)</span><span class="s1">, std</span><span class="s18">::</span><span class="s1">move</span><span class="s14">(</span><span class="s18">*</span><span class="s1">val</span><span class="s14">)))</span><span class="s1">;</span></p>
<p class="p67"><span class="s1"><span class="Apple-tab-span">	</span>is well-formed for some invented variable u.</span></p>
<p class="p47"><span class="s1">[<i>Note </i></span><span class="s12"><i>2</i></span><span class="s1">:</span><span class="s79"> </span><span class="s1">There is no requirement that U is movable (<a href="https://eel.is/c++draft/dcl.init.general"><span class="s80">[dcl.init.general]</span></a>)<a href="https://eel.is/c++draft/optional#monadic-11.sentence-3"><span class="s81">.</span></a> — <i>end note</i>]</span></p>
<p class="p67"><span class="s1"><i>Returns</i>: If </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value, a </span><span class="s46">basic_optional</span><span class="s45">&lt;</span><span class="s44">U, Allocator</span><span class="s45">&gt;</span><span class="s1"> object whose contained value is direct-non-list-initialized with invoke</span><span class="s14">(</span><span class="s1">std</span><span class="s18">::</span><span class="s1">forward</span><span class="s18">&lt;</span><span class="s1">F</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">f</span><span class="s14">)</span><span class="s1">, std</span><span class="s18">::</span><span class="s1">move</span><span class="s14">(</span><span class="s18">*</span><span class="s1">val</span><span class="s14">))</span><span class="s1">; otherwise, </span><span class="s46">basic_optional</span><span class="s45">&lt;</span><span class="s44">U, Allocator</span><span class="s45">&gt;</span><span class="s14">().</span></p>
<p class="p66"><span class="s1"><a href="https://eel.is/c++draft/optional#monadic-12.sentence-1"></a></span><br></p>
<p class="p46"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> F</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> optional or_else</span><span class="s14">(</span><span class="s13">F</span><span class="s18">&amp;&amp;</span><span class="s13"> f</span><span class="s14">)</span><span class="s13"> </span><span class="s1">const</span><span class="s13"> </span><span class="s18">&amp;</span><span class="s13">;</span></p>
<p class="p67"><span class="s1"><i>Constraints</i>: F models <a href="https://eel.is/c++draft/concept.invocable#concept:invocable"><span class="s16">invocable</span></a></span><span class="s18">&lt;&gt;</span><span class="s1"> and T models <a href="https://eel.is/c++draft/concept.copyconstructible#concept:copy_constructible"><span class="s16">copy_constructible</span></a></span></p>
<p class="p67"><span class="s1"><i>Mandates</i>: is_same_v</span><span class="s18">&lt;</span><span class="s1">remove_cvref_t</span><span class="s18">&lt;</span><span class="s1">invoke_result_t</span><span class="s18">&lt;</span><span class="s1">F</span><span class="s18">&gt;&gt;</span><span class="s1">, basic_optional</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true.</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: Equivalent to:</span></p>
<p class="p46"><span class="s1"><span class="Apple-tab-span">	</span>if</span><span class="s13"> </span><span class="s14">(</span><span class="s18">*</span><span class="s1">this</span><span class="s14">)</span><span class="s13"> </span><span class="s14">{</span></p>
<p class="p46"><span class="s13"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s1">return</span><span class="s13"> </span><span class="s18">*</span><span class="s1">this</span><span class="s13">;</span></p>
<p class="p46"><span class="s14"><span class="Apple-tab-span">	</span>}</span><span class="s13"> </span><span class="s1">else</span><span class="s13"> </span><span class="s14">{</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span> </span></span><span class="s19">return</span><span class="s1"> std</span><span class="s18">::</span><span class="s1">forward</span><span class="s18">&lt;</span><span class="s1">F</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">f</span><span class="s14">)()</span><span class="s1">;</span></p>
<p class="p61"><span class="s1"><span class="Apple-tab-span">	</span>}</span></p>
<p class="p69"><span class="s1"><a href="https://eel.is/c++draft/optional#lib:or_else,optional_">🔗<span class="s51"></span></a></span></p>
<p class="p47"><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> F</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> optional or_else</span><span class="s14">(</span><span class="s1">F</span><span class="s18">&amp;&amp;</span><span class="s1"> f</span><span class="s14">)</span><span class="s1"> </span><span class="s18">&amp;&amp;</span><span class="s1">;</span></p>
<p class="p67"><span class="s1"><i>Constraints</i>: F models <a href="https://eel.is/c++draft/concept.invocable#concept:invocable"><span class="s16">invocable</span></a></span><span class="s18">&lt;&gt;</span><span class="s1"> and T models <a href="https://eel.is/c++draft/concept.moveconstructible#concept:move_constructible"><span class="s16">move_constructible</span></a><a href="https://eel.is/c++draft/optional#monadic-16.sentence-1"><span class="s43">.</span></a></span></p>
<p class="p67"><span class="s1"><i>Mandates</i>: is_same_v</span><span class="s18">&lt;</span><span class="s1">remove_cvref_t</span><span class="s18">&lt;</span><span class="s1">invoke_result_t</span><span class="s18">&lt;</span><span class="s1">F</span><span class="s18">&gt;&gt;</span><span class="s1">, </span><span class="s44">basic_optional</span><span class="s18">&gt;</span><span class="s1"> is </span><span class="s47">true.</span></p>
<p class="p67"><span class="s1"><i>Effects</i>: Equivalent to:</span></p>
<p class="p46"><span class="s1"><span class="Apple-tab-span">	</span>if</span><span class="s13"> </span><span class="s14">(</span><span class="s18">*</span><span class="s1">this</span><span class="s14">)</span><span class="s13"> </span><span class="s14">{</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s19">return</span><span class="s1"> std</span><span class="s18">::</span><span class="s1">move</span><span class="s14">(</span><span class="s18">*</span><span class="s19">this</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p46"><span class="s14"><span class="Apple-tab-span">	</span>}</span><span class="s13"> </span><span class="s1">else</span><span class="s13"> </span><span class="s14">{</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s19">return</span><span class="s1"> std</span><span class="s18">::</span><span class="s1">forward</span><span class="s18">&lt;</span><span class="s1">F</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">f</span><span class="s14">)()</span><span class="s1">;</span></p>
<p class="p61"><span class="s1"><span class="Apple-tab-span">	</span>}</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p48"><span class="s1"></span><br></p>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06"><span class="s44"><b>22.5.x.9</b></span><span class="s49"><b> Modifiers</b></span><span class="s44"><b> [basic.optional.mod]</b></span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #0000e9; -webkit-text-stroke: #0000e9; background-color: #21ff06; min-height: 16.0px"><span class="s1"><b></b></span><br></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #0a4d69; -webkit-text-stroke: #0a4d69; background-color: #21ff06"><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">void</span><span class="s13"> reset</span><span class="s14">()</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; -webkit-text-stroke: #000000; background-color: #21ff06"><span class="s1"><i>Effects</i>: If </span><span class="s18">*</span><span class="s19">this</span><span class="s1"> contains a value, calls val</span><span class="s18">-&gt;</span><span class="s1">T</span><span class="s18"> :: ~</span><span class="s1">T</span><span class="s14">()</span><span class="s1"> to destroy the contained value; otherwise no effect.</span></h4>
<p class="p94"><span class="s21"><i>Postconditions</i>: </span><span class="s24">*</span><span class="s22">this</span><span class="s21"> does not contain a value.</span></p>
<p class="p95"><span class="s1"><b></b></span><br></p>
<p class="p96"><span class="s1"><b>Modify 22.5.6</b></span><span class="s13"><b> Relational operators</b></span><span class="s1"><b> </b><a href="https://eel.is/c++draft/optional.relops"><span class="s82"><b>[optional.relops]</b></span></a></span></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">==</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> x, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s13"> y</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p98"><span class="s22">template</span><span class="s24">&lt;</span><span class="s22">class</span><span class="s21"> T, </span><span class="s28">AllocatorT , </span><span class="s22">class</span><span class="s21"> U, AllocatorU</span><span class="s24">&gt;</span><span class="s21"> </span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">bool</span><span class="s21"> </span><span class="s22">operator</span><span class="s24">==</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_optional</span><span class="s24">&lt;</span><span class="s21">T, AllocatorT</span><span class="s24">&gt;&amp;</span><span class="s21"> x, </span><span class="s22">const</span><span class="s21"> basic_optional</span><span class="s24">&lt;</span><span class="s21">U, AllocatorU</span><span class="s24">&gt;&amp;</span><span class="s21"> y</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression </span><span class="s18">*</span><span class="s1">x </span><span class="s18">==</span><span class="s1"> </span><span class="s18">*</span><span class="s1">y is well-formed and its result is convertible to </span><span class="s19">bool<a href="https://eel.is/c++draft/optional#relops-1.sentence-1"><span class="s49">.</span></a></span></p>
<p class="p99"><span class="s1">…</span></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">!=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> x, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s13"> y</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p98"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, AllocatorT , </span><span class="s83">class</span><span class="s21"> U, AllocatorU</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">!=</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">T, AllocatorT</span><span class="s67">&gt;&amp;</span><span class="s21"> x, </span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">U, AllocatorU</span><span class="s67">&gt;&amp;</span><span class="s21"> y</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression </span><span class="s18">*</span><span class="s1">x </span><span class="s18">!=</span><span class="s1"> </span><span class="s18">*</span><span class="s1">y is well-formed and its result is convertible to </span><span class="s19">bool</span></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> x, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s13"> y</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p98"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, AllocatorT , </span><span class="s83">class</span><span class="s21"> U, AllocatorU</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">&lt;</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">T, AllocatorT</span><span class="s67">&gt;&amp;</span><span class="s21"> x, </span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">U, AllocatorU</span><span class="s67">&gt;&amp;</span><span class="s21"> y</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: </span><span class="s18">*</span><span class="s1">x </span><span class="s18">&lt;</span><span class="s1"> </span><span class="s18">*</span><span class="s1">y is well-formed and its result is convertible to </span><span class="s19">bool</span></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p100"><span class="s1"></span><br></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> x, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s13"> y</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, AllocatorT , </span><span class="s83">class</span><span class="s21"> U, AllocatorU</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">&gt;</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">T, AllocatorT</span><span class="s67">&gt;&amp;</span><span class="s21"> x, </span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">U, AllocatorU</span><span class="s67">&gt;&amp;</span><span class="s21"> y</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression </span><span class="s18">*</span><span class="s1">x </span><span class="s18">&gt;</span><span class="s1"> </span><span class="s18">*</span><span class="s1">y is well-formed and its result is convertible to </span><span class="s19">bool</span><span class="s1">.</span></p>
<p class="p102"><span class="s1"></span><br></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> x, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s13"> y</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, AllocatorT , </span><span class="s83">class</span><span class="s21"> U, AllocatorU</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">&lt;=</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">T, AllocatorT</span><span class="s67">&gt;&amp;</span><span class="s21"> x, </span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">U, AllocatorU</span><span class="s67">&gt;&amp;</span><span class="s21"> y</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression </span><span class="s18">*</span><span class="s1">x </span><span class="s18">&lt;=</span><span class="s1"> </span><span class="s18">*</span><span class="s1">y is well-formed and its result is convertible to </span><span class="s19">bool<a href="https://eel.is/c++draft/optional#relops-13.sentence-1"><span class="s49">.</span></a></span></p>
<p class="p102"><span class="s1"></span><br></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> x, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s13"> y</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, AllocatorT , </span><span class="s83">class</span><span class="s21"> U, AllocatorU</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">&gt;=</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">T, AllocatorT</span><span class="s67">&gt;&amp;</span><span class="s21"> x, </span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">U, AllocatorU</span><span class="s67">&gt;&amp;</span><span class="s21"> y</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p98"><span class="s1">…</span></p>
<p class="p103"><span class="s1"></span><br></p>
<p class="p104"><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s13"> T, <a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable_with"><span class="s23">three_way_comparable_with</span></a></span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;</span><span class="s13"> U</span><span class="s18">&gt;</span></p>
<p class="p98"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s19">constexpr</span><span class="s1"> compare_three_way_result_t</span><span class="s18">&lt;</span><span class="s1">T, U</span><span class="s18">&gt;</span></p>
<p class="p98"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">operator</span><span class="s18">&lt;=&gt;</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&amp;</span><span class="s1"> x, </span><span class="s19">const</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">U</span><span class="s18">&gt;&amp;</span><span class="s1"> y</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p55"><span class="s27">template</span><span class="s33">&lt;</span><span class="s27">class</span><span class="s1"> T, AllocatorT , <a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable_with"><span class="s80">three_way_comparable_with</span></a></span><span class="s18">&lt;</span><span class="s26">T</span><span class="s18">&gt;</span><span class="s26"> U</span><span class="s1"> AllocatorU</span><span class="s33">&gt;</span><span class="s1"><span class="Apple-converted-space"> </span></span><span class="s26"> <span class="Apple-converted-space"> </span></span></p>
<p class="p47"><span class="s19">constexpr</span><span class="s1"> compare_three_way_result_t</span><span class="s18">&lt;</span><span class="s1">T, U</span><span class="s18">&gt;</span></p>
<p class="p101"><span class="s28"><span class="Apple-converted-space">    </span></span><span class="s22">operator</span><span class="s24">&lt;=&gt;</span><span class="s25">(</span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">T, AllocatorT</span><span class="s67">&gt;&amp;</span><span class="s21"> x, </span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">U, AllocatorU</span><span class="s67">&gt;&amp;</span><span class="s21"> y</span><span class="s25">)</span><span class="s28">;</span></p>
<p class="p94"><span class="s1"><i>Returns</i>: If x </span><span class="s18">&amp;&amp;</span><span class="s1"> y, </span><span class="s18">*</span><span class="s1">x </span><span class="s18">&lt;=&gt;</span><span class="s1"> </span><span class="s18">*</span><span class="s1">y; otherwise x</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">&lt;=&gt;</span><span class="s1"> y</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span></p>
<p class="p102"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; -webkit-text-stroke: #000000"><span class="s12"><b>Modify </b><a href="https://eel.is/c++draft/optional#nullops"><span class="s85"><b>22.5.7</b></span></a></span><span class="s1"><b> Comparison with nullopt</b></span></h3>
<p class="p106"><span class="s1"><a href="https://eel.is/c++draft/optional.nullops"><b>[optional.nullops]</b><span class="s82"><b></b></span></a></span></p>
<p class="p107"><span class="s1"></span><br></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">==</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> x, nullopt_t</span><span class="s14">)</span><span class="s13"> </span><span class="s1">noexcept</span><span class="s13">;</span></p>
<p class="p98"><span class="s22">template</span><span class="s24">&lt;</span><span class="s22">class</span><span class="s21"> T, class Allocator</span><span class="s24">&gt;</span><span class="s21"> </span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">bool</span><span class="s21"> </span><span class="s22">operator</span><span class="s24">==</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_optional</span><span class="s24">&lt;</span><span class="s21">T, Allocator</span><span class="s24">&gt;&amp;</span><span class="s21"> x, nullopt_t</span><span class="s25">)</span><span class="s21"> </span><span class="s22">noexcept</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Returns</i>: </span><span class="s18">!</span><span class="s1">x.</span></p>
<p class="p108"><span class="s1"></span><br></p>
<p class="p98"><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> T</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">constexpr</span><span class="s1"> strong_ordering </span><span class="s19">operator</span><span class="s18">&lt;=&gt;</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&amp;</span><span class="s1"> x, nullopt_t</span><span class="s14">)</span><span class="s1"> </span><span class="s19">noexcept</span><span class="s1">;</span></p>
<p class="p55"><span class="s27">template</span><span class="s33">&lt;</span><span class="s27">class</span><span class="s1"> T, class Allocator</span><span class="s33">&gt;</span><span class="s1"> </span><span class="s27">constexpr</span><span class="s1"> </span><span class="s26">strong_ordering</span><span class="s1"> </span><span class="s27">operator&lt;</span><span class="s33">==&gt;</span><span class="s37">(</span><span class="s27">const</span><span class="s1"> basic_optional</span><span class="s33">&lt;</span><span class="s1">T, Allocator</span><span class="s33">&gt;&amp;</span><span class="s1"> x, nullopt_t</span><span class="s37">)</span><span class="s1"> </span><span class="s27">noexcept</span><span class="s1">;</span></p>
<p class="p94"><span class="s1"><i>Returns</i>: x</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">&lt;=&gt;</span><span class="s1"> </span><span class="s47">false</span></p>
<p class="p102"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s1"><b>Modify </b><a href="https://eel.is/c++draft/optional#comp.with.t"><span class="s82"><b>22.5.8</b></span></a></span><span class="s13"><b> Comparison with T</b></span><span class="s1"><b> </b><a href="https://eel.is/c++draft/optional.comp.with.t"><span class="s82"><b>[optional.comp.with.t]</b></span></a></span></h3>
<p class="p107"><span class="s1"></span><br></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">==</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> x, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s13"> v</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p98"><span class="s22">template</span><span class="s24">&lt;</span><span class="s22">class</span><span class="s21"> T, class Allocator, </span><span class="s22">class</span><span class="s21"> U</span><span class="s24">&gt;</span><span class="s21"> </span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">bool</span><span class="s21"> </span><span class="s22">operator</span><span class="s24">==</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_optional</span><span class="s24">&lt;</span><span class="s21">T, Allocator</span><span class="s24">&gt;&amp;</span><span class="s21"> x, </span><span class="s22">const</span><span class="s21"> U</span><span class="s24">&amp;</span><span class="s21"> v</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression </span><span class="s18">*</span><span class="s1">x </span><span class="s18">==</span><span class="s1"> v is well-formed and its result is convertible to </span><span class="s19">bool</span><span class="s17">.</span></p>
<p class="p98"><span class="s1">…</span></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">==</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13"> v, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s13"> x</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, </span><span class="s83">class</span><span class="s21"> U, class Allocator,</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">==</span><span class="s84">(</span><span class="s22">const</span><span class="s28"> T</span><span class="s24">&amp;</span><span class="s28"> v, </span><span class="s22">const</span><span class="s28"> basic_optional</span><span class="s24">&lt;</span><span class="s28">U, Allocator</span><span class="s24">&gt;&amp;</span><span class="s28"> x</span><span class="s25">)</span><span class="s28">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression v </span><span class="s18">==</span><span class="s1"> </span><span class="s18">*</span><span class="s1">x is well-formed and its result is convertible to </span><span class="s19">bool</span><span class="s1">.</span></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p100"><span class="s1"></span><br></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">!=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> x, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s13"> v</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, class Allocator, </span><span class="s83">class</span><span class="s21"> U</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">!=</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">T, Allocator</span><span class="s67">&gt;&amp;</span><span class="s21"> x, </span><span class="s83">const</span><span class="s21"> U</span><span class="s67">&amp;</span><span class="s21"> v</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression </span><span class="s18">*</span><span class="s1">x </span><span class="s18">!=</span><span class="s1"> v is well-formed and its result is convertible to </span><span class="s19">bool</span></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p108"><span class="s1"></span><br></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">!=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13"> v, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s13"> x</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">emplate</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, </span><span class="s83">class</span><span class="s21"> U, class Allocator,</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">!=</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> T</span><span class="s67">&amp;</span><span class="s21"> v, </span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">U, Allocator</span><span class="s67">&gt;&amp;</span><span class="s21"> x</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression v </span><span class="s18">!=</span><span class="s1"> </span><span class="s18">*</span><span class="s1">x is well-formed and its result is convertible to </span><span class="s19">bool</span><span class="s1">.</span></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p102"><span class="s1"></span><br></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> x, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s13"> v</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, class Allocator, </span><span class="s83">class</span><span class="s21"> U</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">&lt;</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">T, Allocator</span><span class="s67">&gt;&amp;</span><span class="s21"> x, </span><span class="s83">const</span><span class="s21"> U</span><span class="s67">&amp;</span><span class="s21"> v</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression </span><span class="s18">*</span><span class="s1">x </span><span class="s18">&lt;</span><span class="s1"> v is well-formed and its result is convertible to </span><span class="s19">bool</span><span class="s1">.</span></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p100"><span class="s1"></span><br></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13"> v, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s13"> x</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, </span><span class="s83">class</span><span class="s21"> U, class Allocator,</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operato&lt;</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> T</span><span class="s67">&amp;</span><span class="s21"> v, </span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">U, Allocator</span><span class="s67">&gt;&amp;</span><span class="s21"> x</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression v </span><span class="s18">&lt;</span><span class="s1"> </span><span class="s18">*</span><span class="s1">x is well-formed and its result is convertible to </span><span class="s19">bool</span><span class="s1">.</span></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p102"><span class="s1"></span><br></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> x, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s13"> v</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, class Allocator, </span><span class="s83">class</span><span class="s21"> U</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">&gt;</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">T, Allocator</span><span class="s67">&gt;&amp;</span><span class="s21"> x, </span><span class="s83">const</span><span class="s21"> U</span><span class="s67">&amp;</span><span class="s21"> v</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression </span><span class="s18">*</span><span class="s1">x </span><span class="s18">&gt;</span><span class="s1"> v is well-formed and its result is convertible to </span><span class="s19">bool</span><span class="s1">.</span></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13"> v, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s13"> x</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, </span><span class="s83">class</span><span class="s21"> U, class Allocator,</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">&gt;</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> T</span><span class="s67">&amp;</span><span class="s21"> v, </span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">U, Allocator</span><span class="s67">&gt;&amp;</span><span class="s21"> x</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression v </span><span class="s18">&gt;</span><span class="s1"> </span><span class="s18">*</span><span class="s1">x is well-formed and its result is convertible to </span><span class="s19">bool</span><span class="s1">.</span></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p100"><span class="s1"></span><br></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> x, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s13"> v</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, class Allocator, </span><span class="s83">class</span><span class="s21"> U</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">&lt;=</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">T, Allocator</span><span class="s67">&gt;&amp;</span><span class="s21"> x, </span><span class="s83">const</span><span class="s21"> U</span><span class="s67">&amp;</span><span class="s21"> v</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression </span><span class="s18">*</span><span class="s1">x </span><span class="s18">&lt;=</span><span class="s1"> v is well-formed and its result is convertible to </span><span class="s19">bool</span></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&lt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13"> v, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s13"> x</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, </span><span class="s83">class</span><span class="s21"> U, class Allocator,</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">&lt;=</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> T</span><span class="s67">&amp;</span><span class="s21"> v, </span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">U, Allocator</span><span class="s67">&gt;&amp;</span><span class="s21"> x</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression v </span><span class="s18">&lt;=</span><span class="s1"> </span><span class="s18">*</span><span class="s1">x is well-formed and its result is convertible to </span><span class="s19">bool</span></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p102"><span class="s1"></span><br></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&amp;</span><span class="s13"> x, </span><span class="s1">const</span><span class="s13"> U</span><span class="s18">&amp;</span><span class="s13"> v</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, class Allocator, </span><span class="s83">class</span><span class="s21"> U</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">&gt;=</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">T, Allocator</span><span class="s67">&gt;&amp;</span><span class="s21"> x, </span><span class="s83">const</span><span class="s21"> U</span><span class="s67">&amp;</span><span class="s21"> v</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression </span><span class="s18">*</span><span class="s1">x </span><span class="s18">&gt;=</span><span class="s1"> v is well-formed and its result is convertible to </span><span class="s19">bool</span><span class="s1">.</span></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p102"><span class="s1"></span><br></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">constexpr</span><span class="s13"> </span><span class="s1">bool</span><span class="s13"> </span><span class="s1">operator</span><span class="s18">&gt;=</span><span class="s14">(</span><span class="s1">const</span><span class="s13"> T</span><span class="s18">&amp;</span><span class="s13"> v, </span><span class="s1">const</span><span class="s13"> optional</span><span class="s18">&lt;</span><span class="s13">U</span><span class="s18">&gt;&amp;</span><span class="s13"> x</span><span class="s14">)</span><span class="s13">;</span></p>
<p class="p101"><span class="s83">template</span><span class="s67">&lt;</span><span class="s83">class</span><span class="s21"> T, </span><span class="s83">class</span><span class="s21"> U, class Allocator,</span><span class="s67">&gt;</span><span class="s21"> </span><span class="s83">constexpr</span><span class="s21"> </span><span class="s83">bool</span><span class="s21"> </span><span class="s83">operator</span><span class="s67">&gt;=</span><span class="s84">(</span><span class="s83">const</span><span class="s21"> T</span><span class="s67">&amp;</span><span class="s21"> v, </span><span class="s83">const</span><span class="s21"> basic_optional</span><span class="s67">&lt;</span><span class="s21">U, Allocator</span><span class="s67">&gt;&amp;</span><span class="s21"> x</span><span class="s84">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Mandates</i>: The expression v </span><span class="s18">&gt;=</span><span class="s1"> </span><span class="s18">*</span><span class="s1">x is well-formed and its result is convertible to </span><span class="s19">bool</span><span class="s1">.</span></p>
<p class="p94"><span class="s1">…</span></p>
<p class="p100"><span class="s1"></span><br></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T, </span><span class="s1">class</span><span class="s13"> U</span><span class="s18">&gt;</span></p>
<p class="p104"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s19">requires</span><span class="s13"> </span><span class="s14">(</span><span class="s18">!<a href="https://eel.is/c++draft/optional#concept:is-derived-from-optional"><span class="s12"><i>is-derived-from-optional</i></span></a>&lt;</span><span class="s13">U</span><span class="s18">&gt;</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13"> <a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable_with"><span class="s23">three_way_comparable_with</span></a></span><span class="s18">&lt;</span><span class="s13">T, U</span><span class="s18">&gt;</span></p>
<p class="p98"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s19">constexpr</span><span class="s1"> compare_three_way_result_t</span><span class="s18">&lt;</span><span class="s1">T, U</span><span class="s18">&gt;</span></p>
<p class="p98"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s19">operator</span><span class="s18">&lt;=&gt;</span><span class="s14">(</span><span class="s19">const</span><span class="s1"> optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&amp;</span><span class="s1"> x, </span><span class="s19">const</span><span class="s1"> U</span><span class="s18">&amp;</span><span class="s1"> v</span><span class="s14">)</span><span class="s1">;</span></p>
<p class="p47"><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> T, class Allocator, </span><span class="s19">class</span><span class="s1"> U</span><span class="s18">&gt;</span></p>
<p class="p110"><span class="s13"><span class="Apple-converted-space">    </span></span><span class="s19">requires</span><span class="s13"> </span><span class="s14">(</span><span class="s18">!<a href="https://eel.is/c++draft/optional#concept:is-derived-from-optional"><span class="s12"><i>is-derived-from-optional</i></span></a>&lt;</span><span class="s13">U</span><span class="s18">&gt;</span><span class="s14">)</span><span class="s13"> </span><span class="s18">&amp;&amp;</span><span class="s13"> <a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable_with"><span class="s23">three_way_comparable_with</span></a></span><span class="s18">&lt;</span><span class="s13">T, U</span><span class="s18">&gt;</span></p>
<p class="p47"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s19">constexpr</span><span class="s1"> compare_three_way_result_t</span><span class="s18">&lt;</span><span class="s1">T, U</span><span class="s18">&gt;</span></p>
<p class="p98"><span class="s21"><span class="Apple-converted-space">    </span></span><span class="s22">operator</span><span class="s24">&lt;=&gt;</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> optional</span><span class="s24">&lt;</span><span class="s21">T, Allocator</span><span class="s24">&gt;&amp;</span><span class="s21"> x, </span><span class="s22">const</span><span class="s21"> U</span><span class="s24">&amp;</span><span class="s21"> v</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p94"><span class="s1"><i>Effects</i>: Equivalent to: </span><span class="s19">return</span><span class="s1"> x</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">?</span><span class="s1"> </span><span class="s18">*</span><span class="s1">x </span><span class="s18">&lt;=&gt;</span><span class="s1"> v </span><span class="s18">:</span><span class="s1"> strong_ordering</span><span class="s18"> :: </span><span class="s1">less;</span></p>
<p class="p102"><span class="s1"></span><br></p>
<p class="p102"><span class="s1"></span><br></p>
<p class="p102"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s1"><b>Modify </b><a href="https://eel.is/c++draft/optional#hash"><span class="s82"><b>22.5.10</b></span></a></span><span class="s13"><b> Hash support</b></span><span class="s1"><b> </b><a href="https://eel.is/c++draft/optional.hash"><span class="s82"><b>[optional.hash]</b></span></a></span></h3>
<p class="p107"><span class="s1"></span><br></p>
<p class="p97"><span class="s1">template</span><span class="s18">&lt;</span><span class="s1">class</span><span class="s13"> T</span><span class="s18">&gt;</span><span class="s13"> </span><span class="s1">struct</span><span class="s13"> hash</span><span class="s18">&lt;</span><span class="s13">optional</span><span class="s18">&lt;</span><span class="s13">T</span><span class="s18">&gt;&gt;</span><span class="s13">;</span></p>
<p class="p94"><span class="s1">The specialization hash</span><span class="s18">&lt;</span><span class="s1">optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&gt;</span><span class="s1"> is enabled (<a href="https://eel.is/c++draft/unord.hash"><span class="s16">[unord.hash]</span></a>) if and only if hash</span><span class="s18">&lt;</span><span class="s1">remove_const_t</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&gt;</span><span class="s1"> is enabled<a href="https://eel.is/c++draft/optional#hash-1.sentence-1"><span class="s43">.</span></a> When enabled, for an object o of type optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;</span><span class="s1">, if o</span><span class="s18">.</span><span class="s1">has_value</span><span class="s14">()</span><span class="s1"> </span><span class="s18">==</span><span class="s1"> </span><span class="s47">true</span><span class="s1">, then hash</span><span class="s18">&lt;</span><span class="s1">optional</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&gt;</span><span class="s14">()(</span><span class="s1">o</span><span class="s14">)</span><span class="s1"> evaluates to the same value as hash</span><span class="s18">&lt;</span><span class="s1">remove_const_t</span><span class="s18">&lt;</span><span class="s1">T</span><span class="s18">&gt;&gt;</span><span class="s14">()(</span><span class="s18">*</span><span class="s1">o</span><span class="s14">)</span><span class="s1">; otherwise it evaluates to an unspecified value<a href="https://eel.is/c++draft/optional#hash-1.sentence-2"><span class="s43">.</span></a> The member functions are not guaranteed to be </span><span class="s19">noexcept</span><span class="s1">.</span></p>
<p class="p102"><span class="s1"></span><br></p>
<p class="p29"><span class="s19">template</span><span class="s18">&lt;</span><span class="s19">class</span><span class="s1"> T</span><span class="s26">, class Allocator</span><span class="s18">&gt;</span><span class="s1"> </span><span class="s19">struct</span><span class="s1"> hash</span><span class="s18">&lt;basic_</span><span class="s1">optional</span><span class="s18">&lt;</span><span class="s1">T, Allocator</span><span class="s18">&gt;&gt;</span><span class="s1">;</span></p>
<p class="p62"><span class="s44">The specialization hash</span><span class="s45">&lt;</span><span class="s86">basic_</span><span class="s55">optional</span><span class="s86">&lt;</span><span class="s55">T, Allocator</span><span class="s86">&gt;</span><span class="s45">&gt;</span><span class="s44"> is enabled (<a href="https://eel.is/c++draft/unord.hash"><span class="s12">[unord.hash]</span></a>) if and only if hash</span><span class="s45">&lt;</span><span class="s44">remove_const_t</span><span class="s45">&lt;</span><span class="s44">T</span><span class="s45">&gt;&gt;</span><span class="s44"> is enabled<a href="https://eel.is/c++draft/optional#hash-1.sentence-1"><span class="s1">.</span></a> When enabled, for an object o of type </span><span class="s86">basic_</span><span class="s55">optional</span><span class="s86">&lt;</span><span class="s55">T, Allocator</span><span class="s86">&gt;</span><span class="s44">, if o</span><span class="s45">.</span><span class="s44">has_value</span><span class="s52">()</span><span class="s44"> </span><span class="s45">==</span><span class="s44"> </span><span class="s50">true</span><span class="s44">, then hash</span><span class="s45">&lt;</span><span class="s86">basic_</span><span class="s55">optional</span><span class="s86">&lt;</span><span class="s55">T, Allocator</span><span class="s86">&gt;</span><span class="s45">&gt;</span><span class="s52">()(</span><span class="s44">o</span><span class="s52">)</span><span class="s44"> evaluates to the same value as hash</span><span class="s45">&lt;</span><span class="s44">remove_const_t</span><span class="s45">&lt;</span><span class="s44">T</span><span class="s45">&gt;&gt;</span><span class="s52">()(</span><span class="s45">*</span><span class="s44">o</span><span class="s52">)</span><span class="s44">; otherwise it evaluates to an unspecified value<a href="https://eel.is/c++draft/optional#hash-1.sentence-2"><span class="s1">.</span></a> The member functions are not guaranteed to be </span><span class="s53">noexcept</span><span class="s44">.</span></p>
<p class="p111"><span class="s1"><i></i></span><br></p>
</body>
</html>
