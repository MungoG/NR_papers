<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>An allocator-aware optional type</title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2113.3">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 12.0px Times; color: #0000e9; -webkit-text-stroke: #0000dc}
    p.p3 {margin: 0.0px 0.0px 6.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p6 {margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p7 {margin: 0.0px 0.0px 12.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Courier; color: #000000; -webkit-text-stroke: #000000}
    p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Courier; color: #000000; -webkit-text-stroke: #000000}
    p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 18.0px}
    p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 18.0px}
    p.p18 {margin: 0.0px 0.0px 14.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p19 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p21 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #135003}
    p.p22 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #0d2d44}
    p.p23 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #135003; background-color: #31ff0d}
    p.p24 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #270028; background-color: #31ff0d}
    p.p25 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #0d2d44; background-color: #31ff0d}
    p.p26 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d}
    p.p27 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000dc}
    p.p28 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p29 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #74000e}
    p.p30 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p31 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000dc; background-color: #31ff0d}
    p.p32 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #270028}
    p.p33 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d}
    p.p34 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #135003}
    p.p35 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #135003; background-color: #31ff0d}
    p.p36 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000dc; background-color: #31ff0d}
    p.p37 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #0d2d44; background-color: #31ff0d}
    p.p38 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 9.3px Times; color: #000000; -webkit-text-stroke: #0000dc}
    p.p39 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #2cff0b}
    p.p43 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d}
    p.p44 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d}
    p.p46 {margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p47 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d; min-height: 16.0px}
    p.p48 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px 'Lucida Grande'; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d}
    p.p49 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; background-color: #31ff0d}
    p.p50 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; background-color: #31ff0d}
    p.p51 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p52 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; background-color: #31ff0d; min-height: 16.0px}
    p.p53 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; background-color: #31ff0d}
    p.p54 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000dc; background-color: #31ff0d; min-height: 16.0px}
    p.p55 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d; min-height: 14.0px}
    p.p58 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0d2d44; -webkit-text-stroke: #0d2d44}
    p.p59 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 10.0px Times; color: #0000dc; -webkit-text-stroke: #0000dc}
    p.p60 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 10.0px Times; color: #000000; -webkit-text-stroke: #0000dc}
    p.p61 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #0d2d44}
    li.li6 {margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    li.li26 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d}
    span.s1 {font-kerning: none}
    span.s2 {text-decoration: underline ; font-kerning: none}
    span.s3 {font: 13.0px Courier; font-kerning: none}
    span.s4 {text-decoration: underline ; font-kerning: none; color: #0000e3; -webkit-text-stroke: 0px #0000e3}
    span.s5 {font: 13.0px Courier; -webkit-text-stroke: 0px #000000}
    span.s6 {-webkit-text-stroke: 0px #000000}
    span.s7 {color: #0e00ff; -webkit-text-stroke: 0px #000000}
    span.s8 {font-kerning: none; color: #0e00ff; -webkit-text-stroke: 0px #0e00ff}
    span.s9 {font: 14.0px Courier; font-kerning: none}
    span.s10 {font: 12.0px Courier; font-kerning: none}
    span.s11 {font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s12 {font-kerning: none; -webkit-text-stroke: 0px #372218}
    span.s13 {font-kerning: none; -webkit-text-stroke: 0px #270028}
    span.s14 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #135003}
    span.s15 {font: 13.3px Times; font-kerning: none; -webkit-text-stroke: 0px #0000dc}
    span.s16 {font-kerning: none; -webkit-text-stroke: 0px #74000e}
    span.s17 {font: 12.0px Times; font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s18 {font-kerning: none; -webkit-text-stroke: 0px #0000dc}
    span.s19 {font: 12.0px Times; font-kerning: none}
    span.s20 {font-kerning: none; -webkit-text-stroke: 0px #0d2d44}
    span.s21 {font-kerning: none; background-color: #31ff0d}
    span.s22 {font-kerning: none; background-color: #31ff0d; -webkit-text-stroke: 0px #0d2d44}
    span.s23 {font-kerning: none; background-color: #31ff0d; -webkit-text-stroke: 0px #270028}
    span.s24 {font-kerning: none; -webkit-text-stroke: 0px #64330b}
    span.s25 {font-kerning: none; background-color: #31ff0d; -webkit-text-stroke: 0px #74000e}
    span.s26 {font: 13.3px Times; font-kerning: none; background-color: #31ff0d; -webkit-text-stroke: 0px #135003}
    span.s27 {font-kerning: none; background-color: #31ff0d; -webkit-text-stroke: 0px #000000}
    span.s28 {text-decoration: underline ; font-kerning: none; color: #0000e3; -webkit-text-stroke: 0px #0000dc}
    span.s29 {font-kerning: none; -webkit-text-stroke: 0px #135003}
    span.s30 {text-decoration: underline ; font-kerning: none; color: #0000dc; -webkit-text-stroke: 0px #0000dc}
    span.s31 {font-kerning: none; color: #0000dc; -webkit-text-stroke: 0px #0000dc}
    span.s32 {text-decoration: underline ; font-kerning: none; color: #0000e3}
    span.s33 {font-kerning: none; background-color: #31ff0d; -webkit-text-stroke: 0px #0000dc}
    span.s34 {font: 14.0px Times; font-kerning: none}
    span.s35 {font: 13.3px Times; text-decoration: underline ; font-kerning: none; color: #0000e3}
    span.s36 {font-kerning: none; color: #0000ff; -webkit-text-stroke: 0px #0000ff}
    span.s37 {font-kerning: none; background-color: #2cff0b}
    span.s38 {font: 9.4px Times; vertical-align: -2.0px; font-kerning: none}
    span.s39 {font: 9.4px Times; vertical-align: 4.8px; font-kerning: none}
    span.s40 {font: 9.3px Times; font-kerning: none; -webkit-text-stroke: 0px #0000dc}
    span.s41 {font: 9.4px Times; font-kerning: none}
    span.s42 {font: 13.3px Times; text-decoration: underline ; font-kerning: none; color: #0000e3; -webkit-text-stroke: 0px #0000dc}
    span.s43 {font: 12.0px Times; font-kerning: none; -webkit-text-stroke: 0px #0000dc}
    span.s44 {font: 12.0px 'Lucida Grande'; font-kerning: none}
    span.s45 {text-decoration: underline ; font-kerning: none; color: #0000e3; -webkit-text-stroke: 0px #000000}
    span.s46 {font: 13.3px Times; text-decoration: underline ; font-kerning: none; color: #0000e3; -webkit-text-stroke: 0px #000000}
    span.s47 {text-decoration: underline ; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000dc}
    span.s48 {text-decoration: underline ; font-kerning: none; color: #0000e9}
    span.s49 {font-kerning: none; color: #0000e3}
    span.s50 {font: 10.0px Menlo; font-kerning: none; -webkit-text-stroke: 0px #0000dc}
    span.s51 {font: 10.0px Menlo; font-kerning: none}
    span.s52 {font: 13.3px Times; font-kerning: none}
    span.s53 {font: 9.4px Times; vertical-align: -2.0px; font-kerning: none; background-color: #31ff0d}
    span.s54 {font-kerning: none; background-color: #31ff0d; -webkit-text-stroke: 0px #64330b}
    span.s55 {font: 13.3px Times; font-kerning: none; background-color: #31ff0d; -webkit-text-stroke: 0px #0000dc}
    span.s56 {font: 13.3px Times; font-kerning: none; background-color: #31ff0d}
    span.s57 {font: 12.0px Times; font-kerning: none; -webkit-text-stroke: 0px #270028}
    span.s58 {font: 8.5px Times; vertical-align: -1.8px; font-kerning: none}
    span.s59 {font-kerning: none; color: #0000e3; -webkit-text-stroke: 0px #000000}
    span.s60 {font: 14.0px Times; font-kerning: none; -webkit-text-stroke: 0px #000000}
    span.s61 {font: 15.6px Times; font-kerning: none}
    span.s62 {font: 14.0px Times; text-decoration: underline ; font-kerning: none; color: #0000dc; -webkit-text-stroke: 0px #0000dc}
    span.s63 {font-kerning: none; color: #270028; -webkit-text-stroke: 0px #270028}
    span.s64 {font-kerning: none; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s65 {font-kerning: none; color: #0d2d44; -webkit-text-stroke: 0px #0d2d44}
    span.s66 {font-kerning: none; color: #74000e; -webkit-text-stroke: 0px #74000e}
    span.s67 {font-kerning: none; color: #0d2d44}
    span.s68 {font-kerning: none; background-color: #f0000d}
    span.s69 {font: 12.0px Times; font-kerning: none; background-color: #31ff0d; -webkit-text-stroke: 0px #270028}
    span.Apple-tab-span {white-space:pre}
    ol.ol1 {list-style-type: decimal}
    ul.ul1 {list-style-type: disc}
    ul.ul2 {list-style-type: none}
    ul.ul3 {list-style-type: circle}
    ul.ul4 {list-style-type: square}
  </style>
</head>
<body>
<p class="p1"><span class="s1"><i>Document number: P3153R0</i></span></p>
<p class="p1"><span class="s1"><i>Audience: LEWG<span class="Apple-converted-space"> </span></i></span></p>
<p class="p1"><span class="s1"><br>
</span></p>
<p class="p2"><span class="s2"><a href="mailto:dinka.ranns@gmail.com"><i>Nina Dinka Ranns</i></a></span></p>
<p class="p2"><span class="s2"><a href="mailto:phalpern@halpernwightsoftware.com"><i>Pablo Halpern</i></a></span></p>
<p class="p2"><span class="s2"><a href="mailto:ville.voutilainen@gmail.com"><i>Ville Voutilainen</i></a></span></p>
<p class="p1"><span class="s1"><i>2024-02-15</i></span></p>
<p class="p3"><span class="s1"><br>
</span></p>
<h1 style="margin: 0.0px 0.0px 16.1px 0.0px; text-align: center; font: 24.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>An allocator-aware variant type</b></span></h1>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Abstract</b></span></h2>
<p class="p6"><span class="s1">Library types that can potentially hold <i>allocator-aware (AA)</i> objects should, themselves, be allocator-aware. A PMR container, for example, depends on AA types following a known AA protocol so that it (the container) can uniformly manage its memory. Even types that don't manage their own memory, such as </span><span class="s3">tuple</span><span class="s1">, follow the AA rules when they hold one more more AA elements. (A special case is </span><span class="s3">pair</span><span class="s1">, which is not actually AA but effectively follows the rules through special handling in <i>uses-allocator construction</i>.)</span></p>
<p class="p6"><span class="s1">The current definition of </span><span class="s3">std::variant</span><span class="s1"> does not follow the rules for an AA type, even when holding an AA alternative. This limitation makes </span><span class="s3">std::variant</span><span class="s1"> unsuitable for storage in an AA container when memory allocation customization is needed.</span></p>
<p class="p6"><span class="s1">In this paper, we propose a new, allocator-aware </span><span class="s3">std::basic_variant</span><span class="s1"> usable as a container element type of allocator aware containers, and in any other context where allocator propagation and allocator preservation is expected. This new type would not replace the current </span><span class="s3">std:: variant</span><span class="s1"> as the desired behaviour is not compatible with how </span><span class="s3">std:: variant</span><span class="s1"> handles allocator aware types at the moment. We also propose an </span><span class="s3">std::pmr::variant</span><span class="s1"> type which is a specialisation of </span><span class="s3">std::basic_variant</span><span class="s1"> for </span><span class="s3">std::pmr::polymorphic_allocator&lt;&gt;</span><span class="s1">.</span></p>
<p class="p7"><span class="s1">This is a complete proposal with formal wording.</span></p>
<h1 style="margin: 0.0px 0.0px 16.1px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Motivation</b></span></h1>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>General Motivation for allocator-aware types</b></span></h2>
<p class="p6"><span class="s1"><i>Note: The text below is borrowed nearly verbetim from </i><a href="http://wg21.link/P3002R1"><span class="s4"><i>P3002</i></span></a><i>, which proposes a general policy for when types should use allocators</i></span></p>
<p class="p6"><span class="s1">Memory management is a major part of building software. Numerous facilities in the C++ Standard library exist to give the programmer maximum control over how their program uses memory:</span></p>
<ul class="ul1">
  <li class="li6"><span class="s5"></span><span class="s3">std::unique_ptr</span><span class="s1"> and </span><span class="s3">std::shared_ptr</span><span class="s1"> are parameterized with <i>deleter</i> objects that control, among other things, how memory resources are reclaimed.</span></li>
  <li class="li6"><span class="s5"></span><span class="s3">std::vector</span><span class="s1"> is preferred over other containers in many cases because its use of contiguous memory provides optimal cache locality and minimizes allocate/deallocate operations. Indeed, the LEWG has spent a lot of time on </span><span class="s3">flat_set</span><span class="s1"> (<a href="http://wg21.link/P1222R0"><span class="s4">P1222R0</span></a>) and </span><span class="s3">flat_map</span><span class="s1"> (<a href="http://wg21.link/P0429R3"><span class="s4">P0429R3</span></a>), whose underlying structure defaults to </span><span class="s3">vector</span><span class="s1"> for this reason.</span></li>
  <li class="li6"><span class="s6"></span><span class="s1">Operators </span><span class="s3">new</span><span class="s1"> and </span><span class="s3">delete</span><span class="s1"> are replaceable, giving programmers global control over how memory is allocated.</span></li>
  <li class="li6"><span class="s6"></span><span class="s1">The C++ object model makes a clear distinction between an object’s memory footprint and it’s lifetime.</span></li>
  <li class="li6"><span class="s6"></span><span class="s1">Language constructs such as </span><span class="s3">void*</span><span class="s1"> and </span><span class="s3">reinterpet_cast</span><span class="s1"> provide fine-grained access to objects’ underlying memory.</span></li>
  <li class="li6"><span class="s6"></span><span class="s1">Standard containers and strings are parameterized with allocators, providing object-level control over memory allocation and element construction.</span></li>
</ul>
<p class="p6"><span class="s1">This fine-grained control over memory that C++ gives the programmer is a large part of why C++ is applicable to so many domains — from embedded systems with limited memory budgets to games, high-frequency trading, and scientific simulations that require cache locality, thread affinity, and other memory-related performance optimizations.</span></p>
<p class="p6"><span class="s1">An in-depth description of the value proposition for allocator-aware software can be found in <a href="http://wg21.link/P2035R0"><span class="s4">P2035R0</span></a>. Standard containers are the most ubiquitous examples of <i>allocator-aware</i> types. Their </span><span class="s3">allocator_type</span><span class="s1"> and </span><span class="s3">get_allocator</span><span class="s1"> members and allocator-parameterized constructors allow them to be used like Lego® parts that can be combined and nested as necessary while retaining full programmer control over how the whole assembly allocates memory. For <i>scoped allocators</i> — those that apply not only to the top-level container, but also to its elements — having each element of a container support a predictable allocator-aware interface is crucial to giving the programmer the ability to allocate all memory from a single memory resource, such as an arena or pool. Note that the allocator is a <i>configuration</i> parameter of an object and does not contribute to its value.</span></p>
<p class="p6"><span class="s1">In short, the principles underlying this policy proposal are:</span></p>
<ol class="ol1">
  <li class="li6"><span class="s7"></span><span class="s8">The Standard Library should be general and flexible</span><span class="s1">. To the extent possible, the user of a library class should have control over how memory is allocated.</span></li>
  <li class="li6"><span class="s7"></span><span class="s8">The Standard Library should be consistent</span><span class="s1">. The use of allocators should be consistent with the existing allocator-aware classes and class templates, especially those in the containers library.</span></li>
  <li class="li6"><span class="s7"></span><span class="s8">The parts of the Standard Library should work together</span><span class="s1">. If one part of the library gives the user control over memory allocation but another part does not, then the second part undermines the utility of the first.</span></li>
  <li class="li6"><span class="s7"></span><span class="s8">The Standard Library should encapsulate complexity</span><span class="s1">. Fully general application of allocators is potentially complex and is best left to the experts implementing the Standard Library. Users can choose their own subset of desirable allocator behavior only if the underlying Library classes allow them to choose their preferred approach, whether it be stateless allocators, statically typed allocators, polymorphic allocators, or no allocators.</span></li>
</ol>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Motivation for an Allocator-aware </b></span><span class="s9"><b>variant</b></span></h2>
<p class="p6"><span class="s1">Although each alternative in a </span><span class="s10">std::variant</span><span class="s1"> can be initialized with any set of valid constructor arguments, including allocator arguments, the fact that the </span><span class="s10">variant</span><span class="s1"> itself is not allocator-aware prevents it from working consistently with other parts of the standard library, specifically those parts that depend on <i>uses-allocator construction</i> (section [allocator.uses.construction]) in the standard). For example:</span></p>
<p class="p10"><span class="s1">pmr::polymorphic_allocator&lt;&gt; alloc{ ... };</span></p>
<p class="p10"><span class="s1">using V = variant&lt;pmr::string, int&gt;;</span></p>
<p class="p10"><span class="s1">V v = make_obj_using_allocator&lt;V&gt;(alloc,</span></p>
<p class="p10"><span class="s1"><span class="Apple-converted-space">                                  </span>in_place_type&lt;pmr::string&gt;, "hello");</span></p>
<p class="p10"><span class="s1">assert(get&lt;0&gt;(v).get_allocator() == alloc);<span class="Apple-converted-space">  </span>// FAILS</span></p>
<p class="p10"><span class="s1"><br>
</span></p>
<p class="p6"><span class="s1">Even though an allocator is supplied, it is not used to construct the </span><span class="s10">pmr::string</span><span class="s1"> within the resulting </span><span class="s10">variant</span><span class="s1"> object because </span><span class="s10">variant</span><span class="s1"> does not have the necessary hooks for </span><span class="s10">make_obj_using_allocator</span><span class="s1"> to recognize it as being allocator-aware. Note that, although this example and the ones that follow use </span><span class="s10">pmr::polymorphic_allocator</span><span class="s1">, the same issues would apply to any scoped allocator.</span></p>
<p class="p6"><span class="s1"><i>Uses-allocator construction</i> is rarely used directly in user code. Instead, it is used within the implementation of standard containers and scoped allocators to ensure that the allocator used to construct the container is also used to construct its elements. Continuing the example above, consider what happens if a </span><span class="s10">variant</span><span class="s1"> is stored in a </span><span class="s10">pmr::vector</span><span class="s1">, compared to storing a truly allocator-aware type (</span><span class="s10">pmr::string</span><span class="s1">):</span></p>
<p class="p10"><span class="s1">pmr::vector&lt;pmr::string&gt; vs(alloc);</span></p>
<p class="p10"><span class="s1">pmr::vector&lt;V&gt; <span class="Apple-converted-space">          </span>vv(alloc);</span></p>
<p class="p10"><span class="s1"><br>
</span></p>
<p class="p10"><span class="s1">vs.emplace_back("hello");</span></p>
<p class="p10"><span class="s1">vv.emplace_back("hello");</span></p>
<p class="p10"><span class="s1"><br>
</span></p>
<p class="p10"><span class="s1">assert(vs.back().get_allocator() == alloc);<span class="Apple-converted-space">          </span>// OK</span></p>
<p class="p10"><span class="s1">assert(get&lt;0&gt;(vv.back()).get_allocator() == alloc);<span class="Apple-converted-space">  </span>// FAILS</span></p>
<p class="p10"><span class="s1"><br>
</span></p>
<p class="p6"><span class="s1">An important invariant when using a scoped allocator such as </span><span class="s10">pmr::polymorphic_allocator</span><span class="s1"> is that the same allocator is used throughout an object hierarchy. It is impossible to ensure that this invariant is preserved when using </span><span class="s10">std::variant</span><span class="s1">, even if the element is originally inserted with the correct allocator, because </span><span class="s10">variant</span><span class="s1"> does not remember the allocator used to construct it and cannot therefore re-instate the allocator when changing the active alternative:</span></p>
<p class="p10"><span class="s1">vv.emplace_back(in_place_type&lt;pmr::string&gt;, "hello", alloc);</span></p>
<p class="p10"><span class="s1">assert(get&lt;0&gt;(vv.back()).get_allocator() == alloc);<span class="Apple-converted-space">  </span>// OK</span></p>
<p class="p10"><span class="s1"><br>
</span></p>
<p class="p10"><span class="s1">vv.back() = 5;<span class="Apple-converted-space">          </span>// Change alternative to `int`</span></p>
<p class="p10"><span class="s1">vv.back() = "goodbye";<span class="Apple-converted-space">  </span>// Change alternative back to `pmr::string`</span></p>
<p class="p10"><span class="s1">assert(get&lt;0&gt;(vv.back()).get_allocator() == alloc);<span class="Apple-converted-space">  </span>// FAILS</span></p>
<p class="p10"><span class="s1"><br>
</span></p>
<p class="p6"><span class="s1">Finally, when using assignment, the value stored in the </span><span class="s10">variant</span><span class="s1"> is set sometimes by construction and other times by assignment. Depending on the allocator type’s propagation traits, it is difficult to reason about the resulting alternative’s allocator:</span></p>
<p class="p10"><span class="s1">V v1{ 5 };<span class="Apple-converted-space">        </span>// int does not use an allocator</span></p>
<p class="p10"><span class="s1">V v2{ "hello" };<span class="Apple-converted-space">  </span>// string uses a default-constructed allocator</span></p>
<p class="p10"><span class="s1">v1 = pmr::string("goodbye", alloc); <span class="Apple-converted-space">          </span>// Constructs the string</span></p>
<p class="p10"><span class="s1">v2 = pmr::string("goodbye", alloc); <span class="Apple-converted-space">          </span>// Assigns to the string</span></p>
<p class="p10"><span class="s1">assert(get&lt;0&gt;(v1).get_allocator() == alloc);<span class="Apple-converted-space">  </span>// OK, set by move construction</span></p>
<p class="p10"><span class="s1">assert(get&lt;0&gt;(v2).get_allocator() == alloc);<span class="Apple-converted-space">  </span>// ERROR, set by assignment</span></p>
<p class="p11"><span class="s1"><br>
</span></p>
<h1 style="margin: 0.0px 0.0px 16.1px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Summary of the proposed feature</b></span></h1>
<p class="p6"><span class="s1">This paper proposes an allocator-aware </span><span class="s10">variant</span><span class="s1">. Unfortunately, it would be complicated to add an allocator to the current </span><span class="s10">std::variant</span><span class="s1"> without causing API and ABI compatibility issues and/or imposing long compile times on code that does not benefit from the change. For this reason, we are proposing a new class template, </span><span class="s10">basic_variant</span><span class="s1">, which works like </span><span class="s10">variant</span><span class="s1">, but adds allocator support.</span></p>
<p class="p6"><span class="s1">The key attributes of </span><span class="s10">basic_variant</span><span class="s1"> that make it different from </span><span class="s10">variant</span><span class="s1"> are:</span></p>
<ul class="ul1">
  <li class="li6"><span class="s6"></span><span class="s1">It has an </span><span class="s10">Allocator</span><span class="s1"> template parameter.</span></li>
  <li class="li6"><span class="s6"></span><span class="s1">It has a public </span><span class="s10">allocator_type</span><span class="s1"> member to advertise that it is allocator-aware.</span></li>
  <li class="li6"><span class="s6"></span><span class="s1">There are allocator-enabled versions of every constructor.</span></li>
  <li class="li6"><span class="s6"></span><span class="s1">The supplied allocator is forwarded to the constructor of the active alternative, if that alternative uses a compatible allocator type. The allocator is retained so that it can be supplied to the contained object whenever the active alternative changes. Allocator traits, including propagation traits, are respected.</span></li>
  <li class="li6"><span class="s6"></span><span class="s1">It has an alias, </span><span class="s10">pmr::variant</span><span class="s1">, for which </span><span class="s10">Allocator</span><span class="s1"> is hard-coded to </span><span class="s10">pmr::polymorphic_allocator&lt;&gt;</span><span class="s1">.</span></li>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><br>
</span></h2>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Design decisions:</b></span></h2>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s9"><b>Basic_variant</b></span><span class="s1"><b> supports non-scoped propagating allocators<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p7"><span class="s1">There are two ways of viewing </span><span class="s10">basic_variant</span><span class="s1"> from allocator propagation perspective : <br>
#1 </span><span class="s10">basic_varian</span><span class="s1"> is like an </span><span class="s10">std::tuple</span><span class="s1">, i.e. it only accepts the allocator at construction so it can forward it to the value_type object. One can use a non-scoped propagation allocator, and when using a scoped propagation allocator </span><span class="s10">basic_varian</span><span class="s1"> will not "consume" an allocator level. A variant object is in a way like a tuple object as it does not use the allocator itself, it only passes it into the value_type object. <br>
#2 </span><span class="s10">basic_variant</span><span class="s1"> is like an </span><span class="s10">std::vector</span><span class="s1">, i.e. it is a container of one or zero elements, and one should use a scoped propagating allocator if one wants the value_type object to use the allocator. In this approach </span><span class="s10">basic_variant</span><span class="s1"> will "consume" an allocator level. Using non-scoped propagating allocators makes little sense in this scenario.<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="s1">The proposal implements #1 as </span><span class="s10">basic_variant</span><span class="s1"> itself does not allocate any memory so it makes little sense for it to consume an allocator level.<span class="Apple-converted-space">  </span>The allocator in basic_variant is simply stored so it can be used by any alternative that requires it.</span></p>
<p class="p14"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Allocator overhead</b></span></h3>
<p class="p15"><span class="s1">Allocator overhead can be removed in two cases</span></p>
<p class="p15"><span class="s1">- if all alternatives are not allocator aware</span></p>
<p class="p15"><span class="s1">- is allocator_traits&lt;Allocator&gt;::is_always_equal::value == true</span></p>
<p class="p16"><span class="s1"></span><br></p>
<p class="p15"><span class="s1">In the former case, allocator is simply not needed. In the latter case, there is no need to store or pass in the allocator as the default allocator will do. The paper doesn’t standardise such optimisation, it is left as a QOI. Note that the above cases reduce to std::variant behaviour.</span></p>
<p class="p17"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Default constructor considerations</b></span></h3>
<p class="p7"><span class="s1">Uses_allocator construction is always used in case the default allocator construction produces different allocators each time. Possible optimisation opportunity for allocators which have is_always_equal set to true, but no benefit in triviality or constexpr - uses_allocator construction will be constexpr if it can be constexpr either way. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant constexpr considerations would only depend on the constexpr construction of the 0th alternative.<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="s1">No conditional triviality of the default constructor is possible - the internal state needs to be initialised.<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="s1">Because default constructor has to explicitly specify the allocator, unless is_always_equal==true, the default constructor is noexcept if 0th alternative is not AA or is_always_equal==true, and default construction of 0th alternative is noexcept.</span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Copy constructor considerations</b></span></h3>
<p class="p7"><span class="s1">Copy construction does not do uses_allocator construction - the type is expected to behave according to the traits and get the right allocator. This allows for triviality if allocator is always equal and both the allocator and the constructed type can be trivially copy constructed. If allocator is not always equal, we need to check the traits to get the right allocator and that initialisation can not be trivial. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to store the allocator and triviality only depends on the triviality of the alternatives. This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Move constructor considerations</b></span></h3>
<p class="p7"><span class="s1">Move construction does not do uses_allocator construction - the type is expected to behave according to the traits and get the right allocator. This allows for triviality if allocator and the constructed type can be trivially move constructed. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to store the allocator and triviality only depends on the triviality of the alternatives. This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Value constructor considerations</b></span></h3>
<p class="p7"><span class="s1">Value construction must do uses_allocator construction if allocators aren't always equal- the plain copy/move construction may use the wrong allocator.<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="s1">The paper does not propose exception specification on this value constructor and considers it QOI</span></p>
<p class="p7"><span class="s1">Exception specification considerations<span class="Apple-converted-space">  </span>: <br>
- for non AA type, the exception specification is equivalent to is_nothrow_constructible_v&lt;Tj, T&gt; <br>
- for AA type, to get a possibly no throw construction, we need to delegate to plain copy/move which can possibly reuse the allocation. The delegation can only happen if allocators are always equal. If this constructor checked for allocators being always equal before deciding whether to do uses allocator construction or not, it would make sense for all inplace constructors and allocator extended constructors to do the same. This paper does not propose such considerations.</span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Copy assignment operator considerations</b></span></h3>
<p class="p7"><span class="s1">First the allocator is possibly modified based on the traits, then the assignment/construction is done as normal. In addition to std::variant’s triviality requirements, triviality can only happen if allocator is always equal and it is a trivially copyable type. The condition for the copy construction vs variant move construction is as follows : <br>
- if a copy construction can't throw do copy construction <br>
- if move construction can throw do copy construction as the move construction doesn't bring any benefits <br>
- otherwise, do move construction.<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="s1">With the introduction of allocators, we now have to consider when we can do plain copy construction and when allocator extended construction is needed. If type is non AA, we can do plain copy construction. If the type is AA and allocator is always equal, we can also do plain copy construction. Note that, for allocator is always equal case, plain copy construction and allocator copy construction will effectively result in the same allocator. We do not consider the possibility of doing non allocator extended copy construction for the case where the copy assignment allocator propagation matches the resulting allocator at copy construction as that case can't be checked at compile time.</span></p>
<p class="p7"><span class="s1">In all other cases, copy construction must use allocator extended copy construction to guarantee that the right allocator is used. We assume such cases are always throwing.<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="s1">Move assignment from a temporary basic_variant must construct the temporary object with uses-allocator construction to ensure correct allocator is used.<span class="Apple-converted-space">  </span>A possible optimisation is for the case when allocators are always equal or if POCMA=true<span class="Apple-converted-space">  </span>- such temporary could be constructed with a non allocator extended constructor. This paper does not propose such optimisation.</span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Move assignment operator<span class="Apple-converted-space"> </span></b></span></h3>
<p class="p7"><span class="s1">First the allocator is possibly modified based on the traits, then the assignment/construction is done as normal. In addition to usual triviality requirements, triviality can only happen if the allocator is propagated for move assignment(POCMA=true) or if the allocator is always equal. Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to ever allocate and triviality only depends on the triviality of the alternative operations. This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="s1">The exception specification needs to consider assignment and construction operations. For AA types, move construction can be done directly if the allocator is always equal or if POCMA=true. Otherwise, the move construction needs to explicitly specify the allocator and we consider such move construction to always be possibly throwing.</span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Value assignment operator</b></span></h3>
<p class="p7"><span class="s1">Value construction must do uses_allocator construction if allocators aren't always equal- the plain copy/move construction may use the wrong allocator. Exception specification : <br>
- for non AA type, the exception specification is equivalent to is_nothrow_assignable_v&lt;Tj, T&gt; &amp; &amp; is_nothrow_constructible_v&lt;Tj, T&gt; <br>
- for AA type, any allocation is potentially throwing. To get a possibly no throw construction, we need to delegate to plain move which can possibly reuse the allocation. The delegation can only happen if allocators are always equal. <br>
Possible additional consideration is for basic_variant where no types are allocator aware - such a basic_variant does not need to ever allocate and exception specification depends only on the alternatives This proposal does not consider such optimisation.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Member swap</b></span></h3>
<p class="p7"><span class="s1">First the allocator is possibly modified based on the traits, then the swap/construction is done as normal. Exception specification : To get a possibly no throw construction, we need to delegate to plain move which can possibly reuse the allocation. The delegation can only happen if allocators are always equal or if propagate_on_container_swap == true (for such a type, the resulting allocator in move construction is the required allocator as move construction always propagates the allocator.) This means that swap can only be noexcept if <br>
- is_nothrow_move_constructible_v&lt;Ti, T&gt; &amp; &amp; is_nothrow_constructible_v&lt;Ti, T&gt; for all i, and <br>
- allocator is always equal or propagate_on_container_swap == true<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="s1">Note that swap has undefined behaviour if (allocator is always equal or propagate_on_container_swap == true) condition is not satisfied, so this condition is not reflected in the exception specification.</span></p>
<p class="p18"><span class="s1"></span><br></p>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Proposed wording</b></span></h2>
<p class="p19"><span class="s1"><br>
</span></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; color: #000000; -webkit-text-stroke: #0000dc"><span class="s1"><b>Modify 22.6.2</b></span><span class="s11"><b> Header &lt;variant&gt; synopsis</b></span><span class="s1"><b> [variant.syn]</b></span></h3>
<p class="p21"><span class="s1"><i>// mostly freestanding</i></span></p>
<p class="p15"><span class="s12">#include</span><span class="s1"> </span><span class="s13">&lt;</span><span class="s1">compare</span><span class="s13">&gt;</span><span class="s1"><span class="Apple-converted-space">              </span></span><span class="s14"><i>// see </i></span><span class="s15"><i>[compare.syn]</i></span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p22"><span class="s1">namespace</span><span class="s11"> std </span><span class="s16">{</span></p>
<p class="p21"><span class="s17"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s18"><i>[variant.variant]</i></span><span class="s1"><i>, class template </i></span><span class="s19">variant</span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">class</span><span class="s1"> variant;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p23"><span class="s17"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s18"><i>[variant.basic.variant]</i></span><span class="s1"><i>, class template basic_</i></span><span class="s19">variant</span></p>
<p class="p24"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s1">&lt;class Allocator, </span><span class="s20">class</span><span class="s1">...</span><span class="s11"> Types</span><span class="s1">&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">    </span></span><span class="s22">class</span><span class="s21"> basic_variant;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p21"><span class="s17"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s18"><i>[variant.helper]</i></span><span class="s1"><i>, variant helper classes</i></span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> T</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">struct</span><span class="s1"> variant_size;<span class="Apple-converted-space">                        </span></span><span class="s14"><i>// not defined</i></span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T</span><span class="s13">&gt;</span><span class="s11"> </span><span class="s1">struct</span><span class="s11"> variant_size</span><span class="s13">&lt;</span><span class="s1">const</span><span class="s11"> T</span><span class="s13">&gt;</span><span class="s11">;</span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> size_t variant_size_v </span><span class="s13">=</span><span class="s1"> variant_size</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;::</span><span class="s1">value;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">struct</span><span class="s1"> variant_size</span><span class="s13">&lt;</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;</span><span class="s1">;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">    </span></span><span class="s22">struct</span><span class="s21"> variant_size</span><span class="s23">&lt;basic_</span><span class="s21">variant</span><span class="s23">&lt;Allocator, </span><span class="s21">Types</span><span class="s23">...&gt;&gt;</span><span class="s21">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s1"> T</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">struct</span><span class="s1"> variant_alternative; <span class="Apple-converted-space">      </span></span><span class="s14"><i>// not defined</i></span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s1"> T</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">struct</span><span class="s1"> variant_alternative</span><span class="s13">&lt;</span><span class="s1">I, </span><span class="s20">const</span><span class="s1"> T</span><span class="s13">&gt;</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s1"> T</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">using</span><span class="s1"> variant_alternative_t </span><span class="s13">=</span><span class="s1"> </span><span class="s20">typename</span><span class="s1"> variant_alternative</span><span class="s13">&lt;</span><span class="s1">I, T</span><span class="s13">&gt;::</span><span class="s1">type;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">struct</span><span class="s1"> variant_alternative</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, class Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">    </span></span><span class="s22">struct</span><span class="s21"> variant_alternative</span><span class="s23">&lt;</span><span class="s21">I, basic_variant</span><span class="s23">&lt;Allocator, </span><span class="s21">Types</span><span class="s23">...&gt;&gt;</span><span class="s21">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">inline</span><span class="s1"> </span><span class="s20">constexpr</span><span class="s1"> size_t variant_npos </span><span class="s13">=</span><span class="s1"> </span><span class="s13">-</span><span class="s24">1</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p21"><span class="s17"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s18"><i>[variant.get]</i></span><span class="s1"><i>, value access</i></span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> holds_alternative</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> T, class Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">    </span></span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">bool</span><span class="s21"> holds_alternative</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant</span><span class="s23">&lt;</span><span class="s21">Allocator, Types</span><span class="s23">...&gt;&amp;</span><span class="s25">)</span><span class="s21"> </span><span class="s22">noexcept</span><span class="s21">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s16">)</span><span class="s1">;<span class="Apple-converted-space">                                          </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;&amp;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;&amp;</span><span class="s16">)</span><span class="s1">; <span class="Apple-converted-space">                                        </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s16">)</span><span class="s1">;<span class="Apple-converted-space">                                    </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;&amp;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;&amp;</span><span class="s16">)</span><span class="s1">; <span class="Apple-converted-space">                                  </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p21"><span class="s1"><br>
</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s11">size_t I, </span><span class="s1">class Allocator, class... Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&amp;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;</span><span class="s16">)</span><span class="s1">;<span class="Apple-converted-space">                                          </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s11">size_t I, </span><span class="s1">class Allocator, class... Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&amp;&amp;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;&amp;</span><span class="s16">)</span><span class="s1">; <span class="Apple-converted-space">                                        </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s11">size_t I, </span><span class="s1">class Allocator, class... Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&amp;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span>get</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;</span><span class="s16">)</span><span class="s1">;<span class="Apple-converted-space">                                    </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s11">size_t I, </span><span class="s1">class Allocator, class... Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&amp;&amp;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">      </span>get</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s23">&amp;&amp;</span><span class="s25">)</span><span class="s21">; <span class="Apple-converted-space">                                  </span></span><span class="s26"><i>// freestanding-deleted</i></span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> T</span><span class="s13">&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s16">)</span><span class="s1">; <span class="Apple-converted-space">                              </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> T</span><span class="s13">&amp;&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;&amp;</span><span class="s16">)</span><span class="s1">; <span class="Apple-converted-space">                            </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> T</span><span class="s13">&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s16">)</span><span class="s1">; <span class="Apple-converted-space">                  </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> T</span><span class="s13">&amp;&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;&amp;</span><span class="s16">)</span><span class="s1">; <span class="Apple-converted-space">                </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p21"><span class="s1"><br>
</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class Allocator, class... Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> T</span><span class="s13">&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;</span><span class="s16">)</span><span class="s1">; <span class="Apple-converted-space">                              </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class Allocator, class... Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> T</span><span class="s13">&amp;&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;&amp;</span><span class="s16">)</span><span class="s1">; <span class="Apple-converted-space">                            </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class Allocator, class... Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> T</span><span class="s13">&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;</span><span class="s16">)</span><span class="s1">; <span class="Apple-converted-space">                  </span></span><span class="s14"><i>// freestanding-deleted</i></span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class Allocator, class... Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">    </span></span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">const</span><span class="s21"> T</span><span class="s23">&amp;&amp;</span><span class="s21"> get</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s23">&amp;&amp;</span><span class="s25">)</span><span class="s21">; <span class="Apple-converted-space">                </span></span><span class="s26"><i>// freestanding-deleted</i></span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s1">variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;*</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;*</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s11">size_t I, </span><span class="s1">class Allocator, class... Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s1">variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">*</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s11">size_t I, </span><span class="s1">class Allocator, class... Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">*</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;*</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s20">const</span><span class="s1"> T</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;*</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class Allocator, class... Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span>get_if</span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">*</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class Allocator, class... Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s20">const</span><span class="s1"> T</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">      </span>get_if</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s23">*</span><span class="s25">)</span><span class="s21"> </span><span class="s22">noexcept</span><span class="s21">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p21"><span class="s17"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s18"><i>[variant.relops]</i></span><span class="s1"><i>, relational operators</i></span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">==</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1">, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">!=</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1">, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">&lt;</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1">, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1">, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">&lt;=</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1">, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">&gt;=</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1">, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span><span class="s11"> </span><span class="s1">requires</span><span class="s11"> </span><span class="s16">(</span><span class="s18">three_way_comparable</span><span class="s13">&lt;</span><span class="s11">Types</span><span class="s13">&gt;</span><span class="s11"> </span><span class="s13">&amp;&amp;</span><span class="s11"> </span><span class="s13">...</span><span class="s16">)</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> common_comparison_category_t</span><span class="s13">&lt;</span><span class="s1">compare_three_way_result_t</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">&gt;...&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">operator</span><span class="s13">&lt;=&gt;</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1">, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class AllocatorLhs, AllocatorRhs, class... Types</span><span class="s13">&gt;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s11"> </span><span class="s1">bool</span><span class="s11"> </span><span class="s1">operator</span><span class="s13">==</span><span class="s16">(</span><span class="s1">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s16">)</span><span class="s11">;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class AllocatorLhs, AllocatorRhs, class... Types</span><span class="s13">&gt;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s11"> </span><span class="s1">bool</span><span class="s11"> </span><span class="s1">operator</span><span class="s13">!=</span><span class="s16">(</span><span class="s1">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s16">)</span><span class="s11">;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class AllocatorLhs, AllocatorRhs, class... Types</span><span class="s13">&gt;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s11"> </span><span class="s1">bool</span><span class="s11"> </span><span class="s1">operator</span><span class="s13">&lt;</span><span class="s16">(</span><span class="s1">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s16">)</span><span class="s11">;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class AllocatorLhs, AllocatorRhs, class... Types</span><span class="s13">&gt;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s11"> </span><span class="s1">bool</span><span class="s11"> </span><span class="s1">operator</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s16">)</span><span class="s11">;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class AllocatorLhs, AllocatorRhs, class... Types</span><span class="s13">&gt;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s11"> </span><span class="s1">bool</span><span class="s11"> </span><span class="s1">operator</span><span class="s13">&lt;=</span><span class="s16">(</span><span class="s1">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s16">)</span><span class="s11">;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class AllocatorLhs, AllocatorRhs, class... Types</span><span class="s13">&gt;</span></p>
<p class="p22"><span class="s27"><span class="Apple-converted-space">    </span></span><span class="s21">constexpr</span><span class="s27"> </span><span class="s21">bool</span><span class="s27"> </span><span class="s21">operator</span><span class="s23">&gt;=</span><span class="s25">(</span><span class="s21">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s25">)</span><span class="s27">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">AllocatorLhs, AllocatorRhs, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">requires</span><span class="s1"> </span><span class="s16">(<a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable"><span class="s28">three_way_comparable</span></a></span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> </span><span class="s13">...</span><span class="s16">)</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> common_comparison_category_t</span><span class="s13">&lt;</span><span class="s1">compare_three_way_result_t</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">&gt;...&gt;</span></p>
<p class="p22"><span class="s27"><span class="Apple-converted-space">      </span></span><span class="s21">operator</span><span class="s23">&lt;=&gt;</span><span class="s25">(</span><span class="s21">const basic_variant&lt;AllocatorLhs, Types...&gt;&amp;, const basic_variant&lt;AllocatorRhs, Types...&gt;&amp;</span><span class="s25">)</span><span class="s27">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p27"><span class="s17"><span class="Apple-converted-space">  </span></span><span class="s29"><i>// </i></span><span class="s1"><i>[variant.visit]</i></span><span class="s29"><i>, visitation</i></span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> Visitor, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Variants</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> <i>see below</i> visit</span><span class="s16">(</span><span class="s1">Visitor</span><span class="s13">&amp;&amp;</span><span class="s1">, Variants</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> R, </span><span class="s20">class</span><span class="s1"> Visitor, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Variants</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> R visit</span><span class="s16">(</span><span class="s1">Visitor</span><span class="s13">&amp;&amp;</span><span class="s1">, Variants</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p21"><span class="s17"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s18"><i>[variant.monostate]</i></span><span class="s1"><i>, class </i></span><span class="s19">monostate</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">struct</span><span class="s1"> monostate;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p21"><span class="s17"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s18"><i>[variant.monostate.relops]</i></span><span class="s1"><i>, </i></span><span class="s19">monostate</span><span class="s1"><i> relational operators</i></span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">constexpr</span><span class="s11"> </span><span class="s1">bool</span><span class="s11"> </span><span class="s1">operator</span><span class="s13">==</span><span class="s16">(</span><span class="s11">monostate, monostate</span><span class="s16">)</span><span class="s11"> </span><span class="s1">noexcept</span><span class="s11">;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> strong_ordering </span><span class="s20">operator</span><span class="s13">&lt;=&gt;</span><span class="s16">(</span><span class="s1">monostate, monostate</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p21"><span class="s17"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s18"><i>[variant.specalg]</i></span><span class="s1"><i>, specialized algorithms</i></span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">void</span><span class="s1"> swap</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1">, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1"><i>see below</i></span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">class Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">    </span></span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">void</span><span class="s21"> swap</span><span class="s25">(</span><span class="s21">basic_variant&lt;Allocator, Types</span><span class="s23">...&gt;&amp;</span><span class="s21">, basic_variant&lt;Allocator, Types</span><span class="s23">...&gt;&amp;</span><span class="s25">)</span><span class="s21"> </span><span class="s22">noexcept</span><span class="s25">(</span><span class="s21"><i>see below</i></span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p21"><span class="s17"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s18"><i>[variant.bad.access]</i></span><span class="s1"><i>, class </i></span><span class="s19">bad_variant_access</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">class</span><span class="s1"> bad_variant_access;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p21"><span class="s17"><span class="Apple-converted-space">  </span></span><span class="s1"><i>// </i></span><span class="s18"><i>[variant.hash]</i></span><span class="s1"><i>, hash support</i></span></p>
<p class="p22"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T</span><span class="s13">&gt;</span><span class="s11"> </span><span class="s1">struct</span><span class="s11"> hash;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">struct</span><span class="s1"> hash</span><span class="s13">&lt;</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;</span><span class="s1">;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">  </span></span><span class="s22">template</span><span class="s23">&lt;</span><span class="s21">class Allocator, </span><span class="s22">class</span><span class="s23">...</span><span class="s21"> Types</span><span class="s23">&gt;</span><span class="s21"> </span><span class="s22">struct</span><span class="s21"> hash</span><span class="s23">&lt;basic_</span><span class="s21">variant</span><span class="s23">&lt;Allocator, </span><span class="s21">Types</span><span class="s23">...&gt;&gt;</span><span class="s21">;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;&gt;</span><span class="s1"> </span><span class="s20">struct</span><span class="s1"> hash</span><span class="s13">&lt;</span><span class="s1">monostate</span><span class="s13">&gt;</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span>namespace pmr {</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">            </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    <span class="Apple-tab-span">	</span></span>using variant = basic_variant&lt;polymorphic_allocator&lt;&gt;, Types…&gt;;</span></p>
<p class="p6"><span class="s1"><span class="Apple-converted-space">  </span>}<span class="Apple-converted-space"> </span></span></p>
<p class="p29"><span class="s1">}</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p29"><span class="s1">Insert new section after <a href="https://eel.is/c++draft/variant#variant"><span class="s30">22.6.3</span></a></span><span class="s11"> Class template variant</span><span class="s31"> <a href="https://eel.is/c++draft/variant.variant"><span class="s32">[variant.variant]</span></a></span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p30"><span class="s21"><b>22.6.x Class template basic_variant</b></span><span class="s33"><b> [variant.basic.variant]</b></span></p>
<p class="p31"><span class="s11">X.x.x. 1 <b>General</b></span><span class="s34"><b> </b><a href="https://eel.is/c++draft/variant.variant.general"><span class="s35"><b>[</b></span></a></span><span class="s1"><b>variant.basic.variant.general]</b></span></p>
<p class="p22"><span class="s1"><br>
</span></p>
<p class="p25"><span class="s1">namespace</span><span class="s11"> std </span><span class="s16">{</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s13"> </span><span class="s1">Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">class</span><span class="s1"> basic_variant </span><span class="s16">{</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">  </span></span><span class="s1">public</span><span class="s13">:</span></p>
<p class="p32"><span class="s1"><br>
</span></p>
<p class="p33"><span class="s20"><span class="Apple-converted-space">    </span>using</span><span class="s1"> allocator_type<span class="Apple-converted-space">  </span></span><span class="s13">=</span><span class="s1"> Allocator;</span></p>
<p class="p28"><span class="s1"><br>
</span></p>
<p class="p31"><span class="s17"><span class="Apple-converted-space">    </span></span><span class="s29"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s28"><i>[</i></span></a></span><span class="s1"><i>variant.basic.ctor]</i></span><span class="s29"><i>, constructors</i></span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">()</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1"><i>see below</i></span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">basic_variant</span><span class="s13">&amp;&amp;</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1"><i>see below</i></span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">T</span><span class="s13">&amp;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p25"><span class="s1"><span class="Apple-converted-space">   </span>template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> AllocatorU</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> basic_variant</span><span class="s13">&lt;U, Types…&gt;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">   </span>template&lt;class AllocatorU&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span>constexpr basic_variant(basic_variant&lt;U, Types…&gt;&amp;&amp;) </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1"><i>see below</i></span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span>constexpr basic_variant(const variant&lt;Types…&gt;&amp;);</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span>constexpr basic_variant(variant&lt;Types…&gt;&amp;&amp;);</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">in_place_type_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s1">, Args</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s11"> U, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">in_place_type_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s1">, initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;</span><span class="s1">, Args</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">   </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">in_place_index_t</span><span class="s13">&lt;</span><span class="s1">I</span><span class="s13">&gt;</span><span class="s1">, Args</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s1"> U, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">in_place_index_t</span><span class="s13">&lt;</span><span class="s1">I</span><span class="s13">&gt;</span><span class="s1">, initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;</span><span class="s1">, Args</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p34"><span class="s1"><br>
</span></p>
<p class="p35"><span class="s1"><i>// allocator-extended constructors</i></span></p>
<p class="p33"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const allocator_type a</span><span class="s16">)</span><span class="s1"> ;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const allocator_type a, </span><span class="s20">const</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const allocator_type a, </span><span class="s16">basic_variant</span><span class="s13">&amp;&amp;</span><span class="s16">)</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const allocator_type a, T</span><span class="s13">&amp;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">   </span>template&lt;class AllocatorU&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span>constexpr basic_variant(allocator_arg_t, const allocator_type a, const basic_variant&lt;U, Types…&gt;&amp;);</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">   </span>template&lt;class AllocatorU&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span>constexpr basic_variant(allocator_arg_t, const allocator_type a, basic_variant&lt;U, Types…&gt;&amp;&amp;);</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span>constexpr basic_variant(allocator_arg_t, const allocator_type a, const variant&lt;Types…&gt;&amp;);</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span>constexpr basic_variant(allocator_arg_t, const allocator_type a, variant&lt;Types…&gt;&amp;&amp;);</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const allocator_type a, in_place_type_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s1">, Args</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s11"> U, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const allocator_type a, in_place_type_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s1">, initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;</span><span class="s1">, Args</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const allocator_type a, in_place_index_t</span><span class="s13">&lt;</span><span class="s1">I</span><span class="s13">&gt;</span><span class="s1">, Args</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s1"> U, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const allocator_type a, in_place_index_t</span><span class="s13">&lt;</span><span class="s1">I</span><span class="s13">&gt;</span><span class="s1">, initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;</span><span class="s1">, Args</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p31"><span class="s17"><span class="Apple-converted-space">    </span></span><span class="s29"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s28"><i>[</i></span></a></span><span class="s1"><i>variant.basic.dtor]</i></span><span class="s29"><i>, destructor</i></span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s13">~ </span><span class="s1">basic_variant</span><span class="s16">()</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p31"><span class="s17"><span class="Apple-converted-space">    </span></span><span class="s29"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s28"><i>[</i></span></a></span><span class="s1"><i>variant.basic.assign]</i></span><span class="s29"><i> assignment</i></span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s1">basic_variant&amp;&amp;</span><span class="s16">) </span><span class="s11">noexcept(<i>see below</i>)</span><span class="s1">;;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span>template&lt;class AllocatorU&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s1">const basic_variant&lt;U, Types…&gt;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span>template&lt;class AllocatorU&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s1">basic_variant&lt;U, Types…&gt;</span><span class="s13">&amp;&amp;</span><span class="s16">) </span><span class="s11">noexcept(<i>see below</i>)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s1">const variant&lt;Types…&gt;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span>constexpr basic_variant&amp; operator=(variant&lt;Types…&gt;&amp;&amp; </span><span class="s11">noexcept(<i>see below</i>)</span><span class="s1">);</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T</span><span class="s13">&gt;</span><span class="s11"> </span><span class="s1">constexpr</span><span class="s11"> basic_variant</span><span class="s13">&amp;</span><span class="s11"> </span><span class="s1">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s11">T</span><span class="s13">&amp;&amp;</span><span class="s16">)</span><span class="s11"> </span><span class="s1">noexcept</span><span class="s16">(</span><span class="s11"><i>see below</i></span><span class="s16">)</span><span class="s11">;<span class="Apple-converted-space">   </span></span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p31"><span class="s17"><span class="Apple-converted-space">    </span></span><span class="s29"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s28"><i>[</i></span></a></span><span class="s1"><i>variant.basic.mod]</i></span><span class="s29"><i>, modifiers</i></span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> T</span><span class="s13">&amp;</span><span class="s1"> emplace</span><span class="s16">(</span><span class="s1">Args</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s11"> U, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> T</span><span class="s13">&amp;</span><span class="s1"> emplace</span><span class="s16">(</span><span class="s1">initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;</span><span class="s1">, Args</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&amp;</span><span class="s1"> emplace</span><span class="s16">(</span><span class="s1">Args</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s1"> U, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&amp;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">        </span>emplace</span><span class="s16">(</span><span class="s1">initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;</span><span class="s1">, Args</span><span class="s13">&amp;&amp;...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p31"><span class="s17"><span class="Apple-converted-space">    </span></span><span class="s29"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s28"><i>[</i></span></a></span><span class="s1"><i>variant.basic.status]</i></span><span class="s29"><i>, value status</i></span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> valueless_by_exception</span><span class="s16">()</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p25"><span class="s11"><span class="Apple-converted-space">    </span></span><span class="s1">constexpr</span><span class="s11"> size_t index</span><span class="s16">()</span><span class="s11"> </span><span class="s1">const</span><span class="s11"> </span><span class="s1">noexcept</span><span class="s11">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p36"><span class="s29"><i><span class="Apple-converted-space">   </span>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s28"><i>[</i></span></a></span><span class="s1"><i>variant.basic.al]</i></span><span class="s29"><i>, allocator</i></span></p>
<p class="p33"><span class="s1"><span class="Apple-converted-space">    </span>allocator_type get_allocator</span><span class="s16">()</span><span class="s1"> </span><span class="s20">const</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p31"><span class="s17"><span class="Apple-converted-space">    </span></span><span class="s29"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s28"><i>[</i></span></a></span><span class="s1"><i>variant.basic.swap]</i></span><span class="s29"><i>, swap</i></span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">void</span><span class="s1"> swap</span><span class="s16">(</span><span class="s1">basic_variant</span><span class="s13">&amp;</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1"><i>see below</i></span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p31"><span class="s17"><span class="Apple-converted-space">    </span></span><span class="s29"><i>// </i><a href="https://eel.is/c++draft/variant#ctor"><span class="s28"><i>[</i></span></a></span><span class="s1"><i>variant.basic.visit]</i></span><span class="s29"><i> visitation</i></span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> Self, </span><span class="s20">class</span><span class="s1"> Visitor</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">decltype</span><span class="s16">(</span><span class="s20">auto</span><span class="s16">)</span><span class="s1"> visit</span><span class="s16">(</span><span class="s20">this</span><span class="s1"> Self</span><span class="s13">&amp;&amp;</span><span class="s1">, Visitor</span><span class="s13">&amp;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> R, </span><span class="s20">class</span><span class="s1"> Self, </span><span class="s20">class</span><span class="s1"> Visitor</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">      </span></span><span class="s20">constexpr</span><span class="s1"> R visit</span><span class="s16">(</span><span class="s20">this</span><span class="s1"> Self</span><span class="s13">&amp;&amp;</span><span class="s1">, Visitor</span><span class="s13">&amp;&amp;</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p37"><span class="s1">private</span><span class="s13">:</span></p>
<p class="p33"><span class="s1"><span class="Apple-converted-space">   </span>allocator_type <i>alloc</i>; <span class="Apple-converted-space">        </span></span><span class="s14"><i>// exposition only</i></span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s16">}</span><span class="s1">;</span></p>
<p class="p29"><span class="s21">}</span></p>
<p class="p38"><span class="s1"><br>
</span></p>
<p class="p39"><span class="s1">Any instance of basic_variant at any given time either holds a value of one of its alternative types or holds no value. When an instance of basic_variant holds a value of alternative type T, it means that a value of type T, referred to as the basic_variant object's <a href="https://eel.is/c++draft/variant#def:contained_value,variant"><span class="s35"><i>contained value</i></span></a>, is allocated within the storage of the basic_variant object<a href="https://eel.is/c++draft/variant#variant.general-1.sentence-2"><span class="s35">.</span></a> Implementations are not permitted to use additional storage, such as dynamic memory, to allocate the contained value.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p39"><span class="s1">All types in Types shall meet the <i>Cpp17Destructible</i> requirements (Table </span><span class="s18">35)</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p39"><span class="s1">A program that instantiates the definition of basic_variant with less than 2 template arguments is ill-formed.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p39"><span class="s1">Template argument Allocator shall satisfy the <i>Cpp17Allocator </i>requirements (</span><span class="s36">16.4.4.6.1</span><span class="s1">). A an instance of Allocator is maintained by the basic_variant object during the lifetime of the object or until the allocator is replaced. The allocator instance is set at object creation time and may be replaced only via assignment or swap as specified below. The allocator instance is used to pass to uses-allocator construction of an alternative as specified below.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p19"><span class="s37">If a program declares an explicit or partial specialization of basic_variant, the program is ill-formed, no diagnostic required</span></p>
<h4 style="margin: 0.0px 0.0px 16.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><br>
</span></h4>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000dc; background-color: #31ff0d"><span class="s1"><b>X.x.x.2 </b></span><span class="s11"><b>Constructors </b></span><span class="s1"><b>[variant.basic.ctor]</b></span></h4>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d"><span class="s1">In the descriptions that follow, let <i>i</i> be in the range [</span><span class="s24">0</span><span class="s1">, </span><span class="s20">sizeof</span><span class="s13">...</span><span class="s16">(</span><span class="s1">Types</span><span class="s16">)</span><span class="s1">), and T</span><span class="s38"><i>i</i></span><span class="s1"> be the <i>i</i></span><span class="s39">th</span><span class="s1"> type in Types.</span></h4>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">()</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1"><i>see below</i></span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>: is_default_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38">0</span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: alloc is default-initialized. If allocator_traits</span><span class="s13">&lt;</span><span class="s1">Allocator</span><span class="s13">&gt;::is_always_equal::</span><span class="s1">value is false,<span class="Apple-converted-space">  </span>an alternative of type T</span><span class="s38">0</span><span class="s1"> is constructed by uses-allocator construction with allocator </span><span class="s13">alloc</span><span class="s1"> and no constructor arguments. Otherwise, T</span><span class="s38">0</span><span class="s1"> is value-initialized.<span class="Apple-tab-span">	</span></span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Postconditions</i>: valueless_by_exception</span><span class="s16">()</span><span class="s1"> is </span><span class="s24">false</span><span class="s1"> and index</span><span class="s16">()</span><span class="s1"> is </span><span class="s24">0</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by the value-initialization of T</span><span class="s38">0</span><span class="s40">.</span></p>
<p class="p43"><span class="s40"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Remarks</i>: This function is </span><span class="s20">constexpr</span><span class="s1"> if and only if the selected constructor of the alternative type T</span><span class="s38">0</span><span class="s41"> </span><span class="s1">and the allocator alloc is constexpr-suitable (<a href="https://eel.is/c++draft/dcl.constexpr"><span class="s42">[dcl.constexpr]</span></a>)<a href="https://eel.is/c++draft/variant#ctor-6.sentence-1"><span class="s35">.</span></a> The exception specification is equivalent to is_nothrow_default_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38">0</span><span class="s13">&gt; &amp;&amp; <span class="Apple-converted-space">  </span>(</span><span class="s1">allocator_traits&lt;Allocator&gt;::is_always_equal::value || !uses_allocator_v&lt;remove_cv_t &lt;T</span><span class="s38">0</span><span class="s1">&gt;&gt;).</span><span class="s19"><span class="Apple-tab-span">	</span>[<i>Note </i></span><span class="s43"><i>:</i></span><span class="s44"> </span><span class="s19">See also class monostate<a href="https://eel.is/c++draft/variant#ctor-6.sentence-3"><span class="s45">.</span></a> — <i>end note</i>]</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> w</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Effects</i>: If allocator_traits&lt;Allocator&gt;::is_always_equal::value is true, alloc is default-initialized. Otherwise, alloc is direct-initialized with an allocator_traits&lt;Allocator&gt;::select_on_container_copy_construction(w.get_allocator()). If w holds a value, initializes the variant to hold the same alternative as w and direct-initializes the contained value with <i>GET</i></span><span class="s13">&lt;</span><span class="s1">j</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1">, where j is w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()<a href="https://eel.is/c++draft/variant#ctor-7.sentence-1"><span class="s46">.</span></a></span><span class="s1"> Otherwise, initializes the variant to not hold a value.</span></p>
<p class="p43"><span class="s47"><a href="http://github.com/Eelis/draft/tree/7faaaf22a11d54ad00e40cc8d7fbee90db8b0837/source/utilities.tex#L5127"><span class="Apple-tab-span">	</span></a></span><span class="s1"><i>Throws</i>: Any exception thrown by direct-initializing any T</span><span class="s38"><i>i</i></span><span class="s1"> for all <i>i</i>.</span></p>
<p class="p43"><span class="s18"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Remarks</i>: This constructor is defined as deleted unless is_copy_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> for all <i>i</i><a href="https://eel.is/c++draft/variant#ctor-9.sentence-1"><span class="s35">.</span></a> This constructor is trivial if</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_copy_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> for all <i>i</i>,</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- allocator_traits&lt;Allocator&gt;::is_always_equal::value is true, and</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_copy_constructible_v&lt;Allocator&gt; is true</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">basic_variant </span><span class="s13">&amp;&amp;</span><span class="s1"> w</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1"><i>see below</i></span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>: is_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> for all <i>i</i><a href="https://eel.is/c++draft/variant#ctor-10.sentence-1"><span class="s35">.</span></a>.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: alloc is direct-initialized with w.get_allocator(). If w holds a value, initializes the variant to hold the same alternative as w and direct-initializes the contained value with <i>GET</i></span><span class="s13">&lt;</span><span class="s1">j</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">std</span><span class="s13"> :: </span><span class="s1">move</span><span class="s16">(</span><span class="s1">w</span><span class="s16">))</span><span class="s1">, where j is w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()<a href="https://eel.is/c++draft/variant#ctor-11.sentence-1"><span class="s46">.</span></a></span><span class="s1"> Otherwise, initializes the variant to not hold a value<a href="https://eel.is/c++draft/variant#ctor-11.sentence-2"><span class="s35">.</span></a></span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by move-constructing any T</span><span class="s38"><i>i</i></span><span class="s1"> for all <i>.</i></span></p>
<p class="p43"><span class="s48"><a href="https://eel.is/c++draft/variant#ctor-12.sentence-1"><span class="Apple-tab-span">	</span></a></span><span class="s1"><i>Remarks</i>: The exception specification is equivalent to the logical and of is_nothrow_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> for all <i>i</i>. This constructor is trivial if :</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_move_constructible_v&lt;T</span><span class="s38"><i>i</i></span><span class="s1">&gt; is true for all <i>i</i>, and</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_move_constructible_v&lt;Allocator&gt; is true.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p25"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T</span><span class="s13">&gt;</span><span class="s11"> </span><span class="s1">constexpr</span><span class="s11"> basic_variant</span><span class="s16">(</span><span class="s11">T</span><span class="s13">&amp;&amp;</span><span class="s11"> t</span><span class="s16">)</span><span class="s11"> ;</span></p>
<p class="p43"><span class="s1">Let T</span><span class="s38"><i>j</i></span><span class="s1"> be a type that is determined as follows: build an imaginary function <i>FUN</i></span><span class="s16">(</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s16">)</span><span class="s1"> for each alternative type T</span><span class="s38"><i>i</i></span><span class="s1"> for which T</span><span class="s38"><i>i</i></span><span class="s1"> x</span><span class="s16">[]</span><span class="s1"> </span><span class="s13">=</span><span class="s1"> </span><span class="s16">{</span><span class="s1">std</span><span class="s13"> :: </span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">t</span><span class="s16">)}</span><span class="s1">; is well-formed for some invented variable x<a href="https://eel.is/c++draft/variant#ctor-14.sentence-1"><span class="s35">.</span></a> The overload <i>FUN</i></span><span class="s16">(</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s16">)</span><span class="s1"> selected by overload resolution for the expression <i>FUN</i></span><span class="s16">(</span><span class="s1">std</span><span class="s13"> :: </span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1"> t</span><span class="s16">))</span><span class="s1"> defines the alternative T</span><span class="s38"><i>j</i></span><span class="s1"> which is the type of the contained value after construction.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>:<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- </span><span class="s20">sizeof</span><span class="s13">...</span><span class="s16">(</span><span class="s1">Types</span><span class="s16">)</span><span class="s1"> is nonzero,</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_same_v</span><span class="s13">&lt;</span><span class="s1">remove_cvref_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s1">, variant</span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">false</span><span class="s1">,</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- remove_cvref_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s1"> is neither a specialization of in_place_type_t nor a specialization of in_place_index_t,</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s1">, T</span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">, and<span class="Apple-tab-span">	</span>the expression <i>FUN</i></span><span class="s16">(</span><span class="s1"> std</span><span class="s13"> :: </span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">t</span><span class="s16">))</span><span class="s1"> (with <i>FUN</i> being the above-mentioned set of imaginary functions) is well-formed.<span class="Apple-converted-space"> </span></span></p>
<p class="p26"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[<i>Note </i>:</span><span class="s44"> </span></p>
<p class="p26"><span class="s44"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">basic_variant</span><span class="s13">&lt;</span><span class="s1">string, string</span><span class="s13">&gt;</span><span class="s1"> v</span><span class="s16">(</span><span class="s24">"abc"</span><span class="s16">)</span><span class="s1">;</span></p>
<ul class="ul2">
  <ul class="ul3">
    <li class="li26"><span class="s6"></span><span class="s1"><span class="Apple-tab-span">	</span></span><span class="s44"><span class="Apple-converted-space">    </span></span><span class="s1"><span class="Apple-converted-space">  </span>is ill-formed, as both alternative types have an equally viable constructor for the argument<a href="https://eel.is/c++draft/variant#ctor-15.5.sentence-2"><span class="s32">.</span></a> — <i>end note</i>]</span></li>
  </ul>
</ul>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>: alloc is default-initialized.<span class="Apple-converted-space">  </span>If allocator_traits&lt;Allocator&gt;::is_always_equal::value is false, an alternative of type T</span><span class="s38">j</span><span class="s1"> is constructed by uses-allocator construction with allocator alloc and std::forward&lt;T&gt;(t). Otherwise, an alternative of type T</span><span class="s38">j </span><span class="s1">is direct-non-list-initialized with std</span><span class="s13">::</span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">t</span><span class="s16">)</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Postconditions</i>: holds_alternative</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s13">*</span><span class="s20">this</span><span class="s16">)</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Throws</i>: Any exception thrown by the initialization of the selected alternative T</span><span class="s38"><i>j</i></span><span class="s41"><i>.</i></span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Remarks</i>: If Allocator’s default constructor and T</span><span class="s38"><i>j</i></span><span class="s1">'s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> AllocatorU</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">const basic_variant&lt;AllocatorU, Types…&gt;&amp; w</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>:  is_copy_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> for all <i>i</i></span><span class="s49">.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>: If allocator_traits&lt;Allocator&gt;::is_always_equal::value is true, alloc is default-initialized. Otherwise, alloc is direct-initialized with an allocator_traits&lt;Allocator&gt;::select_on_container_copy_construction(w.get_allocator()). If w holds a value, initializes the variant to hold the same alternative as w and direct-initializes the contained value with <i>GET</i></span><span class="s13">&lt;</span><span class="s1">j</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1">, where j is w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()<a href="https://eel.is/c++draft/variant#ctor-7.sentence-1"><span class="s46">.</span></a></span><span class="s1"> Otherwise, initializes the variant to not hold a value.</span></p>
<p class="p43"><span class="s47"><a href="http://github.com/Eelis/draft/tree/7faaaf22a11d54ad00e40cc8d7fbee90db8b0837/source/utilities.tex#L5127"><span class="Apple-tab-span">	</span></a></span><span class="s1"><i>Throws</i>: Any exception thrown by direct-initializing any T</span><span class="s38"><i>i</i></span><span class="s1"> for all <i>i</i>.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: If is_convertible_v&lt;const AllocatorU&amp;, Allocator&gt; is false, this constructor is defined as deleted. If Allocator’s default constructor and T</span><span class="s38"><i>i</i></span><span class="s1">’s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> AllocatorU</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">basic_variant&lt;AllocatorU, Types…&gt;&amp;&amp; w</span><span class="s16">) </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1"><i>see below</i></span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: is_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> for all <i>i</i><a href="https://eel.is/c++draft/variant#ctor-10.sentence-1"><span class="s35">.</span></a>.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: alloc is direct-initialized with w.get_allocator(). If w holds a value, initializes the variant to hold the same alternative as w and direct-initializes the contained value with <i>GET</i></span><span class="s13">&lt;</span><span class="s1">j</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">std</span><span class="s13"> :: </span><span class="s1">move</span><span class="s16">(</span><span class="s1">w</span><span class="s16">))</span><span class="s1">, where j is w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()<a href="https://eel.is/c++draft/variant#ctor-11.sentence-1"><span class="s46">.</span></a></span><span class="s1"> Otherwise, initializes the variant to not hold a value<a href="https://eel.is/c++draft/variant#ctor-11.sentence-2"><span class="s35">.</span></a></span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by move-constructing any T</span><span class="s38"><i>i</i></span><span class="s1"> for all <i>.</i></span></p>
<p class="p43"><span class="s48"><a href="https://eel.is/c++draft/variant#ctor-12.sentence-1"><span class="Apple-tab-span">	</span></a></span><span class="s1"><i>Remarks</i>: The exception specification is equivalent to the logical and of is_nothrow_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> for all <i>i</i>.<span class="Apple-converted-space">  </span>If is_convertible_v&lt;const AllocatorU&amp;, Allocator&gt; is false, this constructor is defined as deleted. If Allocator’s default constructor and T</span><span class="s38"><i>i</i></span><span class="s1">’s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">const variant&lt;Types…&gt;&amp; w</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p44"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>: alloc is default-initialized. If w holds a value, initializes the variant to hold the same alternative as w and constructs the contained value by uses-allocator construction with allocator alloc and <i>GET</i>&lt;j&gt;(w), where j is w.index()<a href="https://eel.is/c++draft/variant#ctor-11.sentence-1"><span class="s35">.</span></a> Otherwise, initializes the variant to not hold a value.</span></p>
<p class="p44"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by move-constructing any T</span><span class="s38"><i>i</i></span><span class="s1"> for all.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: If Allocator’s default constructor and T</span><span class="s38"><i>i</i></span><span class="s1">’s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p26"><span class="s1">constexpr explicit basic_variant(variant&lt;Types…&gt;&amp;&amp; w);</span></p>
<p class="p44"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>: alloc is default-initialized. If w holds a value, initializes the variant to hold the same alternative as w and constructs the contained value by uses-allocator construction with allocator alloc and <i>GET</i>&lt;j&gt;(std::move(w)), where j is w.index()<a href="https://eel.is/c++draft/variant#ctor-11.sentence-1"><span class="s35">.</span></a> Otherwise, initializes the variant to not hold a value.</span></p>
<p class="p44"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by move-constructing any T</span><span class="s38"><i>i</i></span><span class="s1"> for all.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: If Allocator’s default constructor and T</span><span class="s38"><i>i</i></span><span class="s1">’s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p25"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s11"> U, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">in_place_type_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s1">, initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;</span><span class="s1"> il, Args</span><span class="s13">&amp;&amp;...</span><span class="s1"> args</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>:</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- There is exactly one occurrence of T in Types</span><span class="s13">...</span><span class="s1"> and</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s13">&lt;</span><span class="s1">T, initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;&amp;</span><span class="s1">, Args</span><span class="s13">...&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: alloc is default-initialized.<span class="Apple-converted-space">  </span>An alternative of type T is constructed by uses-allocator construction with allocator alloc and il, std</span><span class="s13"> :: </span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">Args</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1"> args</span><span class="s16">)</span><span class="s13">...</span><span class="s1"> .</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Postconditions</i>: holds_alternative</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s13">*</span><span class="s20">this</span><span class="s16">)</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by calling the selected constructor of T.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: If Allocator’s default constructor and T’s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p26"><span class="s50">t</span><span class="s20">emplate</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Args</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">in_place_index_t</span><span class="s13">&lt;</span><span class="s1">I</span><span class="s13">&gt;</span><span class="s1">, Args</span><span class="s13">&amp;&amp;...</span><span class="s1"> args</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>:</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- I is less than </span><span class="s20">sizeof</span><span class="s13">...</span><span class="s16">(</span><span class="s1">Types</span><span class="s16">)</span><span class="s1"> and</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>I</i></span><span class="s1">, Args</span><span class="s13">...&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: alloc is default-initialized.<span class="Apple-converted-space">  </span>An alternative of type T</span><span class="s38"><i>I</i></span><span class="s1"> is constructed by uses-allocator construction with allocator alloc and std</span><span class="s13"> :: </span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">Args</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">args</span><span class="s16">)</span><span class="s13">...</span><span class="s1"> .</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Postconditions</i>: index</span><span class="s16">()</span><span class="s1"> is I.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by calling the selected constructor of T</span><span class="s38"><i>I</i></span><span class="s41"><i>.</i></span></p>
<p class="p43"><span class="s41"><i><span class="Apple-tab-span">	</span></i></span><span class="s1"><i>Remarks</i>: If Allocator’s default constructor and T</span><span class="s38"><i>I</i></span><span class="s41"><i> </i></span><span class="s1">'s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p26"><span class="s50">t</span><span class="s20">emplate</span><span class="s13">&lt;</span><span class="s1">size_t I, , </span><span class="s20">class</span><span class="s1"> U,<span class="Apple-converted-space">  </span></span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Args</span><span class="s13">&gt;</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">in_place_index_t</span><span class="s13">&lt;</span><span class="s1">I</span><span class="s13">&gt;</span><span class="s1">,<span class="Apple-converted-space">  </span>initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;</span><span class="s1"> il,<span class="Apple-converted-space">  </span>Args</span><span class="s13">&amp;&amp;...</span><span class="s1"> args</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>:</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- I is less than </span><span class="s20">sizeof</span><span class="s13">...</span><span class="s16">(</span><span class="s1">Types</span><span class="s16">)</span><span class="s1"> and</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>I</i></span><span class="s1">, initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;&amp;</span><span class="s1">, Args</span><span class="s13">...&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: alloc is default-initialized.<span class="Apple-converted-space">  </span>An alternative of type T</span><span class="s38"><i>I</i></span><span class="s1"> is constructed by uses-allocator construction with allocator alloc and il, std :: forward&lt;Args&gt;(args)... .</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Postconditions</i>: index</span><span class="s16">()</span><span class="s1"> is I.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown by calling the selected constructor of T</span><span class="s38"><i>I</i></span><span class="s41"><i>.</i></span></p>
<p class="p43"><span class="s41"><i><span class="Apple-tab-span">	</span></i></span><span class="s1"><i>Remarks</i>: If Allocator’s default constructor and T</span><span class="s38"><i>I</i></span><span class="s41"><i> </i></span><span class="s1">'s selected constructor are constexpr constructors, this constructor is a constexpr constructor.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a, </span><span class="s20">const</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> w</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a, basic_variant</span><span class="s13">&amp;&amp;</span><span class="s1"> w</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1">template&lt;class T&gt; constexpr basic_variant(allocator_arg_t, const Allocator&amp; a, T&amp;&amp; t);</span></p>
<p class="p26"><span class="s1">template&lt;class AllocatorU&gt; constexpr basic_variant(allocator_arg_t, const allocator_type a, const basic_variant&lt;U, Types…&gt;&amp;);</span></p>
<p class="p26"><span class="s1">template&lt;class AllocatorU&gt; constexpr basic_variant(allocator_arg_t, const allocator_type a, basic_variant&lt;U, Types…&gt;&amp;&amp;);</span></p>
<p class="p26"><span class="s1">constexpr basic_variant(allocator_arg_t, const allocator_type a, const variant&lt;Types…&gt;&amp;);</span></p>
<p class="p26"><span class="s1">constexpr basic_variant(allocator_arg_t, const allocator_type a, variant&lt;Types…&gt;&amp;&amp;);</span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> T, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Args</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a, in_place_type_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s1">, Args</span><span class="s13">&amp;&amp;...</span><span class="s1"> args</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p25"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s11"> U, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a, in_place_type_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s1">, initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;</span><span class="s1"> il, Args</span><span class="s13">&amp;&amp;...</span><span class="s1"> args</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s50">t</span><span class="s20">emplate</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Args</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">explicit</span><span class="s1"> basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg_t, const Allocator&amp; a, in_place_index_t</span><span class="s13">&lt;</span><span class="s1">I</span><span class="s13">&gt;</span><span class="s1">, Args</span><span class="s13">&amp;&amp;...</span><span class="s1"> args</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s51">t</span><span class="s1">emplate&lt;size_t I, , class U,<span class="Apple-converted-space">  </span>class... Args&gt;<span class="Apple-converted-space"> </span></span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span>constexpr explicit basic_variant(allocator_arg_t, const Allocator&amp; a, in_place_index_t&lt;I&gt;,<span class="Apple-converted-space">  </span>initializer_list&lt;U&gt; il,<span class="Apple-converted-space">  </span>Args&amp;&amp;... args);</span></p>
<p class="p19"><span class="s21"><span class="Apple-tab-span">	</span><i>Effects</i>: Behaves the same as non allocator extended version of the constructor except it initializes alloc with the specified allocator before initializing the alternative, if any, by uses-allocator construction.</span></p>
<p class="p15"><span class="s1"><br>
[Question to LWG : do we need to specify how triviality differs for these constructors?]<span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d"><span class="s15"><b>x.x.x.x</b></span><span class="s52"><b> Destructor </b></span><span class="s1">[variant.basic.dtor]</span></h4>
<h4 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d"><span class="s20">constexpr</span><span class="s1"> </span><span class="s13">~ </span><span class="s1">basic_variant</span><span class="s16">()</span><span class="s1">;</span></h4>
<p class="p43"><span class="s1"><i>Effects</i>: If valueless_by_exception</span><span class="s16">()</span><span class="s1"> is </span><span class="s24">false</span><span class="s1">, destroys the currently contained value.</span></p>
<p class="p19"><span class="s21"><i>Remarks</i>: If is_trivially_destructible_v</span><span class="s23">&lt;</span><span class="s21">T</span><span class="s53"><i>i</i></span><span class="s23">&gt;</span><span class="s21"> is </span><span class="s54">true</span><span class="s21"> for all T</span><span class="s53"><i>i</i></span><span class="s21">, then this destructor is trivial.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p46"><span class="s55"><b>x.x.x.x</b></span><span class="s56"><b> Assignment </b></span><span class="s21">[variant.basic.assign]</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> rhs</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span>Let <i>j</i> be rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">().</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>:<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If allocator_traits&lt;Allocator&gt;::propagate_on_container_copy_assignment::value is </span><span class="s24">true, sets alloc to rhs.alloc</span></p>
<p class="p19"><span class="s21"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If neither </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> nor rhs holds a value, there is no additional effect.</span><span class="s40"><br>
</span><span class="s21"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> holds a value but rhs does not, destroys the value contained in </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> and sets </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> to not hold a value</span><span class="s40"><br>
</span><span class="s21"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if index</span><span class="s25">()</span><span class="s21"> </span><span class="s23">==</span><span class="s21"> <i>j</i>, assigns the value contained in rhs to the value contained in </span><span class="s23">*</span><span class="s22">this</span><span class="s21">,</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- uses_allocator_v&lt;remove_cv_t&lt;Tj&gt;&gt;, Allocator&gt; is false or allocator_traits&lt;Allocator&gt;::is_always_equal::value is true, and<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- either is_nothrow_copy_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> or is_nothrow_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">false,</span></p>
<p class="p43"><span class="s19"><span class="Apple-converted-space">                           </span></span><span class="s1">destroys the current alternative, if any, and direct-non-list-initializes the contained value of type T</span><span class="s38">j</span><span class="s41"> </span><span class="s1">with GET</span><span class="s13">&lt;</span><span class="s1">j</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">rhs</span><span class="s16">))</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, equivalent to </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s1">basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg, alloc, rhs</span><span class="s16">))</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i>Postconditions</i>: index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">==</span><span class="s1"> rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span></p>
<p class="p43"><span class="s1"><i>Returns</i>: </span><span class="s13">*</span><span class="s20">this</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i>Remarks</i>: This operator is defined as deleted unless is_copy_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_copy_assignable_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> for all <i>i</i><a href="https://eel.is/c++draft/variant#assign-5.sentence-1"><span class="s35">.</span></a> The assignment operator is trivial if :</span></p>
<p class="p43"><span class="s1">-  is_trivially_copy_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_trivially_copy_assignable_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_trivially_destructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> for all <i>I,</i></span></p>
<p class="p43"><span class="s1">-  is_trivially_copy_constructible_v</span><span class="s13">&lt;</span><span class="s1">Allocator</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_trivially_copy_assignable_v</span><span class="s13">&lt;</span><span class="s1">Allocator</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_trivially_destructible_v</span><span class="s13">&lt;</span><span class="s1">Allocator</span><span class="s13">&gt;</span><span class="s1"> is true, and</span></p>
<p class="p43"><span class="s24">- </span><span class="s1">allocator_traits&lt;Allocator&gt;::is_always_equal::value is true.</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s1">basic_variant</span><span class="s13">&amp;&amp;</span><span class="s1"> rhs</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1"><i>see below</i></span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span>Let <i>j</i> be rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: is_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_move_assignable_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> for all <i>i</i>.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>:</span></p>
<p class="p19"><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- If allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value is true, sets alloc to rhs.alloc</span><span class="s1"><br>
</span><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- If neither </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> nor rhs holds a value, there is no effect.</span></p>
<p class="p19"><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise, if </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> holds a value but rhs does not, destroys the value contained in </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> and sets </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> to not hold a value.</span><span class="s40"><br>
</span><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise, if index</span><span class="s25">()</span><span class="s21"> </span><span class="s23">==</span><span class="s21"> <i>j</i>, assigns <i>GET</i></span><span class="s23">&lt;</span><span class="s21"><i>j</i></span><span class="s23">&gt;</span><span class="s25">(</span><span class="s21">std</span><span class="s23">::</span><span class="s21">move</span><span class="s25">(</span><span class="s21">rhs</span><span class="s25">))</span><span class="s21"> to the value contained in </span><span class="s23">*</span><span class="s22">this</span><span class="s21">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise,<span class="Apple-converted-space">  </span>if allocator_traits&lt;Allocator&gt;::is_always_equal::value is true or allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value is true, destroys the current alternative, if any, and direct-non-list-initializes the contained value of type T</span><span class="s38">j</span><span class="s41"> </span><span class="s1">with GET</span><span class="s13">&lt;</span><span class="s1">j</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">std</span><span class="s13">::</span><span class="s1">move</span><span class="s16">(</span><span class="s1">rhs</span><span class="s16">)))</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space">                      </span>- Otherwise equivalent to emplace</span><span class="s13">&lt;</span><span class="s1"><i>j</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1"><i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>j</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">std</span><span class="s13">::</span><span class="s1">move</span><span class="s16">(</span><span class="s1">rhs</span><span class="s16">)))</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Returns</i>: </span><span class="s13">*</span><span class="s20">this</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Remarks</i>: If </span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_trivially_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_trivially_move_assignable_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_trivially_destructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> for all <i>i</i>, and<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space">                                </span>- is_trivially_move_constructible_v&lt;Allocator&gt; &amp;&amp; is_trivially_move_assignable_v&lt;Allocator&gt; &amp;&amp; is_trivially_destructible_v&lt;Allocator&gt; is true</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- allocator_traits&lt;Allocator&gt;::is_always_equal::value is true or allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value is true<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>this assignment operator is trivial<a href="https://eel.is/c++draft/variant#assign-10.sentence-1"><span class="s35">.</span></a> </span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>The exception specification is equivalent to logical and operation of (allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp; allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value) and<span class="Apple-converted-space">  </span>is_nothrow_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_nothrow_move_assignable_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> for all <i>i</i>.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an exception is thrown during the call to T</span><span class="s38"><i>j</i></span><span class="s1">'s move construction (with <i>j</i> being rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">), the variant will hold no value.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an exception is thrown during the call to T</span><span class="s38"><i>j</i></span><span class="s1">'s move assignment, the state of the contained value is as defined by the exception safety guarantee of T</span><span class="s38"><i>j</i></span><span class="s1">'s move assignment; index</span><span class="s16">()</span><span class="s1"> will be <i>j</i>.</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p25"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T</span><span class="s13">&gt;</span><span class="s11"> </span><span class="s1">constexpr</span><span class="s11"> basic_variant</span><span class="s13">&amp;</span><span class="s11"> </span><span class="s1">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s11">T</span><span class="s13">&amp;&amp;</span><span class="s11"> t</span><span class="s16">)</span><span class="s11"> </span><span class="s1">noexcept</span><span class="s16">(</span><span class="s11"><i>see below</i></span><span class="s16">)</span><span class="s11">;</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span>Let T</span><span class="s38"><i>j</i></span><span class="s41"><i> </i></span><span class="s1">be a type that is determined as follows: build an imaginary function <i>FUN</i></span><span class="s16">(</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s16">)</span><span class="s1"> for each alternative type T</span><span class="s38"><i>i</i></span><span class="s1"> for which T</span><span class="s38"><i>i</i></span><span class="s1"> x</span><span class="s16">[]</span><span class="s1"> </span><span class="s13">=</span><span class="s1"> </span><span class="s16">{</span><span class="s1">std</span><span class="s13"> :: </span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">t</span><span class="s16">)}</span><span class="s1">; is well-formed for some invented variable x<a href="https://eel.is/c++draft/variant#assign-11.sentence-1"><span class="s35">.</span></a> The overload <i>FUN</i></span><span class="s16">(</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s16">)</span><span class="s1"> selected by overload resolution for the expression <i>FUN</i></span><span class="s16">(</span><span class="s1">std</span><span class="s13"> :: </span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1"> t</span><span class="s16">))</span><span class="s1"> defines the alternative T</span><span class="s38"><i>j</i></span><span class="s1"> which is the type of the contained value after assignment.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>:</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- is_same_v</span><span class="s13">&lt;</span><span class="s1">remove_cvref_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s1">, variant</span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">false</span><span class="s1">,</span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- is_assignable_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s13">&amp;</span><span class="s1">, T</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s1">, T</span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">, and</span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- the expression <i>FUN</i></span><span class="s16">(</span><span class="s1">std</span><span class="s13"> :: </span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">t</span><span class="s16">))</span><span class="s1"> (with <i>FUN</i> being the above-mentioned set of imaginary functions) is well-formed<a href="https://eel.is/c++draft/variant#assign-12.sentence-1"><span class="s35">.</span></a></span></p>
<p class="p26"><span class="s52"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s1">[<i>Note </i>:</span><span class="s44"> </span></p>
<p class="p48"><span class="s1"><span class="Apple-converted-space">                             </span></span><span class="s19">variant</span><span class="s57">&lt;</span><span class="s19">string, string</span><span class="s57">&gt;</span><span class="s19"> v;</span></p>
<ul class="ul2">
  <ul class="ul3">
    <ul class="ul4">
      <li class="li26"><span class="s6"></span><span class="s1"><span class="Apple-converted-space">                                    </span>v </span><span class="s13">=</span><span class="s1"> </span><span class="s24">"abc"</span><span class="s1">;</span></li>
    </ul>
  </ul>
  <li class="li26"><span class="s6"></span><span class="s1"><span class="Apple-converted-space">                    </span>is ill-formed, as both alternative types have an equally viable constructor for the argument<a href="https://eel.is/c++draft/variant#assign-12.3.sentence-2"><span class="s32">.</span></a> — <i>end note</i>]</span></li>
</ul>
<p class="p19"><span class="s21"><i><span class="Apple-tab-span">	</span>Effects</i>:</span><span class="s40"><br>
</span><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- If </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> holds a T</span><span class="s53"><i>j</i></span><span class="s21">, assigns std</span><span class="s23"> :: </span><span class="s21">forward</span><span class="s23">&lt;</span><span class="s21">T</span><span class="s23">&gt;</span><span class="s25">(</span><span class="s21">t</span><span class="s25">)</span><span class="s21"> to the value contained in </span><span class="s23">*</span><span class="s22">this</span><span class="s21">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise, if<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- uses_allocator_v&lt;remove_cvref_t &lt;Tj&gt;, Allocator&gt; is false or allocator_traits&lt;Allocator&gt;::is_always_equal::value is true, and<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- either is_nothrow_copy_constructible_v&lt;T</span><span class="s38"><i>j</i></span><span class="s1">&gt; is true or is_nothrow_move_constructible_v&lt;T</span><span class="s38"><i>j</i></span><span class="s1">&gt; is false</span><span class="s19">,</span></p>
<p class="p43"><span class="s19"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s1"> destroys the current alternative, if any, and direct-non-list-initializes the contained value of type T</span><span class="s38">j</span><span class="s41"> </span><span class="s1">with std::forward&lt;T&gt;(t).</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, equivalent to emplace</span><span class="s13">&lt;</span><span class="s1"><i>j</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s16">(</span><span class="s1">std</span><span class="s13">::</span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">t</span><span class="s16">)))</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Postconditions</i>: holds_alternative</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s13">*</span><span class="s20">this</span><span class="s16">)</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">, with T</span><span class="s38"><i>j</i></span><span class="s1"> selected by the imaginary function overload resolution described above<a href="https://eel.is/c++draft/variant#assign-14.sentence-1"><span class="s35">.</span></a></span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Returns</i>: </span><span class="s13">*</span><span class="s20">this<a href="https://eel.is/c++draft/variant#assign-15.sentence-1"><span class="s46">.</span></a></span></p>
<p class="p26"><span class="s52"><i><span class="Apple-tab-span">	</span>Remarks</i>: The exception specification is equivalent to:</span><span class="s1"> is_nothrow_assignable_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s58"><i>j</i></span><span class="s13">&amp;</span><span class="s1">, T</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_nothrow_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s58"><i>j</i></span><span class="s1">, T</span><span class="s13">&gt; &amp;&amp; (!uses_allocator_v&lt;</span><span class="s52">remove_cvref_t </span><span class="s13">&lt;Tj&gt;, Allocator&gt; || allocator_traits&lt;Allocator&gt;::is_always_equal::value</span><span class="s52">)</span></p>
<p class="p43"><span class="s40"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">If an exception is thrown during the assignment of std</span><span class="s13">::</span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">t</span><span class="s16">)</span><span class="s1"> to the value contained in </span><span class="s13">*</span><span class="s20">this</span><span class="s1">, the state of the contained value and t are as defined by the exception safety guarantee of the assignment expression; valueless_by_exception</span><span class="s16">()</span><span class="s1"> will be </span><span class="s24">false<a href="https://eel.is/c++draft/variant#assign-16.1.sentence-1"><span class="s46">.</span></a></span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an exception is thrown during the initialization of the contained value, the variant object is permitted to not hold a value.</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p25"><span class="s1">template&lt;class AllocatorU&gt;</span></p>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> basic_variant&lt;allocatorU, Types…&gt;</span><span class="s13">&amp;</span><span class="s1"> rhs</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span>Let <i>j</i> be rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">().</span></p>
<p class="p49"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: is_copy_constructible_v&lt;T</span><span class="s38"><i>i</i></span><span class="s1">&gt; &amp;&amp; is_copy_assignable_v&lt;T</span><span class="s38"><i>i</i></span><span class="s1">&gt; is true for all <i>i</i></span><span class="s49">.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>:<span class="Apple-converted-space"> </span></span></p>
<p class="p19"><span class="s21"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value is true, sets alloc to rhs.alloc</span><span class="s1"><br>
</span><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- If neither </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> nor rhs holds a value, there is no additional effect.</span><span class="s40"><br>
</span><span class="s21"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> holds a value but rhs does not, destroys the value contained in </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> and sets </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> to not hold a value</span><span class="s40"><br>
</span><span class="s21"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if index</span><span class="s25">()</span><span class="s21"> </span><span class="s23">==</span><span class="s21"> <i>j</i>, assigns the value contained in rhs to the value contained in </span><span class="s23">*</span><span class="s22">this</span><span class="s21">,</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- uses_allocator_v&lt;remove_cv_t&lt;Tj&gt;&gt;, Allocator&gt; is false or allocator_traits&lt;Allocator&gt;::is_always_equal::value is true, and<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- either is_nothrow_copy_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> or is_nothrow_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">false,</span></p>
<p class="p43"><span class="s19"><span class="Apple-converted-space">                           </span></span><span class="s1">destroys the current alternative, if any, and direct-non-list-initializes the contained value of type T</span><span class="s38">j</span><span class="s41"> </span><span class="s1">with GET</span><span class="s13">&lt;</span><span class="s1">j</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">rhs</span><span class="s16">))</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, equivalent to </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s1">basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg, alloc, rhs</span><span class="s16">))</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i>Postconditions</i>: index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">==</span><span class="s1"> rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span></p>
<p class="p43"><span class="s1"><i>Returns</i>: </span><span class="s13">*</span><span class="s20">this</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i>Remarks</i>: This operator is defined as deleted if is_convertible_v&lt;const AllocatorU&amp;, Allocator&gt; is false.<span class="Apple-converted-space"> </span></span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p50"><span class="s1">template&lt;class AllocatorU&gt;</span></p>
<p class="p33"><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s1">basic_variant&lt;</span><span class="s11">allocatorU, Types…&gt; </span><span class="s13">&amp;&amp;</span><span class="s1"> rhs</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1"><i>see below</i></span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p44"><span class="s1"><span class="Apple-tab-span">	</span>Let <i>j</i> be rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">.</span></p>
<p class="p44"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: is_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_move_assignable_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> for all <i>i</i><a href="https://eel.is/c++draft/variant#assign-7.sentence-1"><span class="s35">.</span></a></span></p>
<p class="p44"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>:</span></p>
<p class="p51"><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- If allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value is true, sets alloc to rhs.alloc</span><span class="s1"><br>
</span><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- If neither </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> nor rhs holds a value, there is no effect.</span></p>
<p class="p51"><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise, if </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> holds a value but rhs does not, destroys the value contained in </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> and sets </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> to not hold a value.</span><span class="s40"><br>
</span><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise, if index</span><span class="s25">()</span><span class="s21"> </span><span class="s23">==</span><span class="s21"> <i>j</i>, assigns <i>GET</i></span><span class="s23">&lt;</span><span class="s21"><i>j</i></span><span class="s23">&gt;</span><span class="s25">(</span><span class="s21">std</span><span class="s23">::</span><span class="s21">move</span><span class="s25">(</span><span class="s21">rhs</span><span class="s25">))</span><span class="s21"> to the value contained in </span><span class="s23">*</span><span class="s22">this</span><span class="s21">.</span></p>
<p class="p44"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise,<span class="Apple-converted-space">  </span>if allocator_traits&lt;Allocator&gt;::is_always_equal::value is true or allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value is true, destroys the current alternative, if any, and direct-non-list-initializes the contained value of type T</span><span class="s38">j</span><span class="s41"> </span><span class="s1">with GET</span><span class="s13">&lt;</span><span class="s1">j</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">std</span><span class="s13">::</span><span class="s1">move</span><span class="s16">(</span><span class="s1">rhs</span><span class="s16">)))</span><span class="s1">.</span></p>
<p class="p44"><span class="s1"><span class="Apple-converted-space">                      </span>- Otherwise equivalent to emplace</span><span class="s13">&lt;</span><span class="s1"><i>j</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1"><i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>j</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">std</span><span class="s13">::</span><span class="s1">move</span><span class="s16">(</span><span class="s1">rhs</span><span class="s16">)))</span><span class="s1">.</span></p>
<p class="p44"><span class="s1"><span class="Apple-tab-span">	</span><i>Returns</i>: </span><span class="s13">*</span><span class="s20">this</span><span class="s1">.</span></p>
<p class="p44"><span class="s1"><i><span class="Apple-tab-span">	</span>Remarks</i>:<span class="Apple-converted-space"> </span></span></p>
<p class="p44"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>The exception specification is equivalent to logical and operation of (allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp; allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value) and<span class="Apple-converted-space">  </span>is_nothrow_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_nothrow_move_assignable_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> for all <i>i</i>.</span></p>
<p class="p44"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an exception is thrown during the call to T</span><span class="s38"><i>j</i></span><span class="s1">'s move construction (with <i>j</i> being rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">), the variant will hold no value.</span></p>
<p class="p44"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an exception is thrown during the call to T</span><span class="s38"><i>j</i></span><span class="s1">'s move assignment, the state of the contained value is as defined by the exception safety guarantee of T</span><span class="s38"><i>j</i></span><span class="s1">'s move assignment; index</span><span class="s16">()</span><span class="s1"> will be <i>j</i>.</span></p>
<p class="p49"><span class="s11"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">This operator is defined as deleted if is_convertible_v&lt;const AllocatorU&amp;, Allocator&gt; is false.</span></p>
<p class="p52"><span class="s1"></span><br></p>
<p class="p52"><span class="s1"></span><br></p>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant&lt;Types…&gt;</span><span class="s13">&amp;</span><span class="s1"> rhs</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span>Let <i>j</i> be rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">().</span></p>
<p class="p53"><span class="s11"><i><span class="Apple-tab-span">	</span></i></span><span class="s1"><i>Constraints</i>: is_copy_constructible_v&lt;T</span><span class="s38"><i>i</i></span><span class="s1">&gt; &amp;&amp; is_copy_assignable_v&lt;T</span><span class="s38"><i>i</i></span><span class="s1">&gt; is true for all <i>i</i></span><span class="s49">.</span></p>
<p class="p44"><span class="s59"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Effects</i>:<span class="Apple-converted-space"> </span></span></p>
<p class="p19"><span class="s21"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If neither </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> nor rhs holds a value, there is no additional effect.</span><span class="s40"><br>
</span><span class="s21"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> holds a value but rhs does not, destroys the value contained in </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> and sets </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> to not hold a value</span><span class="s40"><br>
</span><span class="s21"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if index</span><span class="s25">()</span><span class="s21"> </span><span class="s23">==</span><span class="s21"> <i>j</i>, assigns the value contained in rhs to the value contained in </span><span class="s23">*</span><span class="s22">this</span><span class="s21">,</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- uses_allocator_v&lt;remove_cv_t&lt;Tj&gt;&gt;, Allocator&gt; is false or allocator_traits&lt;Allocator&gt;::is_always_equal::value is true, and<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space">     <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- either is_nothrow_copy_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> or is_nothrow_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>j</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">false,</span></p>
<p class="p43"><span class="s19"><span class="Apple-converted-space">                           </span></span><span class="s1">destroys the current alternative, if any, and direct-non-list-initializes the contained value of type T</span><span class="s38">j</span><span class="s41"> </span><span class="s1">with GET</span><span class="s13">&lt;</span><span class="s1">j</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">rhs</span><span class="s16">))</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, equivalent to </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(</span><span class="s1">basic_variant</span><span class="s16">(</span><span class="s1">allocator_arg, alloc, rhs</span><span class="s16">))</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i>Postconditions</i>: index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">==</span><span class="s1"> rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span></p>
<p class="p43"><span class="s1"><i>Returns</i>: </span><span class="s13">*</span><span class="s20">this</span><span class="s1">.</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> basic_variant</span><span class="s13">&amp;</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">=</span><span class="s16">(v</span><span class="s11">ariant&lt;Types…&gt;</span><span class="s13">&amp;&amp;</span><span class="s1"> rhs</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1"><i>see below</i></span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span>Let <i>j</i> be rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: is_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_move_assignable_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> for all <i>i</i>.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>:</span></p>
<p class="p19"><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- If neither </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> nor rhs holds a value, there is no effect.</span></p>
<p class="p19"><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise, if </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> holds a value but rhs does not, destroys the value contained in </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> and sets </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> to not hold a value.</span><span class="s40"><br>
</span><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise, if index</span><span class="s25">()</span><span class="s21"> </span><span class="s23">==</span><span class="s21"> <i>j</i>, assigns <i>GET</i></span><span class="s23">&lt;</span><span class="s21"><i>j</i></span><span class="s23">&gt;</span><span class="s25">(</span><span class="s21">std</span><span class="s23">::</span><span class="s21">move</span><span class="s25">(</span><span class="s21">rhs</span><span class="s25">))</span><span class="s21"> to the value contained in </span><span class="s23">*</span><span class="s22">this</span><span class="s21">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>- Otherwise,<span class="Apple-converted-space">  </span>if allocator_traits&lt;Allocator&gt;::is_always_equal::value is true or allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value is true, destroys the current alternative, if any, and direct-non-list-initializes the contained value of type T</span><span class="s38">j</span><span class="s41"> </span><span class="s1">with GET</span><span class="s13">&lt;</span><span class="s1">j</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">std</span><span class="s13">::</span><span class="s1">move</span><span class="s16">(</span><span class="s1">rhs</span><span class="s16">)))</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-converted-space">                      </span>- Otherwise equivalent to emplace</span><span class="s13">&lt;</span><span class="s1"><i>j</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1"><i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>j</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">std</span><span class="s13">::</span><span class="s1">move</span><span class="s16">(</span><span class="s1">rhs</span><span class="s16">)))</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Returns</i>: </span><span class="s13">*</span><span class="s20">this</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Remarks</i>:<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>The exception specification is equivalent to logical and operation of (allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp; allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value) and<span class="Apple-converted-space">  </span>is_nothrow_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_nothrow_move_assignable_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> for all <i>i</i>.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an exception is thrown during the call to T</span><span class="s38"><i>j</i></span><span class="s1">'s move construction (with <i>j</i> being rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">), the variant will hold no value.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an exception is thrown during the call to T</span><span class="s38"><i>j</i></span><span class="s1">'s move assignment, the state of the contained value is as defined by the exception safety guarantee of T</span><span class="s38"><i>j</i></span><span class="s1">'s move assignment; index</span><span class="s16">()</span><span class="s1"> will be <i>j</i>.</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p27"><span class="s11"><b> </b></span><span class="s27"><b>Modifiers</b></span><span class="s21"><b> [variant.basic.mod]</b></span></p>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d"><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> T, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Args</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">constexpr</span><span class="s1"> T</span><span class="s13">&amp;</span><span class="s1"> emplace</span><span class="s16">(</span><span class="s1">Args</span><span class="s13">&amp;&amp;...</span><span class="s1"> args</span><span class="s16">)</span><span class="s1">;</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>: is_constructible_v</span><span class="s13">&lt;</span><span class="s1">T, Args</span><span class="s13">...&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">, and T occurs exactly once in Types.</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Equivalent to:</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s20">return</span><span class="s1"> emplace</span><span class="s13">&lt;</span><span class="s52"><i>I</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">std</span><span class="s13">::</span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">Args</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">args</span><span class="s16">)</span><span class="s13">...</span><span class="s16">)</span><span class="s1">;</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d"><span class="s19"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">where <i>I</i> is the zero-based index of T in Types.</span></h4>
<h4 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d; min-height: 16.0px"><span class="s1"></span><br></h4>
<p class="p25"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s11"> U, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> T</span><span class="s13">&amp;</span><span class="s1"> emplace</span><span class="s16">(</span><span class="s1">initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;</span><span class="s1"> il, Args</span><span class="s13">&amp;&amp;...</span><span class="s1"> args</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Constraints</i>: is_constructible_v</span><span class="s13">&lt;</span><span class="s1">T, initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;&amp;</span><span class="s1">, Args</span><span class="s13">...&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">, and T occurs exactly once in Types.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Equivalent to:</span></p>
<p class="p26"><span class="s20"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>return</span><span class="s1"> emplace</span><span class="s13">&lt;</span><span class="s52"><i>I</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">il, std</span><span class="s13">::</span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">Args</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">args</span><span class="s16">)</span><span class="s13">...</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>where <i>I</i> is the zero-based index of T in Types.</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant</span><span class="s13">&lt;Allocator, </span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;</span><span class="s1"> emplace</span><span class="s16">(</span><span class="s1">Args</span><span class="s13">&amp;&amp;...</span><span class="s1"> args</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Mandates</i>: I &lt; </span><span class="s20">sizeof</span><span class="s13">...</span><span class="s16">(</span><span class="s1">Types</span><span class="s16">)</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: is_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>I</i></span><span class="s1">, Args</span><span class="s13">...&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Destroys the currently contained value if valueless_by_exception</span><span class="s16">()</span><span class="s1"> is </span><span class="s24">false</span><span class="s1">. Constructs an alternative of type T</span><span class="s38"><i>I</i></span><span class="s1"> by uses-allocator construction with allocator alloc and std</span><span class="s13">::</span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">Args</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">args</span><span class="s16">)</span><span class="s13">… </span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Postconditions</i>: index</span><span class="s16">()</span><span class="s1"> is I<a href="https://eel.is/c++draft/variant#mod-8.sentence-1"><span class="s35">.</span></a></span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Returns</i>: A reference to the new contained value.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown during the initialization of the contained value.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: If an exception is thrown during the initialization of the contained value, the variant is permitted to not hold a value.</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s1"> U, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Args</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant </span><span class="s13">&lt;Allocator, </span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span>emplace</span><span class="s16">(</span><span class="s1">initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;</span><span class="s1"> il, Args</span><span class="s13">&amp;&amp;...</span><span class="s1"> args</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Mandates</i>: I &lt; </span><span class="s20">sizeof</span><span class="s13">...</span><span class="s16">(</span><span class="s1">Types</span><span class="s16">)</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Constraints</i>: is_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>I</i></span><span class="s1">, initializer_list</span><span class="s13">&lt;</span><span class="s1">U</span><span class="s13">&gt;&amp;</span><span class="s1">, Args</span><span class="s13">...&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>: Destroys the currently contained value if valueless_by_exception</span><span class="s16">()</span><span class="s1"> is </span><span class="s24">false</span><span class="s1">. Constructs an alternative of type T</span><span class="s38"><i>I</i></span><span class="s1"> by uses-allocator construction with allocator alloc and il, std</span><span class="s13"> :: </span><span class="s1">forward</span><span class="s13">&lt;</span><span class="s1">Args</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">args</span><span class="s16">)</span><span class="s13">... .</span></p>
<p class="p43"><span class="s13"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Postconditions</i>: index</span><span class="s16">()</span><span class="s1"> is I.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Returns</i>: A reference to the new contained value.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: Any exception thrown during the initialization of the contained value.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: If an exception is thrown during the initialization of the contained value, the variant is permitted to not hold a value.<span class="Apple-converted-space"> </span></span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p31"><span class="s11"><b>Value status</b></span><span class="s1"><b> [variant.basic.status]<span class="Apple-converted-space">   </span></b></span></p>
<p class="p54"><span class="s1"><b></b></span><br></p>
<p class="p54"><span class="s1"><b></b></span><br></p>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> valueless_by_exception</span><span class="s16">()</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p43"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Effects</i>: Returns </span><span class="s24">false</span><span class="s1"> if and only if the variant holds a value.</span></p>
<p class="p26"><span class="s52"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s1">[<i>Note </i></span><span class="s18"><i>1</i></span><span class="s1">:</span><span class="s44"> </span><span class="s1">It is possible for a basic_variant to hold no value if an exception is thrown during a type-changing assignment or emplacement<a href="https://eel.is/c++draft/variant#status-2.sentence-1"><span class="s32">.</span></a> The latter means that even a basic_variant</span><span class="s13">&lt;</span><span class="s20">float</span><span class="s1">, </span><span class="s20">int</span><span class="s13">&gt;</span><span class="s1"> can become valueless_by_exception</span><span class="s16">()</span><span class="s1">, for instance by</span></p>
<p class="p25"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>struct</span><span class="s11"> S </span><span class="s16">{</span><span class="s11"> </span><span class="s1">operator</span><span class="s11"> </span><span class="s1">int</span><span class="s16">()</span><span class="s11"> </span><span class="s16">{</span><span class="s11"> </span><span class="s1">throw</span><span class="s11"> </span><span class="s24">42</span><span class="s11">; </span><span class="s16">}}</span><span class="s11">;</span></p>
<p class="p24"><span class="s11"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>basic_variant </span><span class="s1">&lt;std::allocator&lt;char&gt;, </span><span class="s20">float</span><span class="s11">, </span><span class="s20">int</span><span class="s1">&gt;</span><span class="s11"> v</span><span class="s16">{</span><span class="s24">12.f</span><span class="s16">}</span><span class="s11">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>v</span><span class="s13">.</span><span class="s1">emplace</span><span class="s13">&lt;</span><span class="s24">1</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">S</span><span class="s16">())</span><span class="s1">;</span></p>
<p class="p26"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>— <i>end note</i>]<span class="Apple-converted-space"> </span></span></p>
<p class="p55"><span class="s1"></span><br></p>
<p class="p25"><span class="s1">constexpr</span><span class="s11"> size_t index</span><span class="s16">()</span><span class="s11"> </span><span class="s1">const</span><span class="s11"> </span><span class="s1">noexcept</span><span class="s11">;</span></p>
<p class="p43"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Effects</i>: If valueless_by_exception</span><span class="s16">()</span><span class="s1"> is </span><span class="s24">true</span><span class="s1">, returns variant_npos<a href="https://eel.is/c++draft/variant#status-3.sentence-1"><span class="s35">.</span></a> Otherwise, returns the zero-based index of the alternative of the contained value.</span></p>
<p class="p47"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000dc; background-color: #31ff0d"><span class="s60"><b>Allocator </b></span><span class="s1"><b>[variant.basic.all]</b></span></h3>
<h3 style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d"><span class="s1">allocator_type get_allocator</span><span class="s16">()</span><span class="s1"> </span><span class="s20">const</span><span class="s1">;</span></h3>
<h3 style="margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d"><span class="s1"><i>Returns</i>: A copy of the Allocator that was passed to the object's constructor or, if that allocator has been replaced, a copy of the most recent replacement.<span class="Apple-converted-space"> </span></span></h3>
<h3 style="margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000; background-color: #31ff0d; min-height: 16.0px"><span class="s1"></span><br></h3>
<h3 style="margin: 0.0px 0.0px 0.0px 0.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #0000dc; background-color: #31ff0d"><span class="s11"><b>Swap</b></span><span class="s1"><b> [variant.basic.swap]</b></span></h3>
<p class="p26"><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">void</span><span class="s1"> swap</span><span class="s16">(</span><span class="s1">basic_variant</span><span class="s13">&amp;</span><span class="s1"> rhs</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1"><i>see below</i></span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Mandates</i>: is_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> for all <i>i</i>.</span></p>
<p class="p43"><span class="s1"><i><span class="Apple-tab-span">	</span>Preconditions</i>: Each T</span><span class="s38"><i>i </i></span><span class="s1">meets the <i>Cpp17Swappable</i> requirements (<a href="https://eel.is/c++draft/swappable.requirements"><span class="s42">[swappable.requirements]</span></a>)</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Effects</i>:  </span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If allocator_traits</span><span class="s13">&lt;</span><span class="s1">Allocator</span><span class="s13">&gt;::</span><span class="s1">propagate_on_container_swap</span><span class="s13">::</span><span class="s1">value is </span><span class="s24">true</span><span class="s1">, then Allocator shall meet the <i>Cpp17Swappable</i> requirements and the allocators of *this and res shall also be exchanged by calling swap as described in <a href="https://eel.is/c++draft/swappable.requirements"><span class="s42">[swappable.requirements]</span></a><a href="https://eel.is/c++draft/container.reqmts#65.sentence-3"><span class="s35">.</span></a> Otherwise, the allocators shall not be swapped, and the behavior is undefined unless *this</span><span class="s13">.</span><span class="s1">get_allocator</span><span class="s16">()</span><span class="s1"> </span><span class="s13">==</span><span class="s1"> rhs</span><span class="s13">.</span><span class="s1">get_allocator</span><span class="s16">()</span><span class="s1">.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- If valueless_by_exception</span><span class="s16">()</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> rhs</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">()</span><span class="s1"> no additional effect.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, if index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">==</span><span class="s1"> rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">, calls swap</span><span class="s16">(</span><span class="s1"><i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s13">*</span><span class="s20">this</span><span class="s16">)</span><span class="s1">, <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">rhs</span><span class="s16">))</span><span class="s1"> where <i>i</i> is index</span><span class="s16">()</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>- Otherwise, exchanges values of rhs and </span><span class="s13">*</span><span class="s20">this</span><span class="s1">.</span></p>
<p class="p43"><span class="s1"><span class="Apple-tab-span">	</span><i>Throws</i>: If index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">==</span><span class="s1"> rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">, any exception thrown by swap</span><span class="s16">(</span><span class="s1"><i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s13">*</span><span class="s20">this</span><span class="s16">)</span><span class="s1">, <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">rhs</span><span class="s16">))</span><span class="s1"> with <i>i</i> being index</span><span class="s16">()<a href="https://eel.is/c++draft/variant#swap-4.sentence-1"><span class="s46">.</span></a></span><span class="s1"> Otherwise, any exception thrown by the move constructor of T</span><span class="s38"><i>i</i></span><span class="s1"> or T</span><span class="s38"><i>j</i></span><span class="s1"> with <i>i</i> being index</span><span class="s16">()</span><span class="s1"> and <i>j</i> being rhs</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">.</span></p>
<p class="p19"><span class="s21"><span class="Apple-tab-span">	</span><i>Remarks</i>: If an exception is thrown during the call to function swap</span><span class="s25">(</span><span class="s21"><i>GET</i></span><span class="s23">&lt;</span><span class="s21"><i>i</i></span><span class="s23">&gt;</span><span class="s25">(</span><span class="s23">*</span><span class="s22">this</span><span class="s25">)</span><span class="s21">, <i>GET</i></span><span class="s23">&lt;</span><span class="s21"><i>i</i></span><span class="s23">&gt;</span><span class="s25">(</span><span class="s21">rhs</span><span class="s25">))</span><span class="s21">, the states of the contained values of </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> and of rhs are determined by the exception safety guarantee of swap for lvalues of T</span><span class="s53"><i>i</i></span><span class="s21"> with <i>i</i> being index</span><span class="s25">()<a href="https://eel.is/c++draft/variant#swap-5.sentence-1"><span class="s46">.</span></a></span><span class="s21"> If an exception is thrown during the exchange of the values of </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> and rhs, the states of the values of </span><span class="s23">*</span><span class="s22">this</span><span class="s21"> and of rhs are determined by the exception safety guarantee of variant's move constructor<a href="https://eel.is/c++draft/variant#swap-5.sentence-2"><span class="s35">.</span></a> The exception specification is equivalent to the logical and of is_nothrow_move_constructible_v</span><span class="s23">&lt;</span><span class="s21">T</span><span class="s53"><i>i</i></span><span class="s23">&gt;</span><span class="s21"> </span><span class="s23">&amp;&amp;</span><span class="s21"> is_nothrow_swappable_v</span><span class="s23">&lt;</span><span class="s21">T</span><span class="s53"><i>i</i></span><span class="s23">&gt;</span><span class="s21"> for all <i>i</i>.</span><span class="s1"><br>
</span></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s61"><b>Add to </b><a href="https://eel.is/c++draft/variant#helper"><span class="s62"><b>22.6.4</b></span></a></span><span class="s1"><b> variant helper classes</b></span></h3>
<p class="p58"><span class="s1">template</span><span class="s63">&lt;</span><span class="s1">class</span><span class="s63">...</span><span class="s64"> Types</span><span class="s63">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s65">struct</span><span class="s1"> variant_size</span><span class="s63">&lt;</span><span class="s1">variant</span><span class="s63">&lt;</span><span class="s1">Types</span><span class="s63">...&gt;&gt;</span><span class="s1"> </span><span class="s63">:</span><span class="s1"> integral_constant</span><span class="s63">&lt;</span><span class="s1">size_t, </span><span class="s65">sizeof</span><span class="s63">...</span><span class="s66">(</span><span class="s1">Types</span><span class="s66">)</span><span class="s63">&gt;</span><span class="s1"> </span><span class="s66">{</span><span class="s1"> </span><span class="s66">}</span><span class="s1">;</span></p>
<p class="p24"><span class="s20">template</span><span class="s1">&lt;class Allocator,<span class="Apple-converted-space">  </span></span><span class="s20">class</span><span class="s1">...</span><span class="s11"> Types</span><span class="s1">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">struct</span><span class="s1"> variant_size</span><span class="s13">&lt;basic_</span><span class="s1">variant</span><span class="s13">&lt;Allocator, </span><span class="s1">Types</span><span class="s13">...&gt;&gt;</span><span class="s1"> </span><span class="s13">:</span><span class="s1"> integral_constant</span><span class="s13">&lt;</span><span class="s1">size_t, </span><span class="s20">sizeof</span><span class="s13">...</span><span class="s16">(</span><span class="s1">Types</span><span class="s16">)</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s16">{</span><span class="s1"> </span><span class="s16">}</span><span class="s1">;</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p15"><span class="s1">…</span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p28"><span class="s1">variant_alternative</span><span class="s63">&lt;</span><span class="s1">I, variant</span><span class="s63">&lt;</span><span class="s1">Types</span><span class="s63">...&gt;&gt;::</span><span class="s1">type</span></p>
<p class="p26"><span class="s1">variant_alternative</span><span class="s13">&lt;</span><span class="s1">I, basic_variant</span><span class="s13">&lt;Allocator, </span><span class="s1">Types</span><span class="s13">...&gt;&gt;::</span><span class="s1">type</span></p>
<p class="p19"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Mandates</i>: I &lt; </span><span class="s20">sizeof</span><span class="s13">...</span><span class="s16">(</span><span class="s1">Types</span><span class="s16">)</span><span class="s1">.</span></p>
<p class="p19"><span class="s1"><span class="Apple-tab-span">	</span><i>Type</i>: The type T</span><span class="s38"><i>I</i></span><span class="s41"><i>.</i></span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s61"><b>Add to </b><a href="https://eel.is/c++draft/variant#get"><span class="s62"><b>22.6.5</b></span></a></span><span class="s1"><b> Value access</b></span></h3>
<p class="p59"><span class="s1"><br>
</span></p>
<p class="p22"><span class="s67">t</span><span class="s1">emplate</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> holds_alternative</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> T, class Allocator,<span class="Apple-converted-space">  </span></span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">  </span></span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">bool</span><span class="s21"> holds_alternative</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant</span><span class="s23">&lt;Allocator, </span><span class="s21">Types</span><span class="s23">...&gt;&amp;</span><span class="s21"> v</span><span class="s25">)</span><span class="s21"> </span><span class="s22">noexcept</span><span class="s21">;</span></p>
<p class="p19"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Mandates</i>: The type T occurs exactly once in Types.</span></p>
<p class="p19"><span class="s1"><span class="Apple-tab-span">	</span><i>Returns</i>: </span><span class="s24">true</span><span class="s1"> if index</span><span class="s16">()</span><span class="s1"> is equal to the zero-based index of T in Types</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p28"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;<span class="Apple-converted-space">                                  </span></span><span class="s14"><i>// exposition only</i></span></p>
<p class="p28"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;&amp;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">; <span class="Apple-converted-space">                                </span></span><span class="s14"><i>// exposition only</i></span></p>
<p class="p28"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;<span class="Apple-converted-space">                            </span></span><span class="s14"><i>// exposition only</i></span></p>
<p class="p28"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;&amp;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">; <span class="Apple-converted-space">                          </span></span><span class="s14"><i>// exposition only</i></span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, class Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&amp;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;<span class="Apple-converted-space">                                  </span></span><span class="s14"><i>// exposition only</i></span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, class Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&amp;&amp;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">; <span class="Apple-converted-space">                                </span></span><span class="s14"><i>// exposition only</i></span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, class Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&amp;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s16">(</span><span class="s20">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;<span class="Apple-converted-space">                            </span></span><span class="s14"><i>// exposition only</i></span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, class Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&amp;&amp;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">    </span><i>GET</i></span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s23">&amp;&amp;</span><span class="s21"> v</span><span class="s25">)</span><span class="s21">; <span class="Apple-converted-space">                          </span></span><span class="s26"><i>// exposition only</i></span></p>
<p class="p15"><span class="s1"><br>
</span></p>
<p class="p19"><span class="s1"><i><span class="Apple-tab-span">	</span>Mandates</i>: I &lt; </span><span class="s20">sizeof</span><span class="s13">...</span><span class="s16">(</span><span class="s1">Types</span><span class="s16">)</span><span class="s1">.</span></p>
<p class="p19"><span class="s1"><i><span class="Apple-tab-span">	</span>Preconditions</i>: v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> is I.</span></p>
<p class="p19"><span class="s1"><i><span class="Apple-tab-span">	</span>Returns</i>: A reference to the object stored in </span><span class="s68">the variant</span><span class="s1"> </span><span class="s21">v</span><span class="s1">.</span></p>
<p class="p60"><span class="s1">.</span></p>
<p class="p28"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p28"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&amp;&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p33"><span class="s1">template&lt;size_t I, class Allocator, class... Types&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1">template&lt;size_t I, class Allocator, class... Types&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&amp;&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1">template&lt;size_t I, class Allocator, class... Types&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s1">template&lt;size_t I, class Allocator, class... Types&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">  </span></span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">const</span><span class="s21"> variant_alternative_t</span><span class="s23">&lt;</span><span class="s21">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s23">&gt;&amp;&amp;</span><span class="s21"> get</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s23">&amp;&amp;</span><span class="s21"> v</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p19"><span class="s1"><i>Mandates</i>: I &lt; </span><span class="s20">sizeof</span><span class="s13">...</span><span class="s16">(</span><span class="s1">Types</span><span class="s16">)</span><span class="s1">.</span></p>
<p class="p19"><span class="s1"><i>Effects</i>: If v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> is I, returns a reference to the object stored in the </span><span class="s68">variant</span><span class="s1"> </span><span class="s21">v</span><span class="s1">. Otherwise, throws an exception of type bad_variant_access.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p15"><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> T, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">constexpr</span><span class="s1"> T</span><span class="s13">&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p15"><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> T, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">constexpr</span><span class="s1"> T</span><span class="s13">&amp;&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p22"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span><span class="s11"> </span><span class="s1">constexpr</span><span class="s11"> </span><span class="s1">const</span><span class="s11"> T</span><span class="s13">&amp;</span><span class="s11"> get</span><span class="s16">(</span><span class="s1">const</span><span class="s11"> variant</span><span class="s13">&lt;</span><span class="s11">Types</span><span class="s13">...&gt;&amp;</span><span class="s11"> v</span><span class="s16">)</span><span class="s11">;</span></p>
<p class="p22"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span><span class="s11"> </span><span class="s1">constexpr</span><span class="s11"> </span><span class="s1">const</span><span class="s11"> T</span><span class="s13">&amp;&amp;</span><span class="s11"> get</span><span class="s16">(</span><span class="s1">const</span><span class="s11"> variant</span><span class="s13">&lt;</span><span class="s11">Types</span><span class="s13">...&gt;&amp;&amp;</span><span class="s11"> v</span><span class="s16">)</span><span class="s11">;</span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> T, class Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">constexpr</span><span class="s1"> T</span><span class="s13">&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> T, class Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span><span class="s20">constexpr</span><span class="s1"> T</span><span class="s13">&amp;&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> T, class Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">const</span><span class="s1"> T</span><span class="s13">&amp;</span><span class="s1"> get</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&amp;</span><span class="s1"> v</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p15"><span class="s22">template</span><span class="s23">&lt;</span><span class="s22">class</span><span class="s21"> T, class Allocator, </span><span class="s22">class</span><span class="s23">...</span><span class="s21"> Types</span><span class="s23">&gt;</span><span class="s21"> </span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">const</span><span class="s21"> T</span><span class="s23">&amp;&amp;</span><span class="s21"> get</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s23">&amp;&amp;</span><span class="s21"> v</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p19"><span class="s1"><i>Mandates</i>: The type T occurs exactly once in Types.</span></p>
<p class="p19"><span class="s1"><i>Effects</i>: If v holds a value of type T, returns a reference to that value<a href="https://eel.is/c++draft/variant#get-9.sentence-1"><span class="s35">.</span></a> Otherwise, throws an exception of type bad_variant_access.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p28"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s1">variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;*</span><span class="s1"> v</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p28"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">size_t I, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&gt;&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;*</span><span class="s1"> v</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p26"><span class="s1">template&lt;size_t I, class Allocator, class... Types&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s1">variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">*</span><span class="s1"> v</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p26"><span class="s1">template&lt;size_t I, class Allocator, class... Types&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s20">const</span><span class="s1"> variant_alternative_t</span><span class="s13">&lt;</span><span class="s1">I, basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">&gt;&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">    </span>get_if</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s23">*</span><span class="s21"> v</span><span class="s25">)</span><span class="s21"> </span><span class="s22">noexcept</span><span class="s21">;</span></p>
<p class="p19"><span class="s1"><i>Mandates</i>: I &lt; </span><span class="s20">sizeof</span><span class="s13">...</span><span class="s16">(</span><span class="s1">Types</span><span class="s16">)</span><span class="s1">.</span></p>
<p class="p19"><span class="s1"><i>Returns</i>: A pointer to the value stored in </span><span class="s68">the variant</span><span class="s1"> </span><span class="s21">v</span><span class="s1">, if v </span><span class="s13">!=</span><span class="s1"> </span><span class="s24">nullptr</span><span class="s1"> and v</span><span class="s13">-&gt;</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">==</span><span class="s1"> I<a href="https://eel.is/c++draft/variant#get-11.sentence-1"><span class="s35">.</span></a> Otherwise, returns </span><span class="s24">nullptr<a href="https://eel.is/c++draft/variant#get-11.sentence-2"><span class="s46">.</span></a></span></p>
<p class="p60"><span class="s1"><br>
</span></p>
<p class="p61"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;*</span><span class="s1"> v</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p61"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s11"> T, </span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s20">const</span><span class="s1"> T</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;*</span><span class="s1"> v</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> T, class Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">    </span>get_if</span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Types...&gt;</span><span class="s13">*</span><span class="s1"> v</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s1">;</span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> T, class Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> add_pointer_t</span><span class="s13">&lt;</span><span class="s20">const</span><span class="s1"> T</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">    </span>get_if</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;Allocator, Types...&gt;</span><span class="s23">*</span><span class="s21"> v</span><span class="s25">)</span><span class="s21"> </span><span class="s22">noexcept</span><span class="s21">;</span></p>
<p class="p19"><span class="s1"><i>Mandates</i>: The type T occurs exactly once in Types.</span></p>
<p class="p19"><span class="s1"><i>Effects</i>: Equivalent to: </span><span class="s20">return</span><span class="s1"> get_if</span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1">; with <i>i</i> being the zero-based index of T in Types.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p30"><span class="s61"><b>Modify </b><a href="https://eel.is/c++draft/variant#relops"><span class="s62"><b>22.6.6</b></span></a></span><span class="s1"><b> Relational operators</b></span></p>
<p class="p30"><span class="s1"><br>
</span></p>
<p class="p61"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">==</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> w</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p26"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">class AllocatorV, class AllocatorW, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">  </span></span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">bool</span><span class="s21"> </span><span class="s22">operator</span><span class="s23">==</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorV, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> v, </span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorW, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> w</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p19"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1"> </span><span class="s13">==</span><span class="s1"> <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s20">bool</span><span class="s1">, for all <i>i</i>.</span></p>
<p class="p19"><span class="s1"><i>Returns</i>: If v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">!=</span><span class="s1"> w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">, </span><span class="s24">false</span><span class="s1">; otherwise if v</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">()</span><span class="s1">, </span><span class="s24">true</span><span class="s1">; otherwise <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1"> </span><span class="s13">==</span><span class="s1"> <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1"> with <i>i</i> being v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p61"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">!=</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> w</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p25"><span class="s1">template&lt;class </span><span class="s11">AllocatorV</span><span class="s1">, </span><span class="s11">class AllocatorW, </span><span class="s1">class... Types&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">  </span></span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">bool</span><span class="s21"> </span><span class="s22">operator</span><span class="s23">!=</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorV, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> v, </span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorW, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> w</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p19"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1"> </span><span class="s13">!=</span><span class="s1"> <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s20">bool</span><span class="s1">, for all <i>i</i>.</span></p>
<p class="p19"><span class="s1"><i>Returns</i>: If v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">!=</span><span class="s1"> w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">, </span><span class="s24">true</span><span class="s1">; otherwise if v</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">()</span><span class="s1">, </span><span class="s24">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1"> </span><span class="s13">!=</span><span class="s1"> <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1"> with <i>i</i> being v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p61"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">&lt;</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> w</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p25"><span class="s1">template&lt;class </span><span class="s11">AllocatorV</span><span class="s1">, </span><span class="s11">class AllocatorW, </span><span class="s1">class... Types&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">  </span></span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">bool</span><span class="s21"> </span><span class="s22">operator</span><span class="s23">&lt;</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorV, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> v, </span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorW, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> w</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p19"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1"> </span><span class="s13">&lt;</span><span class="s1"> <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s20">bool</span><span class="s1">, for all <i>i</i>.</span></p>
<p class="p19"><span class="s1"><i>Returns</i>: If w</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">()</span><span class="s1">, </span><span class="s24">false</span><span class="s1">; otherwise if v</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">()</span><span class="s1">, </span><span class="s24">true</span><span class="s1">; otherwise, if v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">&lt;</span><span class="s1"> w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">, </span><span class="s24">true</span><span class="s1">; otherwise if v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">&gt;</span><span class="s1"> w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">, </span><span class="s24">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1"> </span><span class="s13">&lt;</span><span class="s1"> <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1"> with <i>i</i> being v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p61"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">&gt;</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> w</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p25"><span class="s1">template&lt;class </span><span class="s11">AllocatorV</span><span class="s1">, </span><span class="s11">class AllocatorW, </span><span class="s1">class... Types&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">  </span></span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">bool</span><span class="s21"> </span><span class="s22">operator</span><span class="s23">&gt;</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorV, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> v, </span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorW, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> w</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p19"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1"> </span><span class="s13">&gt;</span><span class="s1"> <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s20">bool</span><span class="s1">, for all <i>i</i>.</span></p>
<p class="p19"><span class="s1"><i>Returns</i>: If v</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">()</span><span class="s1">, </span><span class="s24">false</span><span class="s1">; otherwise if w</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">()</span><span class="s1">, </span><span class="s24">true</span><span class="s1">; otherwise, if v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">&gt;</span><span class="s1"> w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">, </span><span class="s24">true</span><span class="s1">; otherwise if v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">&lt;</span><span class="s1"> w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">, </span><span class="s24">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1"> </span><span class="s13">&gt;</span><span class="s1"> <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1"> with <i>i</i> being v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p61"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">&lt;=</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> w</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p25"><span class="s1">template&lt;class </span><span class="s11">AllocatorV</span><span class="s1">, </span><span class="s11">class AllocatorW, </span><span class="s1">class... Types&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">  </span></span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">bool</span><span class="s21"> </span><span class="s22">operator</span><span class="s23">&lt;=</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorV, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> v, </span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorW, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> w</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p19"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1"> </span><span class="s13">&lt;=</span><span class="s1"> <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s20">bool</span><span class="s1">, for all <i>i</i>.</span></p>
<p class="p19"><span class="s1"><i>Returns</i>: If v</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">()</span><span class="s1">, </span><span class="s24">true</span><span class="s1">; otherwise if w</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">()</span><span class="s1">, </span><span class="s24">false</span><span class="s1">; otherwise, if v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">&lt;</span><span class="s1"> w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">, </span><span class="s24">true</span><span class="s1">; otherwise if v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">&gt;</span><span class="s1"> w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">, </span><span class="s24">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1"> </span><span class="s13">&lt;=</span><span class="s1"> <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1"> with <i>i</i> being v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p61"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">bool</span><span class="s1"> </span><span class="s20">operator</span><span class="s13">&gt;=</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> w</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p37"><span class="s1">template&lt;class </span><span class="s11">AllocatorV</span><span class="s1">, </span><span class="s11">class AllocatorW, </span><span class="s1">class... Types&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">  </span></span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">bool</span><span class="s21"> </span><span class="s22">operator</span><span class="s23">&gt;=</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorV, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> v, </span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorW, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> w</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p19"><span class="s1"><i>Mandates</i>: <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1"> </span><span class="s13">&gt;=</span><span class="s1"> <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1"> is a valid expression that is convertible to </span><span class="s20">bool</span><span class="s1">, for all <i>i</i>.</span></p>
<p class="p19"><span class="s1"><i>Returns</i>: If w</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">()</span><span class="s1">, </span><span class="s24">true</span><span class="s1">; otherwise if v</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">()</span><span class="s1">, </span><span class="s24">false</span><span class="s1">; otherwise, if v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">&gt;</span><span class="s1"> w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">, </span><span class="s24">true</span><span class="s1">; otherwise if v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">&lt;</span><span class="s1"> w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">, </span><span class="s24">false</span><span class="s1">; otherwise <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1"> </span><span class="s13">&gt;=</span><span class="s1"> <i>GET</i></span><span class="s13">&lt;</span><span class="s1"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1"> with <i>i</i> being v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p61"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span><span class="s11"> </span><span class="s1">requires</span><span class="s11"> </span><span class="s16">(<a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable"><span class="s28">three_way_comparable</span></a></span><span class="s13">&lt;</span><span class="s11">Types</span><span class="s13">&gt;</span><span class="s11"> </span><span class="s13">&amp;&amp;</span><span class="s11"> </span><span class="s13">...</span><span class="s16">)</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> common_comparison_category_t</span><span class="s13">&lt;</span><span class="s1">compare_three_way_result_t</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">&gt;...&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">    </span></span><span class="s20">operator</span><span class="s13">&lt;=&gt;</span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v, </span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> w</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p25"><span class="s1">template&lt;class </span><span class="s11">AllocatorV</span><span class="s1">, </span><span class="s11">class AllocatorW, </span><span class="s1">class... Types&gt;</span><span class="s11"> </span><span class="s1">requires</span><span class="s11"> </span><span class="s16">(<a href="https://eel.is/c++draft/cmp.concept#concept:three_way_comparable"><span class="s28">three_way_comparable</span></a></span><span class="s13">&lt;</span><span class="s11">Types</span><span class="s13">&gt;</span><span class="s11"> </span><span class="s13">&amp;&amp;</span><span class="s11"> </span><span class="s13">...</span><span class="s16">)</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> common_comparison_category_t</span><span class="s13">&lt;</span><span class="s1">compare_three_way_result_t</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">&gt;...&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space">    </span></span><span class="s22">operator</span><span class="s23">&lt;=&gt;</span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorV, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> v, </span><span class="s22">const</span><span class="s21"> basic_variant&lt;AllocatorW, Types...&gt;</span><span class="s23">&amp;</span><span class="s21"> w</span><span class="s25">)</span><span class="s21">;</span></p>
<p class="p19"><span class="s19"><span class="Apple-tab-span">	</span></span><span class="s1"><i>Effects</i>: Equivalent to:</span></p>
<p class="p15"><span class="s20"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if</span><span class="s1"> </span><span class="s16">(</span><span class="s1">v</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">()</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> w</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">())</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s20">return</span><span class="s1"> strong_ordering</span><span class="s13">::</span><span class="s1">equal;</span></p>
<p class="p15"><span class="s20"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if</span><span class="s1"> </span><span class="s16">(</span><span class="s1">v</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">())</span><span class="s1"> </span><span class="s20">return</span><span class="s1"> strong_ordering</span><span class="s13">::</span><span class="s1">less;</span></p>
<p class="p15"><span class="s20"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if</span><span class="s1"> </span><span class="s16">(</span><span class="s1">w</span><span class="s13">.</span><span class="s1">valueless_by_exception</span><span class="s16">())</span><span class="s1"> </span><span class="s20">return</span><span class="s1"> strong_ordering</span><span class="s13">::</span><span class="s1">greater;</span></p>
<p class="p15"><span class="s20"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if</span><span class="s1"> </span><span class="s16">(</span><span class="s20">auto</span><span class="s1"> c </span><span class="s13">=</span><span class="s1"> v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1"> </span><span class="s13">&lt;=&gt;</span><span class="s1"> w</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">; c </span><span class="s13">!=</span><span class="s1"> </span><span class="s24">0</span><span class="s16">)</span><span class="s1"> </span><span class="s20">return</span><span class="s1"> c;</span></p>
<p class="p15"><span class="s20"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>return</span><span class="s1"> \exposid</span><span class="s16">{</span><span class="s1">GET</span><span class="s16">}</span><span class="s13">&lt;</span><span class="s52"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">v</span><span class="s16">)</span><span class="s1"> </span><span class="s13">&lt;=&gt;</span><span class="s1"> \exposid</span><span class="s16">{</span><span class="s1">GET</span><span class="s16">}</span><span class="s13">&lt;</span><span class="s52"><i>i</i></span><span class="s13">&gt;</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p19"><span class="s1"><span class="Apple-tab-span">	</span>with <i>i</i> being v</span><span class="s13">.</span><span class="s1">index</span><span class="s16">()</span><span class="s1">.</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s61"><b>Modify </b><a href="https://eel.is/c++draft/variant#visit"><span class="s62"><b>22.6.7</b></span></a></span><span class="s1"><b> Visitation</b></span></h3>
<p class="p19"><span class="s1">Let <i>as-variant</i> denote the following exposition-only function templates:</span></p>
<p class="p22"><span class="s1"><span class="Apple-tab-span">	</span>template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Ts</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s20">auto</span><span class="s13">&amp;&amp;</span><span class="s1"> <i>as-variant</i></span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Ts</span><span class="s13">...&gt;&amp;</span><span class="s1"> var</span><span class="s16">)</span><span class="s1"> </span><span class="s16">{</span><span class="s1"> </span><span class="s20">return</span><span class="s1"> var; </span><span class="s16">}</span></p>
<p class="p22"><span class="s1"><span class="Apple-tab-span">	</span>template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Ts</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s20">auto</span><span class="s13">&amp;&amp;</span><span class="s1"> <i>as-variant</i></span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Ts</span><span class="s13">...&gt;&amp;</span><span class="s1"> var</span><span class="s16">)</span><span class="s1"> </span><span class="s16">{</span><span class="s1"> </span><span class="s20">return</span><span class="s1"> var; </span><span class="s16">}</span></p>
<p class="p22"><span class="s1"><span class="Apple-tab-span">	</span>template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Ts</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s20">auto</span><span class="s13">&amp;&amp;</span><span class="s1"> <i>as-variant</i></span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Ts</span><span class="s13">...&gt;&amp;&amp;</span><span class="s1"> var</span><span class="s16">)</span><span class="s1"> </span><span class="s16">{</span><span class="s1"> </span><span class="s20">return</span><span class="s1"> std</span><span class="s13">::</span><span class="s1">move</span><span class="s16">(</span><span class="s1">var</span><span class="s16">)</span><span class="s1">; </span><span class="s16">}</span></p>
<p class="p22"><span class="s1"><span class="Apple-tab-span">	</span>template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Ts</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s20">auto</span><span class="s13">&amp;&amp;</span><span class="s1"> <i>as-variant</i></span><span class="s16">(</span><span class="s20">const</span><span class="s1"> variant</span><span class="s13">&lt;</span><span class="s1">Ts</span><span class="s13">...&gt;&amp;&amp;</span><span class="s1"> var</span><span class="s16">)</span><span class="s1"> </span><span class="s16">{</span><span class="s1"> </span><span class="s20">return</span><span class="s1"> std</span><span class="s13">::</span><span class="s1">move</span><span class="s16">(</span><span class="s1">var</span><span class="s16">)</span><span class="s1">; </span><span class="s16">}</span></p>
<p class="p25"><span class="s1"><span class="Apple-tab-span">	</span>template&lt;class Allocator, class</span><span class="s13">...</span><span class="s11"> Ts</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s20">auto</span><span class="s13">&amp;&amp;</span><span class="s1"> <i>as-variant</i></span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Ts</span><span class="s13">...&gt;&amp;</span><span class="s1"> var</span><span class="s16">)</span><span class="s1"> </span><span class="s16">{</span><span class="s1"> </span><span class="s20">return</span><span class="s1"> var; </span><span class="s16">}</span></p>
<p class="p25"><span class="s1"><span class="Apple-tab-span">	</span>template&lt;class Allocator, class</span><span class="s13">...</span><span class="s11"> Ts</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s20">auto</span><span class="s13">&amp;&amp;</span><span class="s1"> <i>as-variant (</i></span><span class="s20">const</span><span class="s1"> basic_variant&lt;Allocator, Ts</span><span class="s13">...&gt;&amp;</span><span class="s1"> var</span><span class="s16">)</span><span class="s1"> </span><span class="s16">{</span><span class="s1"> </span><span class="s20">return</span><span class="s1"> var; </span><span class="s16">}</span></p>
<p class="p25"><span class="s1"><span class="Apple-tab-span">	</span>template&lt;class Allocator, class</span><span class="s13">...</span><span class="s11"> Ts</span><span class="s13">&gt;</span></p>
<p class="p26"><span class="s1"><span class="Apple-converted-space">  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s20">auto</span><span class="s13">&amp;&amp;</span><span class="s1"> <i>as-variant</i></span><span class="s16">(</span><span class="s1">basic_variant&lt;Allocator, Ts</span><span class="s13">...&gt;&amp;&amp;</span><span class="s1"> var</span><span class="s16">)</span><span class="s1"> </span><span class="s16">{</span><span class="s1"> </span><span class="s20">return</span><span class="s1"> std</span><span class="s13">::</span><span class="s1">move</span><span class="s16">(</span><span class="s1">var</span><span class="s16">)</span><span class="s1">; </span><span class="s16">}</span></p>
<p class="p25"><span class="s1"><span class="Apple-tab-span">	</span>template&lt;class Allocator, class</span><span class="s13">...</span><span class="s11"> Ts</span><span class="s13">&gt;</span></p>
<p class="p15"><span class="s21"><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span><span class="s22">auto</span><span class="s23">&amp;&amp;</span><span class="s21"> <i>as-variant</i></span><span class="s25">(</span><span class="s22">const</span><span class="s21"> basic_variant&lt;Allocator, Ts</span><span class="s23">...&gt;&amp;&amp;</span><span class="s21"> var</span><span class="s25">)</span><span class="s21"> </span><span class="s25">{</span><span class="s21"> </span><span class="s22">return</span><span class="s21"> std</span><span class="s23">::</span><span class="s21">move</span><span class="s25">(</span><span class="s21">var</span><span class="s25">)</span><span class="s21">; </span><span class="s25">}</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p19"><span class="s1"><span class="Apple-tab-span">	</span>Let <i>n</i> be </span><span class="s20">sizeof</span><span class="s13">...</span><span class="s16">(</span><span class="s1">Variants</span><span class="s16">)</span><span class="s1">…</span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 15.6px Times; color: #000000; -webkit-text-stroke: #0000dc"><span class="s1"><br>
</span></h3>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s61"><b>Modify </b><a href="https://eel.is/c++draft/variant#specalg"><span class="s62"><b>22.6.10</b></span></a></span><span class="s1"><b> Specialized algorithms</b></span></h3>
<p class="p61"><span class="s1">template</span><span class="s13">&lt;</span><span class="s1">class</span><span class="s13">...</span><span class="s11"> Types</span><span class="s13">&gt;</span></p>
<p class="p28"><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s20">constexpr</span><span class="s1"> </span><span class="s20">void</span><span class="s1"> swap</span><span class="s16">(</span><span class="s1">variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> v, variant</span><span class="s13">&lt;</span><span class="s1">Types</span><span class="s13">...&gt;&amp;</span><span class="s1"> w</span><span class="s16">)</span><span class="s1"> </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1"><i>see below</i></span><span class="s16">)</span><span class="s1">;</span></p>
<p class="p33"><span class="s20">template</span><span class="s13">&lt;</span><span class="s1">class Allocator,<span class="Apple-converted-space">  </span></span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span></p>
<h3 style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s21"><span class="Apple-converted-space">  </span></span><span class="s22">constexpr</span><span class="s21"> </span><span class="s22">void</span><span class="s21"> swap</span><span class="s25">(</span><span class="s23">basic_</span><span class="s21">variant</span><span class="s23">&lt;Allocator, </span><span class="s21">Types</span><span class="s23">...&gt;&amp;</span><span class="s21"> v, </span><span class="s23">basic_</span><span class="s21">variant</span><span class="s23">&lt;Allocator, </span><span class="s21">Types</span><span class="s23">...&gt;&amp;</span><span class="s21"> w</span><span class="s25">)</span><span class="s21"> </span><span class="s22">noexcept</span><span class="s25">(</span><span class="s21"><i>see below</i></span><span class="s25">)</span><span class="s21">;</span></h3>
<p class="p19"><span class="s1"><i><span class="Apple-tab-span">	</span>Constraints</i>: is_move_constructible_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> </span><span class="s13">&amp;&amp;</span><span class="s1"> is_swappable_v</span><span class="s13">&lt;</span><span class="s1">T</span><span class="s38"><i>i</i></span><span class="s13">&gt;</span><span class="s1"> is </span><span class="s24">true</span><span class="s1"> for all <i>i</i>.</span></p>
<p class="p19"><span class="s1"><i><span class="Apple-tab-span">	</span>Effects</i>: Equivalent to v</span><span class="s13">.</span><span class="s1">swap</span><span class="s16">(</span><span class="s1">w</span><span class="s16">)</span><span class="s1">.</span></p>
<p class="p19"><span class="s1"><span class="Apple-tab-span">	</span><i>Remarks</i>: The exception specification is equivalent to </span><span class="s20">noexcept</span><span class="s16">(</span><span class="s1">v</span><span class="s13">.</span><span class="s1">swap</span><span class="s16">(</span><span class="s1">w</span><span class="s16">))<a href="https://eel.is/c++draft/variant#specalg-3.sentence-1"><span class="s46">.</span></a></span></p>
<p class="p19"><span class="s1"><br>
</span></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s61"><b>Modify </b><a href="https://eel.is/c++draft/variant#hash"><span class="s62"><b>22.6.12</b></span></a></span><span class="s1"><b> Hash support</b></span></h3>
<p class="p28"><span class="s1"><br>
</span></p>
<p class="p33"><span class="s20">template</span><span class="s13">&lt;</span><span class="s20">class</span><span class="s1"> Allocator, </span><span class="s20">class</span><span class="s13">...</span><span class="s1"> Types</span><span class="s13">&gt;</span><span class="s1"> </span><span class="s20">struct</span><span class="s1"> hash</span><span class="s13">&lt;basic_</span><span class="s1">variant</span><span class="s13">&lt;Allocator, </span><span class="s1">Types</span><span class="s13">...&gt;&gt;</span><span class="s1">;</span></p>
<h3 style="margin: 0.0px 0.0px 13.3px 0.0px; text-align: justify; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s21">The specialization hash</span><span class="s23">&lt;basic_</span><span class="s21">variant</span><span class="s23">&lt;</span><span class="s69">Allocator , </span><span class="s21">Types</span><span class="s23">...&gt;&gt;</span><span class="s21"> is enabled (<a href="https://eel.is/c++draft/unord.hash"><span class="s42">[unord.hash]</span></a>) if and only if every specialization in hash</span><span class="s23">&lt;</span><span class="s21">remove_const_t</span><span class="s23">&lt;</span><span class="s21">Types</span><span class="s23">&gt;&gt;...</span><span class="s21"> is enabled<a href="https://eel.is/c++draft/variant#hash-1.sentence-1"><span class="s35">.</span></a> The member functions are not guaranteed to be </span><span class="s22">noexcept</span><span class="s21">.</span></h3>
<p class="p19"><span class="s1"><br>
</span></p>
<p class="p7"><span class="s1"><br>
</span></p>
</body>
</html>
